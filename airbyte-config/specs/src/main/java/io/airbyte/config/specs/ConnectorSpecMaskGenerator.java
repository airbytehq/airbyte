/*
 * Copyright (c) 2022 Airbyte, Inc., all rights reserved.
 */

package io.airbyte.config.specs;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import io.airbyte.commons.cli.Clis;
import io.airbyte.commons.io.IOs;
import io.airbyte.commons.yaml.Yamls;
import io.airbyte.config.DockerImageSpec;
import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.io.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This script is responsible for generating a set of connection configuration properties that have
 * been marked as <code>secret</code> and therefore should be automatically masked if/when the
 * configuration object is logged.
 * <p>
 * Specs are stored in a separate file from the definitions in an effort to keep the definitions
 * yaml files human-readable and easily-editable, as specs can be rather large.
 * <p>
 * The generated mask file is created in the same location as the spec files provided to this
 * script.
 */
public class ConnectorSpecMaskGenerator {

  private static final Logger LOGGER = LoggerFactory.getLogger(ConnectorSpecMaskGenerator.class);

  public static final String MASK_FILE = "specs_secrets_mask.yaml";
  private static final Option SPEC_ROOT_OPTION = Option.builder("s").longOpt("specs-root").hasArg(true).required(true)
      .desc("path to where spec files are stored").build();
  private static final Options OPTIONS = new Options().addOption(SPEC_ROOT_OPTION);

  public static void main(final String[] args) {
    final CommandLine parsed = Clis.parse(args, OPTIONS);
    final Path specRoot = Path.of(parsed.getOptionValue(SPEC_ROOT_OPTION.getOpt()));

    LOGGER.info("Looking for spec files in '{}'...", specRoot);

    final File[] inputFiles = specRoot.toFile().listFiles();

    if (inputFiles != null) {
      final Set<File> specFiles = Stream.of(inputFiles)
          .filter(file -> file.getName().endsWith("specs.yaml"))
          .collect(Collectors.toSet());

      LOGGER.info("Found {} spec files for processing.", specFiles.size());

      final Set<String> secretPropertyNames = specFiles.stream().map(ConnectorSpecMaskGenerator::readFile)
          .filter(file -> file != null)
          .map(ConnectorSpecMaskGenerator::deserializeYaml)
          .flatMap(List::stream)
          .map(ConnectorSpecMaskGenerator::findSecrets)
          .flatMap(Set::stream)
          .collect(Collectors.toCollection(TreeSet::new));

      final String outputString = String.format("# This file is generated by %s.\n", ConnectorSpecMaskGenerator.class.getName())
          + "# Do NOT edit this file directly. See generator class for more details.\n"
          + Yamls.serialize(Map.of("properties", secretPropertyNames));
      final Path outputPath = IOs.writeFile(specRoot.resolve(MASK_FILE), outputString);
      LOGGER.info("Finished generating spec mask file '{}'.", outputPath);
    } else {
      LOGGER.info("No spec files found in '{}'.  Nothing to generate.", specRoot);
    }
  }

  private static List<DockerImageSpec> deserializeYaml(final String yaml) {
    return Yamls.deserialize(yaml, new TypeReference<>() {});
  }

  private static Set<String> findSecrets(final DockerImageSpec spec) {
    final SpecMaskPropertyGenerator specMaskPropertyGenerator = new SpecMaskPropertyGenerator();
    final JsonNode properties = spec.getSpec().getConnectionSpecification().get("properties");
    return specMaskPropertyGenerator.getSecretFieldNames(properties);
  }

  private static String readFile(final File file) {
    try {
      LOGGER.info("Reading spec file '{}'...", file.getAbsolutePath());
      return FileUtils.readFileToString(file, Charset.defaultCharset());
    } catch (final IOException e) {
      LOGGER.error("Unable to read contents of '{}'.", file.getAbsolutePath(), e);
      return null;
    }
  }

}
