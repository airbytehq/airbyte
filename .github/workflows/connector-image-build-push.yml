name: Connector Image Build and Push (Python and Manifest-Only)
# This workflow builds and pushes connector images for Python and manifest-only connectors.
# It is intended to replace Airbyte-CI connector image builds and can be triggered manually or called from other workflows
# to publish connector images on merge to master.

on:
  # Available as a reusable workflow
  # (https://docs.github.com/en/actions/sharing-automations/reusing-workflows)
  workflow_call:
    inputs:
      connector-name:
        description: "Connector name (e.g., source-faker, destination-postgres)"
        required: true
        type: string
      # release-type:
      #   description: "Release type"
      #   required: true
      #   type: choice
      #   default: "pre-release"
      #   options:
      #     - "pre-release"
      #     - "main-release"
      registry:
        description: "Docker registry"
        required: false
        type: string
        default: "docker.io/airbyte"
      tag-override:
        description: "Override the image tag (optional). If not provided, the tag will be derived from the connector's metadata.yaml."
        required: false
        type: string
        default: ""
      push-latest:
        description: "if pushing the image, to a remote registry, also push it with the 'latest' tag"
        required: false
        type: boolean
        default: false
      dry-run:
        description: "Dry run mode (build but don't push)"
        required: false
        type: boolean
        default: true
      force-publish:
        description: "(CAUTION!) Enable to force publish (override) the image even if it already exists on the remote registry"
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  packages: write

jobs:
  build-and-push-connector:
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Install the latest version of uv
        uses: astral-sh/setup-uv@v6

      - name: Install Poe and yq
        run: |
          uv tool install poethepoet
          sudo snap install yq

      - name: Validate inputs and resolve variables
        id: vars
        run: |
          set -euo pipefail

          CONNECTOR_NAME="${{ inputs.connector-name }}"
          CONNECTOR_DIR="airbyte-integrations/connectors/${CONNECTOR_NAME}"
          METADATA_FILE="${CONNECTOR_DIR}/metadata.yaml"

          # Check if connector directory exists
          if [[ ! -d "$CONNECTOR_DIR" ]]; then
            echo "❌ Connector directory not found: $CONNECTOR_DIR"
            exit 1
          fi

          # Check if metadata.yaml exists
          if [[ ! -f "$METADATA_FILE" ]]; then
            echo "❌ metadata.yaml not found: $METADATA_FILE"
            exit 1
          fi

          # Change to connector directory for poe commands
          cd "$CONNECTOR_DIR"

          # Validate connector language (only Python and manifest-only supported for now)
          CONNECTOR_LANGUAGE=$(poe -qq get-language)
          if [[ "$CONNECTOR_LANGUAGE" != "python" && "$CONNECTOR_LANGUAGE" != "manifest-only" ]]; then
            echo "❌ Unsupported connector language: $CONNECTOR_LANGUAGE"
            exit 1
          fi

          # Get base image from metadata.yaml
          BASE_IMAGE=$(poe -qq get-base-image)
          if [[ -z "$BASE_IMAGE" ]]; then
            echo "❌ Base image not found in metadata.yaml"
            exit 1
          fi

          # Resolve connector version to use for image tagging
          if [[ "${{ inputs.tag-override }}" ]]; then
            CONNECTOR_VERSION_TAG="${{ inputs.tag-override }}"
            echo "🏷 Using provided tag: $CONNECTOR_VERSION_TAG"
          else
            CONNECTOR_VERSION_TAG=$(poe -qq get-version)
            if [[ -z "$CONNECTOR_VERSION_TAG" ]]; then
              echo "❌ Docker tag not found in metadata.yaml"
              exit 1
            fi
            echo "🏷 Using tag from metadata.yaml: $CONNECTOR_VERSION_TAG"
          fi

          # Can't dry-run and force-publish at the same time
          if [[ "${{ inputs.dry-run }}" == "true" && "${{ inputs.force-publish }}" == "true" ]]; then
            echo "❌ Cannot use dry-run and force-publish together"
            exit 1
          fi

          # Validate registry input
          case "${{ inputs.registry }}" in
            "docker.io/airbyte")
              # Supported registries
              ;;
            "ghcr.io/airbytehq")
              # Unsupported for now
              echo "ℹ️ GitHub Container Registry is not supported yet, please use 'docker.io/airbyte' instead"
              exit 1
              ;;
            *)
              echo "❌ Unsupported registry: ${{ inputs.registry }}"
              exit 1
              ;;
          esac

          # Get all tags to use for image pushing
          DOCKER_TAGS="${{ inputs.registry }}/${CONNECTOR_NAME}:${CONNECTOR_VERSION_TAG}"
          if [[ "${{ inputs.push-latest }}" == "true" ]]; then
            DOCKER_TAGS="${DOCKER_TAGS},${{ inputs.registry }}/${CONNECTOR_NAME}:latest"
          fi

          echo "📋 Build Details:"
          echo "  Connector: $CONNECTOR_NAME"
          echo "  Language: $CONNECTOR_LANGUAGE"
          echo "  Base Image: $BASE_IMAGE"
          echo "  Version Tag: $CONNECTOR_VERSION_TAG"
          echo "  Registry: ${{ inputs.registry }}"
          echo "  Tag(s) to Push: $DOCKER_TAGS"
          echo "  Dry Run: ${{ inputs.dry-run }}"
          echo "  Force Publish: ${{ inputs.force-publish }}" 

          {
            echo "connector-name=$CONNECTOR_NAME"
            echo "connector-type=$CONNECTOR_LANGUAGE"
            echo "connector-dir=$CONNECTOR_DIR"
            echo "base-image=$BASE_IMAGE"
            echo "connector-version-tag=$CONNECTOR_VERSION_TAG"
            echo "docker-tags=$DOCKER_TAGS"
          } >> $GITHUB_OUTPUT

      - name: Check if image already exists
        id: check-exists
        run: |
          set -euo pipefail

          # Initialize decision variables
          DO_BUILD="false"
          DO_PUBLISH="false"
          IMAGE_EXISTS="unknown"

          # Use Docker Hub API with retry and exponential backoff
          URL="https://registry.hub.docker.com/v2/repositories/airbyte/${{ steps.vars.outputs.connector-name }}/tags/${{ steps.vars.outputs.connector-version-tag }}/"
          STATUS=""
          echo "🔍 Checking if image exists on Docker Hub: ${{ steps.vars.outputs.connector-name }}:${{ steps.vars.outputs.connector-version-tag }}"

          max_attempts=5
          for attempt in {1..$max_attempts}; do
            echo "  Attempt $attempt/$max_attempts..."
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
            case "$STATUS" in
              "200"|"404")
                break
                ;;
              *)
                if [[ $attempt -lt $max_attempts ]]; then
                  delay=$((2 ** (attempt - 1)))
                  echo "⚠️  Unexpected status $STATUS, retrying in $delay seconds..."
                  sleep $delay
                else
                  echo "❌ Failed to check image after $max_attempts attempts. Last status: $STATUS"
                  exit 1
                fi
            esac
          done

          # Evaluate results
          case "$STATUS" in
            "200")
              echo "ℹ️ Image exists on Docker Hub"
              IMAGE_EXISTS="true"
              DO_BUILD="false"
              DO_PUBLISH="false"
              ;;
            "404")
              echo "✅ Image does not exist on Docker Hub"
              IMAGE_EXISTS="false"
              DO_BUILD="true"
              DO_PUBLISH="true"
              ;;
            *)
              echo "⚠️ Unable to determine if image exists (HTTP $STATUS)... Aborting to be safe"
              exit 1
              ;;
          esac

          # If dry-run is enabled, set build and publish decisions accordingly
          if [[ "${{ inputs.dry-run }}" == "true" ]]; then
            echo "🔄 Dry run mode enabled - will build but not push"
            DO_BUILD="true"
            DO_PUBLISH="false"
          fi

          # If force-publish is enabled, override decisions
          if [[ "${{ inputs.force-publish }}" == "true" ]]; then
            echo "🔄 Force publish enabled - will build and push regardless of existing image"
            DO_BUILD="true"
            DO_PUBLISH="true"
          fi

          # Output decision summary
          echo ""
          echo "📊 Build Decision Summary:"
          echo "  Image exists: $IMAGE_EXISTS"
          echo "  Will build: $DO_BUILD"
          echo "  Will publish: $DO_PUBLISH"
          echo "  Dry run mode: ${{ inputs.dry-run }}"
          echo "  Force publish: ${{ inputs.force-publish }}"

          # Set outputs for subsequent steps
          {
            echo "image-exists=$IMAGE_EXISTS"
            echo "do-build=$DO_BUILD"
            echo "do-publish=$DO_PUBLISH"
          } >> $GITHUB_OUTPUT

      - name: Login to Docker Hub
        if: ${{ steps.check-exists.outputs.do-publish }}
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_PASSWORD }}

      - name: Set up Docker Buildx
        if: ${{ steps.check-exists.outputs.do-build }}
        uses: docker/setup-buildx-action@v3

      - name: Build and push connector image
        if: ${{ steps.check-exists.outputs.do-build }}
        uses: docker/build-push-action@v5
        with:
          context: ${{ steps.vars.outputs.connector-dir }}
          file: docker-images/Dockerfile.${{ steps.vars.outputs.connector-type }}-connector
          platforms: linux/amd64,linux/arm64
          tags: ${{ steps.vars.outputs.docker-tags }}
          build-args: |
            BASE_IMAGE=${{ steps.vars.outputs.base-image }}
            CONNECTOR_NAME=${{ steps.vars.outputs.connector-name }}
          push: ${{ steps.check-exists.outputs.do-publish }}

      - name: Run `spec` Image Test
        if: ${{ steps.check-exists.outputs.do-build }}
        run: |
          docker run --rm ${{ inputs.registry }}/${{ steps.vars.outputs.connector-name }}:${{ steps.vars.outputs.image-tag }} spec

      - name: Run Image Vulnerability Scan
        if: ${{ steps.check-exists.outputs.do-build }}
        uses: anchore/scan-action@v6
        with:
          image: "${{ steps.vars.outputs.image-build-num-tag }}"
          output-format: "table"
          severity-cutoff: high
          fail-build: false
