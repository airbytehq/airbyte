name: Connector Image Build and Push (Python and Manifest-Only)
# This workflow builds and pushes connector images for Python and manifest-only connectors.
# It is intended to replace Airbyte-CI connector image builds and can be triggered manually or called from other workflows
# to publish connector images on merge to master.

on:
  workflow_call:
    inputs:
      connector-name:
        description: "Connector name (e.g., source-faker, destination-postgres)"
        required: true
        type: string
      # release-type:
      #   description: "Release type"
      #   required: true
      #   type: choice
      #   default: "pre-release"
      #   options:
      #     - "pre-release"
      #     - "main-release"
      registry:
        description: "Docker registry"
        required: false
        type: string
        default: "docker.io/airbyte"
      tag-override:
        description: "Override the image tag (optional). If not provided, the tag will be derived from the connector's metadata.yaml."
        required: false
        type: string
        default: ""
      dry-run:
        description: "Dry run mode (build but don't push)"
        required: false
        type: boolean
        default: true
      force-publish:
        description: "(CAUTION!) Enable to force publish (override) the image even if it already exists on the remote registry"
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  packages: write

jobs:
  build-and-push-connector:
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Install the latest version of uv
        uses: astral-sh/setup-uv@v6

      - name: Install Poe and yq
        run: |
          uv tool install poethepoet
          sudo snap install yq

      - name: Validate inputs and resolve variables
        id: vars
        run: |
          set -euo pipefail

          CONNECTOR_NAME="${{ inputs.connector-name }}"
          CONNECTOR_DIR="airbyte-integrations/connectors/${CONNECTOR_NAME}"
          METADATA_FILE="${CONNECTOR_DIR}/metadata.yaml"

          # Check if connector directory exists
          if [[ ! -d "$CONNECTOR_DIR" ]]; then
            echo "âŒ Connector directory not found: $CONNECTOR_DIR"
            exit 1
          fi

          # Check if metadata.yaml exists
          if [[ ! -f "$METADATA_FILE" ]]; then
            echo "âŒ metadata.yaml not found: $METADATA_FILE"
            exit 1
          fi

          # Change to connector directory for poe commands
          cd "$CONNECTOR_DIR"

          # Validate connector language (only Python and manifest-only supported for now)
          CONNECTOR_LANGUAGE=$(poe -qq get-language)
          if [[ "$CONNECTOR_LANGUAGE" != "python" && "$CONNECTOR_LANGUAGE" != "manifest-only" ]]; then
            echo "âŒ Unsupported connector language: $CONNECTOR_LANGUAGE"
            exit 1
          fi

          # Get base image from metadata.yaml
          BASE_IMAGE=$(poe -qq get-base-image)
          if [[ -z "$BASE_IMAGE" ]]; then
            echo "âŒ Base image not found in metadata.yaml"
            exit 1
          fi

          # Resolve connector version to use for image tagging
          if [[ "${{ inputs.tag-override }}" ]]; then
            DOCKER_TAG="${{ inputs.tag-override }}"
            echo "ğŸ· Using provided tag: $DOCKER_TAG"
          else
            DOCKER_TAG=$(poe -qq get-version)
            if [[ -z "$DOCKER_TAG" ]]; then
              echo "âŒ Docker tag not found in metadata.yaml"
              exit 1
            fi
            echo "ğŸ· Using tag from metadata.yaml: $DOCKER_TAG"
          fi

          # Can't dry-run and force-publish at the same time
          if [[ "${{ inputs.dry-run }}" == "true" && "${{ inputs.force-publish }}" == "true" ]]; then
            echo "âŒ Cannot use dry-run and force-publish together"
            exit 1
          fi

          # Validate registry input
          case "${{ inputs.registry }}" in
            "docker.io/airbyte")
              # Supported registries
              ;;
            "ghcr.io/airbytehq")
              # Unsupported for now
              echo "â„¹ï¸ GitHub Container Registry is not supported yet, please use 'docker.io/airbyte' instead"
              exit 1
              ;;
            *)
              echo "âŒ Unsupported registry: ${{ inputs.registry }}"
              exit 1
              ;;
          esac

          FULL_IMAGE_NAME="${{ inputs.registry }}/${CONNECTOR_NAME}:${DOCKER_TAG}"

          echo "ğŸ“‹ Build Details:"
          echo "  Connector: $CONNECTOR_NAME"
          echo "  Language: $CONNECTOR_LANGUAGE"
          echo "  Base Image: $BASE_IMAGE"
          echo "  Docker Tag: $DOCKER_TAG"
          echo "  Registry: ${{ inputs.registry }}"
          echo "  Full Image: $FULL_IMAGE_NAME"
          echo "  Dry Run: ${{ inputs.dry-run }}"
          echo "  Force Publish: ${{ inputs.force-publish }}" 

          {
            echo "connector-name=$CONNECTOR_NAME"
            echo "connector-type=$CONNECTOR_LANGUAGE"
            echo "connector-dir=$CONNECTOR_DIR"
            echo "docker-tag=$DOCKER_TAG"
            echo "base-image=$BASE_IMAGE"
            echo "registry=${ inputs.registry }"
            echo "image-name=$FULL_IMAGE_NAME"
          } >> $GITHUB_OUTPUT

      - name: Check if image already exists
        id: check-exists
        run: |
          set -euo pipefail

          # Initialize decision variables
          DO_BUILD="false"
          DO_PUBLISH="false"
          IMAGE_EXISTS="unknown"

          # Use Docker Hub API with retry and exponential backoff
          URL="https://registry.hub.docker.com/v2/repositories/airbyte/${{ steps.vars.outputs.connector-name }}/tags/${{ steps.vars.outputs.docker-tag }}/"
          STATUS=""
          echo "ğŸ” Checking if image exists on Docker Hub: ${{ steps.vars.outputs.image-name }}"

          max_attempts=5
          for attempt in {1..$max_attempts}; do
            echo "  Attempt $attempt/$max_attempts..."
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
            case "$STATUS" in
              "200"|"404")
                break
                ;;
              *)
                if [[ $attempt -lt $max_attempts ]]; then
                  delay=$((2 ** (attempt - 1)))
                  echo "âš ï¸  Unexpected status $STATUS, retrying in $delay seconds..."
                  sleep $delay
                else
                  echo "âŒ Failed to check image after $max_attempts attempts. Last status: $STATUS"
                  exit 1
                fi
            esac
          done

          # Evaluate results
          case "$STATUS" in
            "200")
              echo "â„¹ï¸ Image exists on Docker Hub: $IMAGE_NAME"
              IMAGE_EXISTS="true"
              DO_BUILD="false"
              DO_PUBLISH="false"
              ;;
            "404")
              echo "âœ… Image does not exist on Docker Hub: $IMAGE_NAME"
              IMAGE_EXISTS="false"
              DO_BUILD="true"
              DO_PUBLISH="${{ inputs.dry-run != 'true' }}"
              ;;
            *)
              echo "âš ï¸ Unable to determine if image exists (HTTP $STATUS)... Aborting to be safe"
              exit 1
              ;;
          esac

          # If force-publish is enabled, override decisions
          if [[ "${{ inputs.force-publish }}" == "true" ]]; then
            echo "ğŸ”„ Force publish enabled - will build and push regardless of existing image"
            DO_BUILD="true"
            DO_PUBLISH="true"
          fi

          # Output decision summary
          echo ""
          echo "ğŸ“Š Build Decision Summary:"
          echo "  Image exists: $IMAGE_EXISTS"
          echo "  Will build: $DO_BUILD"
          echo "  Will publish: $DO_PUBLISH"
          echo "  Dry run mode: ${{ inputs.dry-run }}"
          echo "  Force publish: ${{ inputs.force-publish }}"

          # Set outputs for subsequent steps
          {
            echo "image-exists=$IMAGE_EXISTS"
            echo "do-build=$DO_BUILD"
            echo "do-publish=$DO_PUBLISH"
          } >> $GITHUB_OUTPUT

      - name: Login to Docker Hub
        if: ${{ steps.check-exists.outputs.do-publish== 'true' }}
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_PASSWORD }}

      # - name: Login to GitHub Container Registry
      #   if: ${{ inputs.registry == 'ghcr.io/airbytehq' && !inputs.dry-run && steps.check-exists.outputs.exists != 'true' }}
      #   uses: docker/login-action@v3
      #   with:
      #     registry: ghcr.io
      #     username: ${{ github.repository_owner }}
      #     password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        if: ${{ steps.check-exists.outputs.exists != 'true' }}
        uses: docker/setup-buildx-action@v3

      # - name: Build and push connector image
      #   if: ${{ steps.check-exists.outputs.exists != 'true' }}
      #   uses: docker/build-push-action@v5
      #   with:
      #     context: ${{ steps.validate.outputs.connector-dir }}
      #     file: docker-images/Dockerfile.${{ steps.validate.outputs.connector-type }}-connector
      #     platforms: linux/amd64,linux/arm64
      #     tags: ${{ steps.version.outputs.full-image-name }}
      #     build-args: |
      #       BASE_IMAGE=${{ steps.version.outputs.base-image }}
      #       CONNECTOR_NAME=${{ inputs.connector }}
      #       CONNECTOR_SNAKE_NAME=${{ inputs.connector }}
      #       CONNECTOR_VERSION=${{ steps.version.outputs.base-version }}
      #     push: ${{ !inputs.dry-run }}
      #     cache-from: type=gha
      #     cache-to: type=gha,mode=max

      # - name: Test connector image
      #   if: ${{ steps.check-exists.outputs.exists != 'true' && !inputs.dry-run }}
      #   run: |
      #     echo "ğŸ§ª Testing connector image: ${{ steps.version.outputs.full-image-name }}"
      #     docker run --rm ${{ steps.version.outputs.full-image-name }} spec

      # - name: Run vulnerability scan
      #   if: ${{ steps.check-exists.outputs.exists != 'true' }}
      #   uses: anchore/scan-action@v6
      #   with:
      #     image: ${{ steps.version.outputs.full-image-name }}
      #     output-format: table
      #     severity-cutoff: high
      #     fail-build: false

      # - name: Summary
      #   run: |
      #     echo "## ğŸš€ Build Summary" >> $GITHUB_STEP_SUMMARY
      #     echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
      #     echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
      #     echo "| Connector | \`${{ inputs.connector }}\` |" >> $GITHUB_STEP_SUMMARY
      #     echo "| Type | ${{ steps.validate.outputs.connector-type }} |" >> $GITHUB_STEP_SUMMARY
      #     echo "| Release Type | ${{ inputs.release-type }} |" >> $GITHUB_STEP_SUMMARY
      #     echo "| Registry | ${{ inputs.registry }} |" >> $GITHUB_STEP_SUMMARY
      #     echo "| Image | \`${{ steps.version.outputs.full-image-name }}\` |" >> $GITHUB_STEP_SUMMARY
      #     echo "| Dry Run | ${{ inputs.dry-run }} |" >> $GITHUB_STEP_SUMMARY
      #     echo "| Already Exists | ${{ steps.check-exists.outputs.exists || 'N/A' }} |" >> $GITHUB_STEP_SUMMARY

      #     if [[ "${{ steps.check-exists.outputs.exists }}" == "true" ]]; then
      #       echo "â„¹ï¸  Image already exists - skipped build and push"
      #     elif [[ "${{ inputs.dry-run }}" == "true" ]]; then
      #       echo "ğŸƒ Dry run completed - image built but not pushed"
      #     else
      #       echo "âœ… Image built and pushed successfully"
      #     fi
