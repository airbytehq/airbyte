import org.gradle.api.DefaultTask
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.file.ConfigurableFileTree
import org.gradle.api.file.FileCollection
import org.gradle.api.tasks.CacheableTask
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.PathSensitive
import org.gradle.api.tasks.PathSensitivity
import org.gradle.api.tasks.TaskAction

import java.security.MessageDigest
import java.nio.file.Paths

@CacheableTask
abstract class AirbyteDockerBaseTask extends DefaultTask {

    @InputFiles
    @PathSensitive(PathSensitivity.RELATIVE)
    FileCollection filesInDockerImage

    @Input
    Map<String, String> baseImageHashes

    @InputFile
    File dockerFile

    @OutputFile
    File idFileOutput
}

abstract class AirbyteDockerTask extends AirbyteDockerBaseTask {

    @InputFile
    File buildScript = project.rootProject.file('tools/bin/build_image.sh')

    @TaskAction
    def dockerTask() {
        project.exec {
            commandLine(
                    buildScript.absolutePath,
                    project.rootDir.absolutePath,
                    project.projectDir.absolutePath,
                    dockerFile.name,
                    DockerHelpers.getDevTaggedImage(project.projectDir, dockerFile.name),
                    idFileOutput.absolutePath,
           )
        }
    }
}

abstract class AirbyteDockerWithLocalCDKLegacyTask extends AirbyteDockerBaseTask {

    @InputFile
    File buildScript = project.rootProject.file('airbyte-integrations/scripts/build-connector-image-with-local-cdk.sh')

    @TaskAction
    def dockerTask() {
        project.exec {
            environment "CONNECTOR_TAG", DockerHelpers.getDevTaggedImage(project.projectDir, dockerFile.name)
            environment "CONNECTOR_NAME", project.findProperty('connectorAcceptanceTest.connectorName')
            commandLine buildScript.absolutePath
        }
    }
}

class AirbyteDockerTaskFactory {

    private AirbyteDockerTaskFactory() {}

    Project project
    String dockerFileName

    File dockerFile() {
        return project.file(dockerFileName)
    }

    String dockerfilePathHash() {
        return MessageDigest.getInstance("MD5")
                .digest(dockerFile().absolutePath.getBytes())
                .encodeHex()
                .toString()
    }

    FileCollection filteredProjectFiles() {
        ConfigurableFileTree files = project.fileTree(project.projectDir)
        def dockerignore = project.file('.dockerignore')
        if (!dockerignore.exists()) {
            return files.filter {
                file -> !file.toString().contains(".venv")
            }
        }
        for (def rule : dockerignore.readLines()) {
            if (rule.startsWith("#")) {
                continue
            }
            rule = rule.trim()
            files = (rule.startsWith("!") ? files.include(rule.substring(1)) : files.exclude(rule)) as ConfigurableFileTree
        }
        return files
    }

    Map<String,String> collectKnownImageHashes() {
        def stdout = new ByteArrayOutputStream()
        project.exec {
            commandLine "docker", "images", "--no-trunc", "-f", "dangling=false", "--format", "{{.Repository}}:{{.Tag}} {{.ID}}"
            standardOutput = stdout
        }
        Map<String,String> map = [:]
        stdout.toString().eachLine {line ->
            def splits = line.split()
            map.put(splits[0], splits[1].trim())
        }
        return map
    }

    Map<String, String> baseTaggedImagesAndHashes(Map<String, String> allKnownImageHashes) {
        def taggedImages = new HashSet<String>()

        // Look for "FROM foo AS bar" directives, and add them to the map with .put("bar", "foo")
        Map<String, String> imageAliases = [:]
        dockerFile().eachLine { line ->
            def parts = line.split()
            if (parts.length >= 4 && parts[0].equals("FROM") && parts[parts.length - 2].equals("AS")) {
                imageAliases.put(parts[parts.length - 1], parts[1])
            }
        }

        dockerFile().eachLine { line ->
            if (line.startsWith("FROM ")) {
                def image = line.split()[1]
                assert !image.isEmpty()
                taggedImages.add(image)
            } else if (line.startsWith("COPY --from=")) {
                def image = line.substring("COPY --from=".length()).split()[0]
                assert !image.isEmpty()
                if (imageAliases[image] != null) {
                    taggedImages.add(imageAliases[image])
                } else {
                    taggedImages.add(image)
                }
            }
        }

        Map<String, String> result = [:]
        for (def taggedImage : taggedImages) {
            taggedImage = resolveEnvironmentVariables(taggedImage)
            result.put(taggedImage, allKnownImageHashes.getOrDefault(taggedImage, "???"))
        }
        return result
    }

    // Some image tags rely on environment variables (e.g. "FROM amazoncorretto:${JDK_VERSION}").
    // dump those into a "sh -c 'echo ...'" command to resolve them (e.g. "amazoncorretto:17.0.4")
    String resolveEnvironmentVariables(String str) {
        def stdout = new ByteArrayOutputStream()
        project.exec {
            commandLine "sh", "-c", "echo " + str
            standardOutput = stdout;
        }
        return stdout.toString().trim()
    }

    def createTask(String taskName) {
        if (!dockerFile().exists()) {
            return project.tasks.register(taskName) {
                logger.info "Skipping ${taskName} because ${dockerFile()} does not exist."
            }
        }
        Class<? extends AirbyteDockerBaseTask> taskClass = AirbyteDockerTask
        if (project.hasProperty('connectorAcceptanceTest.useLocalCdk') && project.parent.project.name == "connectors") {
            taskClass = AirbyteDockerWithLocalCDKLegacyTask
        }
        def taggedImage = DockerHelpers.getDevTaggedImage(project.projectDir, dockerFileName)
        def idFilePath = Paths.get(project.rootProject.rootDir.absolutePath, '.dockerversions', dockerfilePathHash())
        def airbyteDockerTask = project.tasks.register(taskName, taskClass) {
            it.filesInDockerImage = filteredProjectFiles()
            it.dockerFile = this.dockerFile()
            it.baseImageHashes = baseTaggedImagesAndHashes(collectKnownImageHashes())
            it.idFileOutput = idFilePath.toFile()
            it.outputs.upToDateWhen {
                for (Map.Entry<String, String> e : it.baseImageHashes) {
                    if (e.key.startsWith("airbyte/") && e.value == "???") {
                        logger.info "Not up to date: missing at least one airbyte base image in docker"
                        return false
                    }
                }
                def allImageHashes = collectKnownImageHashes()
                if (!allImageHashes.containsKey(taggedImage)) {
                    logger.info "Not up to date: ID file exists but target image not found in docker"
                    return false
                }
                def currentBaseImageHashes = baseTaggedImagesAndHashes(allImageHashes)
                if (!it.baseImageHashes.equals(currentBaseImageHashes)) {
                    logger.info "Not up to date: at last one base image has changed in docker since task creation"
                    return false
                }
                return true
            }
        }
        airbyteDockerTask.configure {
            dependsOn project.tasks.matching { it.name == 'distTar' }
            dependsOn project.tasks.named('generate')
        }
        project.tasks.named('assemble').configure {
            dependsOn airbyteDockerTask
        }
        def airbyteDockerCleanTask = project.tasks.register(taskName + "Clean", Delete) {
            delete idFilePath
        }
        project.tasks.named('clean').configure {
            dependsOn airbyteDockerCleanTask
        }
        return airbyteDockerTask
    }

    static def build(Project project, String taskName, String dockerFileName) {
        def f = new AirbyteDockerTaskFactory()
        f.project = project
        f.dockerFileName = dockerFileName
        f.createTask(taskName)
    }
}

class AirbyteDockerPlugin implements Plugin<Project> {

    void apply(Project project) {
        AirbyteDockerTaskFactory.build(project, 'airbyteDocker', 'Dockerfile')
        AirbyteDockerTaskFactory.build(project, 'airbyteDockerTest', 'Dockerfile.test')
    }
}
