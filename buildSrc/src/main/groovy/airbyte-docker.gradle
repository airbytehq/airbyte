import org.gradle.api.DefaultTask
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.file.ConfigurableFileTree
import org.gradle.api.file.FileCollection
import org.gradle.api.tasks.CacheableTask
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.PathSensitive
import org.gradle.api.tasks.PathSensitivity
import org.gradle.api.tasks.TaskAction
import org.slf4j.Logger

import java.security.MessageDigest
import java.nio.file.Paths

@CacheableTask
abstract class AirbyteDockerBaseTask extends DefaultTask {

    @InputFiles
    @PathSensitive(PathSensitivity.RELATIVE)
    FileCollection filesInDockerImage

    @Input
    Set<String> baseImageHashes

    @InputFile
    File dockerFile

    @OutputFile
    File idFileOutput
}

abstract class AirbyteDockerTask extends AirbyteDockerBaseTask {

    @InputFile
    File buildScript = project.rootProject.file('tools/bin/build_image.sh')

    @TaskAction
    def dockerTask() {
        project.exec {
            commandLine(
                    buildScript.absolutePath,
                    project.rootDir.absolutePath,
                    project.projectDir.absolutePath,
                    dockerFile.name,
                    DockerHelpers.getDevTaggedImage(project.projectDir, dockerFile.name),
                    idFileOutput.absolutePath,
           )
        }
    }
}

abstract class AirbyteDockerWithLocalCDKLegacyTask extends AirbyteDockerBaseTask {

    @InputFile
    File buildScript = project.rootProject.file('airbyte-integrations/scripts/build-connector-image-with-local-cdk.sh')

    @TaskAction
    def dockerTask() {
        project.exec {
            environment "CONNECTOR_TAG", DockerHelpers.getDevTaggedImage(project.projectDir, dockerFile.name)
            environment "CONNECTOR_NAME", project.findProperty('connectorAcceptanceTest.connectorName')
            commandLine buildScript.absolutePath
        }
    }
}

class AirbyteDockerPlugin implements Plugin<Project> {

    static def getBaseTaggedImages(File dockerfile) {
        def result = [] as Set<String>

        // Look for "FROM foo AS bar" directives, and add them to the map with .put("bar", "foo")
        Map<String, String> imageAliases = [:]
        dockerfile.eachLine { line ->
            def parts = line.split()
            if (parts.length >= 4 && parts[0].equals("FROM") && parts[parts.length - 2].equals("AS")) {
                imageAliases.put(parts[parts.length - 1], parts[1])
            }
        }

        dockerfile.eachLine { line ->
            if (line.startsWith("FROM ")) {
                def image = line.split()[1]
                assert !image.isEmpty()
                result.add(image)
            } else if (line.startsWith("COPY --from=")) {
                def image = line.substring("COPY --from=".length()).split()[0]
                assert !image.isEmpty()
                if (imageAliases[image] != null) {
                    result.add(imageAliases[image])
                } else {
                    result.add(image)
                }
            }
        }

        return result
    }

    static def getBaseImageHashes(Map imageToHash, File dockerfile) {
        def result = [] as Set<String>

        getBaseTaggedImages(dockerfile).forEach { taggedImage ->
            result.add((String) imageToHash.get(taggedImage))
        }

        return result
    }

    static String getImageHash(Project project, String taggedImage) {
        def stdout = new ByteArrayOutputStream()

        project.exec {
            commandLine "docker", "images", "--no-trunc", "-f", "dangling=false", "--format", "{{.ID}}", resolveEnvironmentVariables(project, taggedImage)
            standardOutput = stdout;
        }

        return "$stdout".toString().trim()
    }

    // Some image tags rely on environment variables (e.g. "FROM amazoncorretto:${JDK_VERSION}").
    // dump those into a "sh -c 'echo ...'" command to resolve them (e.g. "amazoncorretto:17.0.4")
    static String resolveEnvironmentVariables(Project project, String str) {
        def stdout = new ByteArrayOutputStream()

        project.exec {
            commandLine "sh", "-c", "echo " + str
            standardOutput = stdout;
        }

        return "$stdout".toString().trim()
    }

    static boolean isUpToDate(Logger logger, File idFileOutput, Project project, File dockerFile) {
        if (idFileOutput.exists()) {
            def taggedImage = DockerHelpers.getDevTaggedImage(project.projectDir, dockerFile.name)
            logger.debug "taggedImage " + taggedImage

            def current = getImageHash(project, taggedImage)
            logger.debug "current " + current
            def stored = (String) project.rootProject.imageToHash.get(taggedImage)
            logger.debug "stored " + stored

            def notUpToDate = new ArrayList<String>(getBaseTaggedImages(dockerFile)).any { baseImage ->
                logger.debug "checking base image " + baseImage
                def storedBase = (String) project.rootProject.imageToHash.get(resolveEnvironmentVariables(project, baseImage))
                def currentBase = getImageHash(project, baseImage)

                logger.debug "storedBase " + storedBase
                logger.debug "currentBase " + currentBase
                if (!currentBase.equals(storedBase)) {
                    logger.debug "did not match"
                    return true
                } else {
                    logger.debug "did match"
                    return false
                }
            }

            if (notUpToDate) {
                return false;
            }

            logger.debug "stored " + stored

            def upToDate = current.equals(stored)

            logger.debug "uptodate " + upToDate.toString()

            return upToDate
        } else {
            return false
        }
    }

    static FileCollection filteredProjectFiles(Project project) {
        ConfigurableFileTree files = project.fileTree(project.projectDir).asFileTree
        def dockerignore = project.file('.dockerignore')
        if (!dockerignore.exists()) {
            return files.filter {
                file -> !file.toString().contains(".venv")
            }
        }
        for (def rule : dockerignore.readLines()) {
            if (rule.startsWith("#")) {
                continue
            }
            rule = rule.trim()
            files = (rule.startsWith("!") ? files.include(rule.substring(1)) : files.exclude(rule)) as ConfigurableFileTree
        }
        return files
    }


    static def createTask(Project project, String taskName, String dockerFileName) {
        def dockerFile = project.file(dockerFileName)
        if (!dockerFile.exists()) {
            project.tasks.register(taskName) {
                logger.info "Skipping ${taskName} because ${dockerFile} does not exist."
            }
            return
        }
        Class<? extends AirbyteDockerBaseTask> taskClass = AirbyteDockerTask
        if (project.hasProperty('connectorAcceptanceTest.useLocalCdk') && project.parent.project.name == "connectors") {
            taskClass = AirbyteDockerWithLocalCDKLegacyTask
        }
        def airbyteDockerTask = project.tasks.register(taskName, taskClass) {
            def dockerfilePathHash = MessageDigest.getInstance("MD5")
                    .digest(dockerFile.absolutePath.getBytes())
                    .encodeHex()
                    .toString()

            it.filesInDockerImage = filteredProjectFiles(project)
            it.dockerFile = dockerFile
            it.baseImageHashes = getBaseImageHashes(project.rootProject.imageToHash, dockerFile)
            it.idFileOutput = Paths.get(project.rootProject.rootDir.absolutePath, '.dockerversions', dockerfilePathHash).toFile()

            it.outputs.upToDateWhen {
                return isUpToDate(logger, it.idFileOutput, project, dockerFile)
            }
        }
        airbyteDockerTask.configure {
            dependsOn project.tasks.matching { it.name == 'distTar' }
            dependsOn project.tasks.named('generate')
        }
        project.tasks.named('assemble').configure {
            dependsOn airbyteDockerTask
        }
    }

    void apply(Project project) {
        // set (and cache) global image to version map
        project.rootProject.ext.imageToHash = {
            if (!project.rootProject.hasProperty("imageToHash")) {
                def imageToHash = [:]
                def stdout = new ByteArrayOutputStream()
                project.exec {
                    commandLine "docker", "images", "--no-trunc", "-f", "dangling=false", "--format", "{{.Repository}}:{{.Tag}} {{.ID}}"
                    standardOutput = stdout;
                }

                "$stdout".eachLine { line ->
                    def splits = line.split()
                    imageToHash.put(splits[0], splits[1].trim())
                }

                return imageToHash
            } else {
                return project.rootProject.imageToHash
            }
        }()

        createTask(project, 'airbyteDocker', 'Dockerfile')
        createTask(project, 'airbyteDockerTest', 'Dockerfile.test')
    }
}
