Module airbyte_cdk.sources.utils.schema_helpers
===============================================

Functions
---------

    
`check_config_against_spec_or_exit(config: Mapping[str, Any], spec: airbyte_cdk.models.airbyte_protocol.ConnectorSpecification)`
:   Check config object against spec. In case of spec is invalid, throws
    an exception with validation error description.
    
    :param config - config loaded from file specified over command line
    :param spec - spec object generated by connector

    
`expand_refs(schema: Any) ‑> None`
:   Iterate over schema and replace all occurrences of $ref with their definitions.
    
    :param schema: schema that will be patched

    
`rename_key(schema: Any, old_key: str, new_key: str) ‑> None`
:   Iterate over nested dictionary and replace one key with another. Used to replace anyOf with oneOf. Recursive."
    
    :param schema: schema that will be patched
    :param old_key: name of the key to replace
    :param new_key: new name of the key

    
`resolve_ref_links(obj: Any) ‑> Union[Dict[str, Any], List[Any]]`
:   Scan resolved schema and convert jsonref.JsonRef object to JSON serializable dict.
    
    :param obj - jsonschema object with ref field resolved.
    :return JSON serializable object with references without external dependencies.

    
`split_config(config: Mapping[str, Any]) ‑> Tuple[dict, airbyte_cdk.sources.utils.schema_helpers.InternalConfig]`
:   Break config map object into 2 instances: first is a dict with user defined
    configuration and second is internal config that contains private keys for
    acceptance test configuration.
    
    :param
     config - Dict object that has been loaded from config file.
    
    :return tuple of user defined config dict with filtered out internal
    parameters and SAT internal config object.

Classes
-------

`InternalConfig(**data: Any)`
:   Create a new model by parsing and validating input data from keyword arguments.
    
    Raises ValidationError if the input data cannot be parsed to form a valid model.

    ### Ancestors (in MRO)

    * pydantic.main.BaseModel
    * pydantic.utils.Representation

    ### Class variables

    `KEYWORDS: ClassVar[set]`
    :

    `limit: int`
    :

    `page_size: int`
    :

    ### Methods

    `dict(self, *args, **kwargs)`
    :   Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

`JsonFileLoader(uri_base: str, shared: str)`
:   Custom json file loader to resolve references to resources located in "shared" directory.
    We need this for compatability with existing schemas cause all of them have references
    pointing to shared_schema.json file instead of shared/shared_schema.json

`ResourceSchemaLoader(package_name: str)`
:   JSONSchema loader from package resources

    ### Methods

    `get_schema(self, name: str) ‑> dict`
    :   This method retrieves a JSON schema from the schemas/ folder.
        
        
        The expected file structure is to have all top-level schemas (corresponding to streams) in the "schemas/" folder, with any shared $refs
        living inside the "schemas/shared/" folder. For example:
        
        schemas/shared/<shared_definition>.json
        schemas/<name>.json # contains a $ref to shared_definition
        schemas/<name2>.json # contains a $ref to shared_definition