<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>airbyte_cdk.sources.utils.transform API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>airbyte_cdk.sources.utils.transform</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# Copyright (c) 2022 Airbyte, Inc., all rights reserved.
#

import logging
from distutils.util import strtobool
from enum import Flag, auto
from typing import Any, Callable, Dict, Mapping, Optional

from jsonschema import Draft7Validator, validators

logger = logging.getLogger(&#34;airbyte&#34;)


class TransformConfig(Flag):
    &#34;&#34;&#34;
    TypeTransformer class config. Configs can be combined using bitwise or operator e.g.
        ```
        TransformConfig.DefaultSchemaNormalization | TransformConfig.CustomSchemaNormalization
        ```
    &#34;&#34;&#34;

    # No action taken, default behaviour. Cannot be combined with any other options.
    NoTransform = auto()
    # Applies default type casting with default_convert method which converts
    # values by applying simple type casting to specified jsonschema type.
    DefaultSchemaNormalization = auto()
    # Allow registering custom type transformation callback. Can be combined
    # with DefaultSchemaNormalization. In this case default type casting would
    # be applied before custom one.
    CustomSchemaNormalization = auto()


class TypeTransformer:
    &#34;&#34;&#34;
    Class for transforming object before output.
    &#34;&#34;&#34;

    _custom_normalizer: Optional[Callable[[Any, Dict[str, Any]], Any]] = None

    def __init__(self, config: TransformConfig):
        &#34;&#34;&#34;
        Initialize TypeTransformer instance.
        :param config Transform config that would be applied to object
        &#34;&#34;&#34;
        if TransformConfig.NoTransform in config and config != TransformConfig.NoTransform:
            raise Exception(&#34;NoTransform option cannot be combined with other flags.&#34;)
        self._config = config
        all_validators = {
            key: self.__get_normalizer(key, orig_validator)
            for key, orig_validator in Draft7Validator.VALIDATORS.items()
            # Do not validate field we do not transform for maximum performance.
            if key in [&#34;type&#34;, &#34;array&#34;, &#34;$ref&#34;, &#34;properties&#34;, &#34;items&#34;]
        }
        self._normalizer = validators.create(meta_schema=Draft7Validator.META_SCHEMA, validators=all_validators)

    def registerCustomTransform(self, normalization_callback: Callable[[Any, Dict[str, Any]], Any]) -&gt; Callable:
        &#34;&#34;&#34;
        Register custom normalization callback.
        :param normalization_callback function to be used for value
        normalization. Takes original value and part type schema. Should return
        normalized value. See docs/connector-development/cdk-python/schemas.md
        for details.
        :return Same callbeck, this is usefull for using registerCustomTransform function as decorator.
        &#34;&#34;&#34;
        if TransformConfig.CustomSchemaNormalization not in self._config:
            raise Exception(&#34;Please set TransformConfig.CustomSchemaNormalization config before registering custom normalizer&#34;)
        self._custom_normalizer = normalization_callback
        return normalization_callback

    def __normalize(self, original_item: Any, subschema: Dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;
        Applies different transform function to object&#39;s field according to config.
        :param original_item original value of field.
        :param subschema part of the jsonschema containing field type/format data.
        :return Final field value.
        &#34;&#34;&#34;
        if TransformConfig.DefaultSchemaNormalization in self._config:
            original_item = self.default_convert(original_item, subschema)

        if self._custom_normalizer:
            original_item = self._custom_normalizer(original_item, subschema)
        return original_item

    @staticmethod
    def default_convert(original_item: Any, subschema: Dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;
        Default transform function that is used when TransformConfig.DefaultSchemaNormalization flag set.
        :param original_item original value of field.
        :param subschema part of the jsonschema containing field type/format data.
        :return transformed field value.
        &#34;&#34;&#34;
        target_type = subschema.get(&#34;type&#34;, [])
        if original_item is None and &#34;null&#34; in target_type:
            return None
        if isinstance(target_type, list):
            # jsonschema type could either be a single string or array of type
            # strings. In case if there is some disambigous and more than one
            # type (except null) do not do any conversion and return original
            # value. If type array has one type and null i.e. {&#34;type&#34;:
            # [&#34;integer&#34;, &#34;null&#34;]}, convert value to specified type.
            target_type = [t for t in target_type if t != &#34;null&#34;]
            if len(target_type) != 1:
                return original_item
            target_type = target_type[0]
        try:
            if target_type == &#34;string&#34;:
                return str(original_item)
            elif target_type == &#34;number&#34;:
                return float(original_item)
            elif target_type == &#34;integer&#34;:
                return int(original_item)
            elif target_type == &#34;boolean&#34;:
                if isinstance(original_item, str):
                    return strtobool(original_item) == 1
                return bool(original_item)
        except (ValueError, TypeError):
            return original_item
        return original_item

    def __get_normalizer(self, schema_key: str, original_validator: Callable):
        &#34;&#34;&#34;
        Traverse through object fields using native jsonschema validator and apply normalization function.
        :param schema_key related json schema key that currently being validated/normalized.
        :original_validator: native jsonschema validator callback.
        &#34;&#34;&#34;

        def normalizator(validator_instance: Callable, property_value: Any, instance: Any, schema: Dict[str, Any]):
            &#34;&#34;&#34;
            Jsonschema validator callable it uses for validating instance. We
            override default Draft7Validator to perform value transformation
            before validation take place. We do not take any action except
            logging warn if object does not conform to json schema, just using
            jsonschema algorithm to traverse through object fields.
            Look
            https://python-jsonschema.readthedocs.io/en/stable/creating/?highlight=validators.create#jsonschema.validators.create
            validators parameter for detailed description.
            :
            &#34;&#34;&#34;

            def resolve(subschema):
                if &#34;$ref&#34; in subschema:
                    _, resolved = validator_instance.resolver.resolve(subschema[&#34;$ref&#34;])
                    return resolved
                return subschema

            # Transform object and array values before running json schema type checking for each element.
            if schema_key == &#34;properties&#34;:
                for k, subschema in property_value.items():
                    if k in (instance or {}):
                        subschema = resolve(subschema)
                        instance[k] = self.__normalize(instance[k], subschema)
            elif schema_key == &#34;items&#34;:
                subschema = resolve(property_value)
                for index, item in enumerate((instance or [])):
                    instance[index] = self.__normalize(item, subschema)

            # Running native jsonschema traverse algorithm after field normalization is done.
            yield from original_validator(validator_instance, property_value, instance, schema)

        return normalizator

    def transform(self, record: Dict[str, Any], schema: Mapping[str, Any]):
        &#34;&#34;&#34;
        Normalize and validate according to config.
        :param record: record instance for normalization/transformation. All modification are done by modifying existent object.
        :param schema: object&#39;s jsonschema for normalization.
        &#34;&#34;&#34;
        if TransformConfig.NoTransform in self._config:
            return
        normalizer = self._normalizer(schema)
        for e in normalizer.iter_errors(record):
            &#34;&#34;&#34;
            just calling normalizer.validate() would throw an exception on
            first validation occurences and stop processing rest of schema.
            &#34;&#34;&#34;
            logger.warning(e.message)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="airbyte_cdk.sources.utils.transform.TransformConfig"><code class="flex name class">
<span>class <span class="ident">TransformConfig</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>TypeTransformer class config. Configs can be combined using bitwise or operator e.g.
<code>TransformConfig.DefaultSchemaNormalization | TransformConfig.CustomSchemaNormalization</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TransformConfig(Flag):
    &#34;&#34;&#34;
    TypeTransformer class config. Configs can be combined using bitwise or operator e.g.
        ```
        TransformConfig.DefaultSchemaNormalization | TransformConfig.CustomSchemaNormalization
        ```
    &#34;&#34;&#34;

    # No action taken, default behaviour. Cannot be combined with any other options.
    NoTransform = auto()
    # Applies default type casting with default_convert method which converts
    # values by applying simple type casting to specified jsonschema type.
    DefaultSchemaNormalization = auto()
    # Allow registering custom type transformation callback. Can be combined
    # with DefaultSchemaNormalization. In this case default type casting would
    # be applied before custom one.
    CustomSchemaNormalization = auto()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="airbyte_cdk.sources.utils.transform.TransformConfig.CustomSchemaNormalization"><code class="name">var <span class="ident">CustomSchemaNormalization</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="airbyte_cdk.sources.utils.transform.TransformConfig.DefaultSchemaNormalization"><code class="name">var <span class="ident">DefaultSchemaNormalization</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="airbyte_cdk.sources.utils.transform.TransformConfig.NoTransform"><code class="name">var <span class="ident">NoTransform</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="airbyte_cdk.sources.utils.transform.TypeTransformer"><code class="flex name class">
<span>class <span class="ident">TypeTransformer</span></span>
<span>(</span><span>config: <a title="airbyte_cdk.sources.utils.transform.TransformConfig" href="#airbyte_cdk.sources.utils.transform.TransformConfig">TransformConfig</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for transforming object before output.</p>
<p>Initialize TypeTransformer instance.
:param config Transform config that would be applied to object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypeTransformer:
    &#34;&#34;&#34;
    Class for transforming object before output.
    &#34;&#34;&#34;

    _custom_normalizer: Optional[Callable[[Any, Dict[str, Any]], Any]] = None

    def __init__(self, config: TransformConfig):
        &#34;&#34;&#34;
        Initialize TypeTransformer instance.
        :param config Transform config that would be applied to object
        &#34;&#34;&#34;
        if TransformConfig.NoTransform in config and config != TransformConfig.NoTransform:
            raise Exception(&#34;NoTransform option cannot be combined with other flags.&#34;)
        self._config = config
        all_validators = {
            key: self.__get_normalizer(key, orig_validator)
            for key, orig_validator in Draft7Validator.VALIDATORS.items()
            # Do not validate field we do not transform for maximum performance.
            if key in [&#34;type&#34;, &#34;array&#34;, &#34;$ref&#34;, &#34;properties&#34;, &#34;items&#34;]
        }
        self._normalizer = validators.create(meta_schema=Draft7Validator.META_SCHEMA, validators=all_validators)

    def registerCustomTransform(self, normalization_callback: Callable[[Any, Dict[str, Any]], Any]) -&gt; Callable:
        &#34;&#34;&#34;
        Register custom normalization callback.
        :param normalization_callback function to be used for value
        normalization. Takes original value and part type schema. Should return
        normalized value. See docs/connector-development/cdk-python/schemas.md
        for details.
        :return Same callbeck, this is usefull for using registerCustomTransform function as decorator.
        &#34;&#34;&#34;
        if TransformConfig.CustomSchemaNormalization not in self._config:
            raise Exception(&#34;Please set TransformConfig.CustomSchemaNormalization config before registering custom normalizer&#34;)
        self._custom_normalizer = normalization_callback
        return normalization_callback

    def __normalize(self, original_item: Any, subschema: Dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;
        Applies different transform function to object&#39;s field according to config.
        :param original_item original value of field.
        :param subschema part of the jsonschema containing field type/format data.
        :return Final field value.
        &#34;&#34;&#34;
        if TransformConfig.DefaultSchemaNormalization in self._config:
            original_item = self.default_convert(original_item, subschema)

        if self._custom_normalizer:
            original_item = self._custom_normalizer(original_item, subschema)
        return original_item

    @staticmethod
    def default_convert(original_item: Any, subschema: Dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;
        Default transform function that is used when TransformConfig.DefaultSchemaNormalization flag set.
        :param original_item original value of field.
        :param subschema part of the jsonschema containing field type/format data.
        :return transformed field value.
        &#34;&#34;&#34;
        target_type = subschema.get(&#34;type&#34;, [])
        if original_item is None and &#34;null&#34; in target_type:
            return None
        if isinstance(target_type, list):
            # jsonschema type could either be a single string or array of type
            # strings. In case if there is some disambigous and more than one
            # type (except null) do not do any conversion and return original
            # value. If type array has one type and null i.e. {&#34;type&#34;:
            # [&#34;integer&#34;, &#34;null&#34;]}, convert value to specified type.
            target_type = [t for t in target_type if t != &#34;null&#34;]
            if len(target_type) != 1:
                return original_item
            target_type = target_type[0]
        try:
            if target_type == &#34;string&#34;:
                return str(original_item)
            elif target_type == &#34;number&#34;:
                return float(original_item)
            elif target_type == &#34;integer&#34;:
                return int(original_item)
            elif target_type == &#34;boolean&#34;:
                if isinstance(original_item, str):
                    return strtobool(original_item) == 1
                return bool(original_item)
        except (ValueError, TypeError):
            return original_item
        return original_item

    def __get_normalizer(self, schema_key: str, original_validator: Callable):
        &#34;&#34;&#34;
        Traverse through object fields using native jsonschema validator and apply normalization function.
        :param schema_key related json schema key that currently being validated/normalized.
        :original_validator: native jsonschema validator callback.
        &#34;&#34;&#34;

        def normalizator(validator_instance: Callable, property_value: Any, instance: Any, schema: Dict[str, Any]):
            &#34;&#34;&#34;
            Jsonschema validator callable it uses for validating instance. We
            override default Draft7Validator to perform value transformation
            before validation take place. We do not take any action except
            logging warn if object does not conform to json schema, just using
            jsonschema algorithm to traverse through object fields.
            Look
            https://python-jsonschema.readthedocs.io/en/stable/creating/?highlight=validators.create#jsonschema.validators.create
            validators parameter for detailed description.
            :
            &#34;&#34;&#34;

            def resolve(subschema):
                if &#34;$ref&#34; in subschema:
                    _, resolved = validator_instance.resolver.resolve(subschema[&#34;$ref&#34;])
                    return resolved
                return subschema

            # Transform object and array values before running json schema type checking for each element.
            if schema_key == &#34;properties&#34;:
                for k, subschema in property_value.items():
                    if k in (instance or {}):
                        subschema = resolve(subschema)
                        instance[k] = self.__normalize(instance[k], subschema)
            elif schema_key == &#34;items&#34;:
                subschema = resolve(property_value)
                for index, item in enumerate((instance or [])):
                    instance[index] = self.__normalize(item, subschema)

            # Running native jsonschema traverse algorithm after field normalization is done.
            yield from original_validator(validator_instance, property_value, instance, schema)

        return normalizator

    def transform(self, record: Dict[str, Any], schema: Mapping[str, Any]):
        &#34;&#34;&#34;
        Normalize and validate according to config.
        :param record: record instance for normalization/transformation. All modification are done by modifying existent object.
        :param schema: object&#39;s jsonschema for normalization.
        &#34;&#34;&#34;
        if TransformConfig.NoTransform in self._config:
            return
        normalizer = self._normalizer(schema)
        for e in normalizer.iter_errors(record):
            &#34;&#34;&#34;
            just calling normalizer.validate() would throw an exception on
            first validation occurences and stop processing rest of schema.
            &#34;&#34;&#34;
            logger.warning(e.message)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="airbyte_cdk.sources.utils.transform.TypeTransformer.default_convert"><code class="name flex">
<span>def <span class="ident">default_convert</span></span>(<span>original_item: Any, subschema: Dict[str, Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Default transform function that is used when TransformConfig.DefaultSchemaNormalization flag set.
:param original_item original value of field.
:param subschema part of the jsonschema containing field type/format data.
:return transformed field value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def default_convert(original_item: Any, subschema: Dict[str, Any]) -&gt; Any:
    &#34;&#34;&#34;
    Default transform function that is used when TransformConfig.DefaultSchemaNormalization flag set.
    :param original_item original value of field.
    :param subschema part of the jsonschema containing field type/format data.
    :return transformed field value.
    &#34;&#34;&#34;
    target_type = subschema.get(&#34;type&#34;, [])
    if original_item is None and &#34;null&#34; in target_type:
        return None
    if isinstance(target_type, list):
        # jsonschema type could either be a single string or array of type
        # strings. In case if there is some disambigous and more than one
        # type (except null) do not do any conversion and return original
        # value. If type array has one type and null i.e. {&#34;type&#34;:
        # [&#34;integer&#34;, &#34;null&#34;]}, convert value to specified type.
        target_type = [t for t in target_type if t != &#34;null&#34;]
        if len(target_type) != 1:
            return original_item
        target_type = target_type[0]
    try:
        if target_type == &#34;string&#34;:
            return str(original_item)
        elif target_type == &#34;number&#34;:
            return float(original_item)
        elif target_type == &#34;integer&#34;:
            return int(original_item)
        elif target_type == &#34;boolean&#34;:
            if isinstance(original_item, str):
                return strtobool(original_item) == 1
            return bool(original_item)
    except (ValueError, TypeError):
        return original_item
    return original_item</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="airbyte_cdk.sources.utils.transform.TypeTransformer.registerCustomTransform"><code class="name flex">
<span>def <span class="ident">registerCustomTransform</span></span>(<span>self, normalization_callback: Callable[[Any, Dict[str, Any]], Any]) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Register custom normalization callback.
:param normalization_callback function to be used for value
normalization. Takes original value and part type schema. Should return
normalized value. See docs/connector-development/cdk-python/schemas.md
for details.
:return Same callbeck, this is usefull for using registerCustomTransform function as decorator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def registerCustomTransform(self, normalization_callback: Callable[[Any, Dict[str, Any]], Any]) -&gt; Callable:
    &#34;&#34;&#34;
    Register custom normalization callback.
    :param normalization_callback function to be used for value
    normalization. Takes original value and part type schema. Should return
    normalized value. See docs/connector-development/cdk-python/schemas.md
    for details.
    :return Same callbeck, this is usefull for using registerCustomTransform function as decorator.
    &#34;&#34;&#34;
    if TransformConfig.CustomSchemaNormalization not in self._config:
        raise Exception(&#34;Please set TransformConfig.CustomSchemaNormalization config before registering custom normalizer&#34;)
    self._custom_normalizer = normalization_callback
    return normalization_callback</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.utils.transform.TypeTransformer.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self, record: Dict[str, Any], schema: Mapping[str, Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Normalize and validate according to config.
:param record: record instance for normalization/transformation. All modification are done by modifying existent object.
:param schema: object's jsonschema for normalization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform(self, record: Dict[str, Any], schema: Mapping[str, Any]):
    &#34;&#34;&#34;
    Normalize and validate according to config.
    :param record: record instance for normalization/transformation. All modification are done by modifying existent object.
    :param schema: object&#39;s jsonschema for normalization.
    &#34;&#34;&#34;
    if TransformConfig.NoTransform in self._config:
        return
    normalizer = self._normalizer(schema)
    for e in normalizer.iter_errors(record):
        &#34;&#34;&#34;
        just calling normalizer.validate() would throw an exception on
        first validation occurences and stop processing rest of schema.
        &#34;&#34;&#34;
        logger.warning(e.message)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="airbyte_cdk.sources.utils" href="index.html">airbyte_cdk.sources.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="airbyte_cdk.sources.utils.transform.TransformConfig" href="#airbyte_cdk.sources.utils.transform.TransformConfig">TransformConfig</a></code></h4>
<ul class="">
<li><code><a title="airbyte_cdk.sources.utils.transform.TransformConfig.CustomSchemaNormalization" href="#airbyte_cdk.sources.utils.transform.TransformConfig.CustomSchemaNormalization">CustomSchemaNormalization</a></code></li>
<li><code><a title="airbyte_cdk.sources.utils.transform.TransformConfig.DefaultSchemaNormalization" href="#airbyte_cdk.sources.utils.transform.TransformConfig.DefaultSchemaNormalization">DefaultSchemaNormalization</a></code></li>
<li><code><a title="airbyte_cdk.sources.utils.transform.TransformConfig.NoTransform" href="#airbyte_cdk.sources.utils.transform.TransformConfig.NoTransform">NoTransform</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="airbyte_cdk.sources.utils.transform.TypeTransformer" href="#airbyte_cdk.sources.utils.transform.TypeTransformer">TypeTransformer</a></code></h4>
<ul class="">
<li><code><a title="airbyte_cdk.sources.utils.transform.TypeTransformer.default_convert" href="#airbyte_cdk.sources.utils.transform.TypeTransformer.default_convert">default_convert</a></code></li>
<li><code><a title="airbyte_cdk.sources.utils.transform.TypeTransformer.registerCustomTransform" href="#airbyte_cdk.sources.utils.transform.TypeTransformer.registerCustomTransform">registerCustomTransform</a></code></li>
<li><code><a title="airbyte_cdk.sources.utils.transform.TypeTransformer.transform" href="#airbyte_cdk.sources.utils.transform.TypeTransformer.transform">transform</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>