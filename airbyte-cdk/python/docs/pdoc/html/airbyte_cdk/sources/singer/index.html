<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>airbyte_cdk.sources.singer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>airbyte_cdk.sources.singer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# Copyright (c) 2021 Airbyte, Inc., all rights reserved.
#

from .singer_helpers import SingerHelper, SyncModeInfo
from .source import ConfigContainer, SingerSource

__all__ = [&#34;ConfigContainer&#34;, &#34;SingerSource&#34;, &#34;SyncModeInfo&#34;, &#34;SingerHelper&#34;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="airbyte_cdk.sources.singer.singer_helpers" href="singer_helpers.html">airbyte_cdk.sources.singer.singer_helpers</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="airbyte_cdk.sources.singer.source" href="source.html">airbyte_cdk.sources.singer.source</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="airbyte_cdk.sources.singer.ConfigContainer"><code class="flex name class">
<span>class <span class="ident">ConfigContainer</span></span>
<span>(</span><span>config, config_path)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConfigContainer(Dict[str, Any]):
    config_path: str

    def __init__(self, config, config_path):
        super().__init__(config)
        self.config_path = config_path</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="airbyte_cdk.sources.singer.ConfigContainer.config_path"><code class="name">var <span class="ident">config_path</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="airbyte_cdk.sources.singer.SingerHelper"><code class="flex name class">
<span>class <span class="ident">SingerHelper</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SingerHelper:
    @staticmethod
    def _transform_types(stream_properties: DefaultDict):
        for field_name in stream_properties:
            field_object = stream_properties[field_name]
            # according to issue CDK: typing errors #9500, mypy raises error on this line
            # &#39;&#34;Type[SingerHelper]&#34; has no attribute &#34;_parse_type&#34;&#39;, it&#39;s need to fix
            # ignored for now
            field_object[&#34;type&#34;] = SingerHelper._parse_type(field_object[&#34;type&#34;])  # type: ignore

    @staticmethod
    def singer_catalog_to_airbyte_catalog(
        singer_catalog: Dict[str, Any], sync_mode_overrides: Dict[str, SyncModeInfo], primary_key_overrides: Dict[str, List[str]]
    ) -&gt; AirbyteCatalog:
        &#34;&#34;&#34;
        :param singer_catalog:
        :param sync_mode_overrides: A dict from stream name to the sync modes it should use. Each stream in this dict must exist in the Singer catalog,
          but not every stream in the catalog should exist in this
        :param primary_key_overrides: A dict of stream name -&gt; list of fields to be used as PKs.
        :return: Airbyte Catalog
        &#34;&#34;&#34;
        airbyte_streams = []
        # according to issue CDK: typing errors #9500, mypy raises error on this line
        # &#39;Item &#34;None&#34; of &#34;Optional[Any]&#34; has no attribute &#34;__iter__&#34; (not iterable)&#39;
        # It occurs because default value isn&#39;t set, and it&#39;s None
        # It&#39;s needed to set default value, ignored for now
        for stream in singer_catalog.get(&#34;streams&#34;):  # type: ignore
            name = stream.get(&#34;stream&#34;)
            schema = stream.get(&#34;schema&#34;)
            airbyte_stream = AirbyteStream(name=name, json_schema=schema)
            if name in sync_mode_overrides:
                override_sync_modes(airbyte_stream, sync_mode_overrides[name])
            else:
                set_sync_modes_from_metadata(airbyte_stream, stream.get(&#34;metadata&#34;, []))

            if name in primary_key_overrides:
                airbyte_stream.source_defined_primary_key = [[k] for k in primary_key_overrides[name]]
            elif stream.get(&#34;key_properties&#34;):
                airbyte_stream.source_defined_primary_key = [[k] for k in stream[&#34;key_properties&#34;]]

            airbyte_streams += [airbyte_stream]
        return AirbyteCatalog(streams=airbyte_streams)

    @staticmethod
    def _read_singer_catalog(logger, shell_command: str) -&gt; Mapping[str, Any]:
        completed_process = subprocess.run(
            shell_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True
        )
        for line in completed_process.stderr.splitlines():
            logger.log(*log_by_prefix(line, &#34;ERROR&#34;))

        return json.loads(completed_process.stdout)

    @staticmethod
    def get_catalogs(
        logger,
        shell_command: str,
        sync_mode_overrides: Dict[str, SyncModeInfo],
        primary_key_overrides: Dict[str, List[str]],
        excluded_streams: List,
    ) -&gt; Catalogs:
        singer_catalog = SingerHelper._read_singer_catalog(logger, shell_command)
        streams = singer_catalog.get(&#34;streams&#34;, [])
        if streams and excluded_streams:
            # according to issue CDK: typing errors #9500, mypy raises error on this line
            # &#39;Unsupported target for indexed assignment (&#34;Mapping[str, Any]&#34;)&#39;
            # _read_singer_catalog returns Mapping, to fix this error it should be changed to MutableMapping
            # ignored for now
            singer_catalog[&#34;streams&#34;] = [stream for stream in streams if stream[&#34;stream&#34;] not in excluded_streams]  # type: ignore

        # according to issue CDK: typing errors #9500, mypy raises error on this line
        # &#39;Argument 1 to &#34;singer_catalog_to_airbyte_catalog&#34; of &#34;SingerHelper&#34; has incompatible type &#34;Mapping[str, Any]&#34;; expected &#34;Dict[str, Any]&#34;&#39;
        # singer_catalog is Mapping, because _read_singer_catalog returns Mapping, but singer_catalog_to_airbyte_catalog expects Dict
        # it&#39;s needed to check and fix, ignored for now
        airbyte_catalog = SingerHelper.singer_catalog_to_airbyte_catalog(singer_catalog, sync_mode_overrides, primary_key_overrides)  # type: ignore
        return Catalogs(singer_catalog=singer_catalog, airbyte_catalog=airbyte_catalog)

    @staticmethod
    def read(logger, shell_command, is_message=(lambda x: True)) -&gt; Iterator[AirbyteMessage]:
        with subprocess.Popen(shell_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True) as p:
            for line, text_wrapper in SingerHelper._read_lines(p):
                if text_wrapper is p.stdout:
                    out_json = to_json(line)
                    if out_json is not None and is_message(out_json):
                        message_data = SingerHelper._airbyte_message_from_json(out_json)
                        if message_data is not None:
                            yield message_data
                    else:
                        logger.log(*log_by_prefix(line, &#34;INFO&#34;))
                else:
                    logger.log(*log_by_prefix(line, &#34;ERROR&#34;))

    @staticmethod
    def _read_lines(process: subprocess.Popen) -&gt; Iterator[Tuple[str, TextIOWrapper]]:
        sel = selectors.DefaultSelector()
        # according to issue CDK: typing errors #9500, mypy raises error on this two lines
        # &#39;Argument 1 to &#34;register&#34; of &#34;DefaultSelector&#34; has incompatible type &#34;Optional[IO[Any]]&#34;; expected &#34;Union[int, HasFileno]&#34;&#39;
        # &#39;Argument 1 to &#34;register&#34; of &#34;DefaultSelector&#34; has incompatible type &#34;Optional[IO[Any]]&#34;; expected &#34;Union[int, HasFileno]&#34;&#39;
        # It&#39;s need to check, ignored for now
        sel.register(process.stdout, selectors.EVENT_READ)  # type: ignore
        sel.register(process.stderr, selectors.EVENT_READ)  # type: ignore
        eof = False
        while not eof:
            selects_list = sel.select()
            empty_line_counter = 0
            for key, _ in selects_list:
                # according to issue CDK: typing errors #9500, mypy raises two errors on these lines
                # &#39;Item &#34;int&#34; of &#34;Union[int, HasFileno]&#34; has no attribute &#34;readline&#34;&#39;
                # &#39;Item &#34;HasFileno&#34; of &#34;Union[int, HasFileno]&#34; has no attribute &#34;readline&#34;&#39;
                # It&#39;s need to check, ignored for now
                line = key.fileobj.readline()  # type: ignore
                if not line:
                    empty_line_counter += 1
                    if empty_line_counter &gt;= len(selects_list):
                        eof = True

                        try:
                            process.wait(timeout=60)
                        except subprocess.TimeoutExpired:
                            # according to issue CDK: typing errors #9500, mypy raises error on this line
                            # &#39;On Python 3 &#39;{}&#39;.format(b&#39;abc&#39;) produces &#34;b&#39;abc&#39;&#34;, not &#39;abc&#39;; use &#39;{!r}&#39;.format(b&#39;abc&#39;) if this is desired behavior&#39;
                            # It&#39;s need to fix, ignored for now
                            raise Exception(f&#34;Underlying command {process.args} is hanging&#34;)  # type: ignore

                        if process.returncode != 0:
                            # according to issue CDK: typing errors #9500, mypy raises error on this line
                            # &#39;On Python 3 &#39;{}&#39;.format(b&#39;abc&#39;) produces &#34;b&#39;abc&#39;&#34;, not &#39;abc&#39;; use &#39;{!r}&#39;.format(b&#39;abc&#39;) if this is desired behavior&#39;
                            # It&#39;s need to fix, ignored for now
                            raise Exception(f&#34;Underlying command {process.args} failed with exit code {process.returncode}&#34;)  # type: ignore
                else:
                    # according to issue CDK: typing errors #9500, mypy raises error on this line
                    # &#39;Incompatible types in &#34;yield&#34; (actual type &#34;Tuple[Any, Union[int, HasFileno]]&#34;, expected type &#34;Tuple[str, TextIOWrapper]&#34;)&#39;
                    # It&#39;s need to fix, ignored for now
                    yield line, key.fileobj  # type: ignore

    @staticmethod
    def _airbyte_message_from_json(transformed_json: Mapping[str, Any]) -&gt; Optional[AirbyteMessage]:
        if transformed_json is None or transformed_json.get(&#34;type&#34;) == &#34;SCHEMA&#34; or transformed_json.get(&#34;type&#34;) == &#34;ACTIVATE_VERSION&#34;:
            return None
        elif transformed_json.get(&#34;type&#34;) == &#34;STATE&#34;:
            out_record = AirbyteStateMessage(data=transformed_json[&#34;value&#34;])
            out_message = AirbyteMessage(type=Type.STATE, state=out_record)
        else:
            # todo: check that messages match the discovered schema
            stream_name = transformed_json[&#34;stream&#34;]
            # according to issue CDK: typing errors #9500, mypy raises error on this line
            # &#39;Incompatible types in assignment (expression has type &#34;AirbyteRecordMessage&#34;, variable has type &#34;AirbyteStateMessage&#34;)&#39;
            # type of out_record is first initialized as AirbyteStateMessage on the line 240
            # however AirbyteRecordMessage is assigned on the line below, it causes error
            # ignored
            out_record = AirbyteRecordMessage(  # type: ignore
                stream=stream_name,
                data=transformed_json[&#34;record&#34;],
                emitted_at=int(datetime.now().timestamp()) * 1000,
            )
            out_message = AirbyteMessage(type=Type.RECORD, record=out_record)
        return out_message

    @staticmethod
    def create_singer_catalog_with_selection(masked_airbyte_catalog: ConfiguredAirbyteCatalog, discovered_singer_catalog: object) -&gt; str:
        combined_catalog_path = os.path.join(&#34;singer_rendered_catalog.json&#34;)
        masked_singer_streams = []

        stream_name_to_configured_stream = {
            configured_stream.stream.name: configured_stream for configured_stream in masked_airbyte_catalog.streams
        }

        # according to issue CDK: typing errors #9500, mypy raises error on this line
        # &#39;&#34;object&#34; has no attribute &#34;get&#34;&#39;
        # discovered_singer_catalog type is set to object on the line 259, need to check
        # ignored for now
        for singer_stream in discovered_singer_catalog.get(&#34;streams&#34;):  # type: ignore
            stream_name = singer_stream.get(&#34;stream&#34;)
            if stream_name in stream_name_to_configured_stream:
                new_metadatas = []
                # support old style catalog.
                singer_stream[&#34;schema&#34;][&#34;selected&#34;] = True
                if singer_stream.get(&#34;metadata&#34;):
                    metadatas = singer_stream.get(&#34;metadata&#34;)
                    for metadata in metadatas:
                        new_metadata = metadata
                        new_metadata[&#34;metadata&#34;][&#34;selected&#34;] = True
                        if not is_field_metadata(new_metadata):
                            configured_stream = stream_name_to_configured_stream[stream_name]
                            if configured_for_incremental(configured_stream):
                                replication_method = _INCREMENTAL
                                if configured_stream.cursor_field:
                                    new_metadata[&#34;metadata&#34;][&#34;replication-key&#34;] = configured_stream.cursor_field[0]
                            else:
                                replication_method = _FULL_TABLE
                            new_metadata[&#34;metadata&#34;][&#34;forced-replication-method&#34;] = replication_method
                            new_metadata[&#34;metadata&#34;][&#34;replication-method&#34;] = replication_method
                        else:
                            if &#34;fieldExclusions&#34; in new_metadata[&#34;metadata&#34;]:
                                new_metadata[&#34;metadata&#34;][&#34;selected&#34;] = True if not new_metadata[&#34;metadata&#34;][&#34;fieldExclusions&#34;] else False
                        new_metadatas += [new_metadata]
                    singer_stream[&#34;metadata&#34;] = new_metadatas

            masked_singer_streams += [singer_stream]

        combined_catalog = {&#34;streams&#34;: masked_singer_streams}
        with open(combined_catalog_path, &#34;w&#34;) as fh:
            fh.write(json.dumps(combined_catalog))

        return combined_catalog_path</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="airbyte_cdk.sources.singer.SingerHelper.create_singer_catalog_with_selection"><code class="name flex">
<span>def <span class="ident">create_singer_catalog_with_selection</span></span>(<span>masked_airbyte_catalog:Â <a title="airbyte_cdk.models.airbyte_protocol.ConfiguredAirbyteCatalog" href="../../models/airbyte_protocol.html#airbyte_cdk.models.airbyte_protocol.ConfiguredAirbyteCatalog">ConfiguredAirbyteCatalog</a>, discovered_singer_catalog:Â object) â>Â str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_singer_catalog_with_selection(masked_airbyte_catalog: ConfiguredAirbyteCatalog, discovered_singer_catalog: object) -&gt; str:
    combined_catalog_path = os.path.join(&#34;singer_rendered_catalog.json&#34;)
    masked_singer_streams = []

    stream_name_to_configured_stream = {
        configured_stream.stream.name: configured_stream for configured_stream in masked_airbyte_catalog.streams
    }

    # according to issue CDK: typing errors #9500, mypy raises error on this line
    # &#39;&#34;object&#34; has no attribute &#34;get&#34;&#39;
    # discovered_singer_catalog type is set to object on the line 259, need to check
    # ignored for now
    for singer_stream in discovered_singer_catalog.get(&#34;streams&#34;):  # type: ignore
        stream_name = singer_stream.get(&#34;stream&#34;)
        if stream_name in stream_name_to_configured_stream:
            new_metadatas = []
            # support old style catalog.
            singer_stream[&#34;schema&#34;][&#34;selected&#34;] = True
            if singer_stream.get(&#34;metadata&#34;):
                metadatas = singer_stream.get(&#34;metadata&#34;)
                for metadata in metadatas:
                    new_metadata = metadata
                    new_metadata[&#34;metadata&#34;][&#34;selected&#34;] = True
                    if not is_field_metadata(new_metadata):
                        configured_stream = stream_name_to_configured_stream[stream_name]
                        if configured_for_incremental(configured_stream):
                            replication_method = _INCREMENTAL
                            if configured_stream.cursor_field:
                                new_metadata[&#34;metadata&#34;][&#34;replication-key&#34;] = configured_stream.cursor_field[0]
                        else:
                            replication_method = _FULL_TABLE
                        new_metadata[&#34;metadata&#34;][&#34;forced-replication-method&#34;] = replication_method
                        new_metadata[&#34;metadata&#34;][&#34;replication-method&#34;] = replication_method
                    else:
                        if &#34;fieldExclusions&#34; in new_metadata[&#34;metadata&#34;]:
                            new_metadata[&#34;metadata&#34;][&#34;selected&#34;] = True if not new_metadata[&#34;metadata&#34;][&#34;fieldExclusions&#34;] else False
                    new_metadatas += [new_metadata]
                singer_stream[&#34;metadata&#34;] = new_metadatas

        masked_singer_streams += [singer_stream]

    combined_catalog = {&#34;streams&#34;: masked_singer_streams}
    with open(combined_catalog_path, &#34;w&#34;) as fh:
        fh.write(json.dumps(combined_catalog))

    return combined_catalog_path</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.SingerHelper.get_catalogs"><code class="name flex">
<span>def <span class="ident">get_catalogs</span></span>(<span>logger, shell_command:Â str, sync_mode_overrides:Â Dict[str,Â <a title="airbyte_cdk.sources.singer.singer_helpers.SyncModeInfo" href="singer_helpers.html#airbyte_cdk.sources.singer.singer_helpers.SyncModeInfo">SyncModeInfo</a>], primary_key_overrides:Â Dict[str,Â List[str]], excluded_streams:Â List) â>Â <a title="airbyte_cdk.sources.singer.singer_helpers.Catalogs" href="singer_helpers.html#airbyte_cdk.sources.singer.singer_helpers.Catalogs">Catalogs</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_catalogs(
    logger,
    shell_command: str,
    sync_mode_overrides: Dict[str, SyncModeInfo],
    primary_key_overrides: Dict[str, List[str]],
    excluded_streams: List,
) -&gt; Catalogs:
    singer_catalog = SingerHelper._read_singer_catalog(logger, shell_command)
    streams = singer_catalog.get(&#34;streams&#34;, [])
    if streams and excluded_streams:
        # according to issue CDK: typing errors #9500, mypy raises error on this line
        # &#39;Unsupported target for indexed assignment (&#34;Mapping[str, Any]&#34;)&#39;
        # _read_singer_catalog returns Mapping, to fix this error it should be changed to MutableMapping
        # ignored for now
        singer_catalog[&#34;streams&#34;] = [stream for stream in streams if stream[&#34;stream&#34;] not in excluded_streams]  # type: ignore

    # according to issue CDK: typing errors #9500, mypy raises error on this line
    # &#39;Argument 1 to &#34;singer_catalog_to_airbyte_catalog&#34; of &#34;SingerHelper&#34; has incompatible type &#34;Mapping[str, Any]&#34;; expected &#34;Dict[str, Any]&#34;&#39;
    # singer_catalog is Mapping, because _read_singer_catalog returns Mapping, but singer_catalog_to_airbyte_catalog expects Dict
    # it&#39;s needed to check and fix, ignored for now
    airbyte_catalog = SingerHelper.singer_catalog_to_airbyte_catalog(singer_catalog, sync_mode_overrides, primary_key_overrides)  # type: ignore
    return Catalogs(singer_catalog=singer_catalog, airbyte_catalog=airbyte_catalog)</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.SingerHelper.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>logger, shell_command, is_message=&lt;function SingerHelper.&lt;lambda&gt;&gt;) â>Â Iterator[<a title="airbyte_cdk.models.airbyte_protocol.AirbyteMessage" href="../../models/airbyte_protocol.html#airbyte_cdk.models.airbyte_protocol.AirbyteMessage">AirbyteMessage</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read(logger, shell_command, is_message=(lambda x: True)) -&gt; Iterator[AirbyteMessage]:
    with subprocess.Popen(shell_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True) as p:
        for line, text_wrapper in SingerHelper._read_lines(p):
            if text_wrapper is p.stdout:
                out_json = to_json(line)
                if out_json is not None and is_message(out_json):
                    message_data = SingerHelper._airbyte_message_from_json(out_json)
                    if message_data is not None:
                        yield message_data
                else:
                    logger.log(*log_by_prefix(line, &#34;INFO&#34;))
            else:
                logger.log(*log_by_prefix(line, &#34;ERROR&#34;))</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.SingerHelper.singer_catalog_to_airbyte_catalog"><code class="name flex">
<span>def <span class="ident">singer_catalog_to_airbyte_catalog</span></span>(<span>singer_catalog:Â Dict[str,Â Any], sync_mode_overrides:Â Dict[str,Â <a title="airbyte_cdk.sources.singer.singer_helpers.SyncModeInfo" href="singer_helpers.html#airbyte_cdk.sources.singer.singer_helpers.SyncModeInfo">SyncModeInfo</a>], primary_key_overrides:Â Dict[str,Â List[str]]) â>Â <a title="airbyte_cdk.models.airbyte_protocol.AirbyteCatalog" href="../../models/airbyte_protocol.html#airbyte_cdk.models.airbyte_protocol.AirbyteCatalog">AirbyteCatalog</a></span>
</code></dt>
<dd>
<div class="desc"><p>:param singer_catalog:
:param sync_mode_overrides: A dict from stream name to the sync modes it should use. Each stream in this dict must exist in the Singer catalog,
but not every stream in the catalog should exist in this
:param primary_key_overrides: A dict of stream name -&gt; list of fields to be used as PKs.
:return: Airbyte Catalog</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def singer_catalog_to_airbyte_catalog(
    singer_catalog: Dict[str, Any], sync_mode_overrides: Dict[str, SyncModeInfo], primary_key_overrides: Dict[str, List[str]]
) -&gt; AirbyteCatalog:
    &#34;&#34;&#34;
    :param singer_catalog:
    :param sync_mode_overrides: A dict from stream name to the sync modes it should use. Each stream in this dict must exist in the Singer catalog,
      but not every stream in the catalog should exist in this
    :param primary_key_overrides: A dict of stream name -&gt; list of fields to be used as PKs.
    :return: Airbyte Catalog
    &#34;&#34;&#34;
    airbyte_streams = []
    # according to issue CDK: typing errors #9500, mypy raises error on this line
    # &#39;Item &#34;None&#34; of &#34;Optional[Any]&#34; has no attribute &#34;__iter__&#34; (not iterable)&#39;
    # It occurs because default value isn&#39;t set, and it&#39;s None
    # It&#39;s needed to set default value, ignored for now
    for stream in singer_catalog.get(&#34;streams&#34;):  # type: ignore
        name = stream.get(&#34;stream&#34;)
        schema = stream.get(&#34;schema&#34;)
        airbyte_stream = AirbyteStream(name=name, json_schema=schema)
        if name in sync_mode_overrides:
            override_sync_modes(airbyte_stream, sync_mode_overrides[name])
        else:
            set_sync_modes_from_metadata(airbyte_stream, stream.get(&#34;metadata&#34;, []))

        if name in primary_key_overrides:
            airbyte_stream.source_defined_primary_key = [[k] for k in primary_key_overrides[name]]
        elif stream.get(&#34;key_properties&#34;):
            airbyte_stream.source_defined_primary_key = [[k] for k in stream[&#34;key_properties&#34;]]

        airbyte_streams += [airbyte_stream]
    return AirbyteCatalog(streams=airbyte_streams)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="airbyte_cdk.sources.singer.SingerSource"><code class="flex name class">
<span>class <span class="ident">SingerSource</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SingerSource(BaseSource[ConfigContainer, str, str]):
    def configure(self, config: Mapping[str, Any], temp_dir: str) -&gt; ConfigContainer:
        &#34;&#34;&#34;
        Persist raw_config in temporary directory to run the Source job
        This can be overridden if extra temporary files need to be persisted in the temp dir
        &#34;&#34;&#34;
        config_path = os.path.join(temp_dir, &#34;config.json&#34;)
        config = ConfigContainer(self.transform_config(config), config_path)
        self.write_config(config, config_path)
        return config

    # Can be overridden to change an input config
    def transform_config(self, config: Mapping[str, Any]) -&gt; Mapping[str, Any]:
        &#34;&#34;&#34;
        Singer source may need to adapt the Config object for the singer tap specifics
        &#34;&#34;&#34;
        return config

    def read_catalog(self, catalog_path: str) -&gt; str:
        &#34;&#34;&#34;
        Since singer source don&#39;t need actual catalog object, we override this to return path only
        &#34;&#34;&#34;
        return catalog_path

    def read_state(self, state_path: str) -&gt; str:
        &#34;&#34;&#34;
        Since singer source don&#39;t need actual state object, we override this to return path only
        &#34;&#34;&#34;
        return state_path

    def check_config(self, logger: logging.Logger, config_path: str, config: ConfigContainer) -&gt; AirbyteConnectionStatus:
        &#34;&#34;&#34;
        Some Singer source may perform check using config_path or config to
        tests if the input configuration can be used to successfully connect to the integration
        &#34;&#34;&#34;
        raise NotImplementedError

    def discover_cmd(self, logger: logging.Logger, config_path: str) -&gt; str:
        &#34;&#34;&#34;
        Returns the command used to run discovery in the singer tap. For example, if the bash command used to invoke the singer tap is `tap-postgres`,
        and the config JSON lived in &#34;/path/config.json&#34;, this method would return &#34;tap-postgres --config /path/config.json&#34;
        &#34;&#34;&#34;
        raise NotImplementedError

    def read_cmd(self, logger: logging.Logger, config_path: str, catalog_path: str, state_path: str = None) -&gt; str:
        &#34;&#34;&#34;
        Returns the command used to read data from the singer tap. For example, if the bash command used to invoke the singer tap is `tap-postgres`,
        and the config JSON lived in &#34;/path/config.json&#34;, and the catalog was in &#34;/path/catalog.json&#34;,
        this method would return &#34;tap-postgres --config /path/config.json --catalog /path/catalog.json&#34;
        &#34;&#34;&#34;
        raise NotImplementedError

    def _discover_internal(self, logger: logging.Logger, config_path: str) -&gt; Catalogs:
        cmd = self.discover_cmd(logger, config_path)
        catalogs = SingerHelper.get_catalogs(
            logger, cmd, self.get_sync_mode_overrides(), self.get_primary_key_overrides(), self.get_excluded_streams()
        )
        return catalogs

    def check(self, logger: logging.Logger, config: ConfigContainer) -&gt; AirbyteConnectionStatus:
        &#34;&#34;&#34;
        Tests if the input configuration can be used to successfully connect to the integration
        &#34;&#34;&#34;
        return self.check_config(logger, config.config_path, config)

    def discover(self, logger: logging.Logger, config: ConfigContainer) -&gt; AirbyteCatalog:
        &#34;&#34;&#34;
        Implements the parent class discover method.
        &#34;&#34;&#34;
        return self._discover_internal(logger, config.config_path).airbyte_catalog

    def read(self, logger: logging.Logger, config: ConfigContainer, catalog_path: str, state_path: str = None) -&gt; Iterable[AirbyteMessage]:
        &#34;&#34;&#34;
        Implements the parent class read method.
        &#34;&#34;&#34;
        catalogs = self._discover_internal(logger, config.config_path)
        masked_airbyte_catalog = ConfiguredAirbyteCatalog.parse_obj(self.read_config(catalog_path))
        selected_singer_catalog_path = SingerHelper.create_singer_catalog_with_selection(masked_airbyte_catalog, catalogs.singer_catalog)

        read_cmd = self.read_cmd(logger, config.config_path, selected_singer_catalog_path, state_path)
        return SingerHelper.read(logger, read_cmd)

    def get_sync_mode_overrides(self) -&gt; Dict[str, SyncModeInfo]:
        &#34;&#34;&#34;
        The Singer Spec outlines a way for taps to declare in their catalog that their streams support incremental sync (valid-replication-keys,
        forced-replication-method, and others). However, many taps which are incremental don&#39;t actually declare that via the catalog, and just
        use their input state to perform an incremental sync without giving any hints to the user. An Airbyte Connector built on top of such a
        Singer Tap cannot automatically detect which streams are full refresh or incremental or what their cursors are. In those cases the developer
        needs to manually specify information about the sync modes.

        This method provides a way of doing that: the dict of stream names to SyncModeInfo returned from this method will be used to override each
        stream&#39;s sync mode information in the Airbyte Catalog output from the discover method. Only set fields provided in the SyncModeInfo are used.
        If a SyncModeInfo field is not set, it will not be overridden in the output catalog.

        :return: A dict from stream name to the sync modes that should be applied to this stream.
        &#34;&#34;&#34;
        return {}

    def get_primary_key_overrides(self) -&gt; Dict[str, List[str]]:
        &#34;&#34;&#34;
        Similar to get_sync_mode_overrides but for primary keys.

        :return: A dict from stream name to the list of primary key fields for the stream.
        &#34;&#34;&#34;
        return {}

    def get_excluded_streams(self) -&gt; List[str]:
        &#34;&#34;&#34;
        This method provide ability to exclude some streams from catalog

        :return: A list of excluded stream names
        &#34;&#34;&#34;
        return []</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="airbyte_cdk.sources.source.BaseSource" href="../source.html#airbyte_cdk.sources.source.BaseSource">BaseSource</a></li>
<li><a title="airbyte_cdk.connector.BaseConnector" href="../../connector.html#airbyte_cdk.connector.BaseConnector">BaseConnector</a></li>
<li>abc.ABC</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="airbyte_cdk.sources.singer.source.BaseSingerSource" href="source.html#airbyte_cdk.sources.singer.source.BaseSingerSource">BaseSingerSource</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="airbyte_cdk.sources.singer.SingerSource.check_config_against_spec"><code class="name">var <span class="ident">check_config_against_spec</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="airbyte_cdk.sources.singer.SingerSource.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, logger:Â logging.Logger, config:Â <a title="airbyte_cdk.sources.singer.source.ConfigContainer" href="source.html#airbyte_cdk.sources.singer.source.ConfigContainer">ConfigContainer</a>) â>Â <a title="airbyte_cdk.models.airbyte_protocol.AirbyteConnectionStatus" href="../../models/airbyte_protocol.html#airbyte_cdk.models.airbyte_protocol.AirbyteConnectionStatus">AirbyteConnectionStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Tests if the input configuration can be used to successfully connect to the integration</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check(self, logger: logging.Logger, config: ConfigContainer) -&gt; AirbyteConnectionStatus:
    &#34;&#34;&#34;
    Tests if the input configuration can be used to successfully connect to the integration
    &#34;&#34;&#34;
    return self.check_config(logger, config.config_path, config)</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.SingerSource.check_config"><code class="name flex">
<span>def <span class="ident">check_config</span></span>(<span>self, logger:Â logging.Logger, config_path:Â str, config:Â <a title="airbyte_cdk.sources.singer.source.ConfigContainer" href="source.html#airbyte_cdk.sources.singer.source.ConfigContainer">ConfigContainer</a>) â>Â <a title="airbyte_cdk.models.airbyte_protocol.AirbyteConnectionStatus" href="../../models/airbyte_protocol.html#airbyte_cdk.models.airbyte_protocol.AirbyteConnectionStatus">AirbyteConnectionStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Some Singer source may perform check using config_path or config to
tests if the input configuration can be used to successfully connect to the integration</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_config(self, logger: logging.Logger, config_path: str, config: ConfigContainer) -&gt; AirbyteConnectionStatus:
    &#34;&#34;&#34;
    Some Singer source may perform check using config_path or config to
    tests if the input configuration can be used to successfully connect to the integration
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.SingerSource.configure"><code class="name flex">
<span>def <span class="ident">configure</span></span>(<span>self, config:Â Mapping[str,Â Any], temp_dir:Â str) â>Â <a title="airbyte_cdk.sources.singer.source.ConfigContainer" href="source.html#airbyte_cdk.sources.singer.source.ConfigContainer">ConfigContainer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Persist raw_config in temporary directory to run the Source job
This can be overridden if extra temporary files need to be persisted in the temp dir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure(self, config: Mapping[str, Any], temp_dir: str) -&gt; ConfigContainer:
    &#34;&#34;&#34;
    Persist raw_config in temporary directory to run the Source job
    This can be overridden if extra temporary files need to be persisted in the temp dir
    &#34;&#34;&#34;
    config_path = os.path.join(temp_dir, &#34;config.json&#34;)
    config = ConfigContainer(self.transform_config(config), config_path)
    self.write_config(config, config_path)
    return config</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.SingerSource.discover"><code class="name flex">
<span>def <span class="ident">discover</span></span>(<span>self, logger:Â logging.Logger, config:Â <a title="airbyte_cdk.sources.singer.source.ConfigContainer" href="source.html#airbyte_cdk.sources.singer.source.ConfigContainer">ConfigContainer</a>) â>Â <a title="airbyte_cdk.models.airbyte_protocol.AirbyteCatalog" href="../../models/airbyte_protocol.html#airbyte_cdk.models.airbyte_protocol.AirbyteCatalog">AirbyteCatalog</a></span>
</code></dt>
<dd>
<div class="desc"><p>Implements the parent class discover method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discover(self, logger: logging.Logger, config: ConfigContainer) -&gt; AirbyteCatalog:
    &#34;&#34;&#34;
    Implements the parent class discover method.
    &#34;&#34;&#34;
    return self._discover_internal(logger, config.config_path).airbyte_catalog</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.SingerSource.discover_cmd"><code class="name flex">
<span>def <span class="ident">discover_cmd</span></span>(<span>self, logger:Â logging.Logger, config_path:Â str) â>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the command used to run discovery in the singer tap. For example, if the bash command used to invoke the singer tap is <code>tap-postgres</code>,
and the config JSON lived in "/path/config.json", this method would return "tap-postgres &ndash;config /path/config.json"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discover_cmd(self, logger: logging.Logger, config_path: str) -&gt; str:
    &#34;&#34;&#34;
    Returns the command used to run discovery in the singer tap. For example, if the bash command used to invoke the singer tap is `tap-postgres`,
    and the config JSON lived in &#34;/path/config.json&#34;, this method would return &#34;tap-postgres --config /path/config.json&#34;
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.SingerSource.get_excluded_streams"><code class="name flex">
<span>def <span class="ident">get_excluded_streams</span></span>(<span>self) â>Â List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>This method provide ability to exclude some streams from catalog</p>
<p>:return: A list of excluded stream names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_excluded_streams(self) -&gt; List[str]:
    &#34;&#34;&#34;
    This method provide ability to exclude some streams from catalog

    :return: A list of excluded stream names
    &#34;&#34;&#34;
    return []</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.SingerSource.get_primary_key_overrides"><code class="name flex">
<span>def <span class="ident">get_primary_key_overrides</span></span>(<span>self) â>Â Dict[str,Â List[str]]</span>
</code></dt>
<dd>
<div class="desc"><p>Similar to get_sync_mode_overrides but for primary keys.</p>
<p>:return: A dict from stream name to the list of primary key fields for the stream.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_primary_key_overrides(self) -&gt; Dict[str, List[str]]:
    &#34;&#34;&#34;
    Similar to get_sync_mode_overrides but for primary keys.

    :return: A dict from stream name to the list of primary key fields for the stream.
    &#34;&#34;&#34;
    return {}</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.SingerSource.get_sync_mode_overrides"><code class="name flex">
<span>def <span class="ident">get_sync_mode_overrides</span></span>(<span>self) â>Â Dict[str,Â <a title="airbyte_cdk.sources.singer.singer_helpers.SyncModeInfo" href="singer_helpers.html#airbyte_cdk.sources.singer.singer_helpers.SyncModeInfo">SyncModeInfo</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>The Singer Spec outlines a way for taps to declare in their catalog that their streams support incremental sync (valid-replication-keys,
forced-replication-method, and others). However, many taps which are incremental don't actually declare that via the catalog, and just
use their input state to perform an incremental sync without giving any hints to the user. An Airbyte Connector built on top of such a
Singer Tap cannot automatically detect which streams are full refresh or incremental or what their cursors are. In those cases the developer
needs to manually specify information about the sync modes.</p>
<p>This method provides a way of doing that: the dict of stream names to SyncModeInfo returned from this method will be used to override each
stream's sync mode information in the Airbyte Catalog output from the discover method. Only set fields provided in the SyncModeInfo are used.
If a SyncModeInfo field is not set, it will not be overridden in the output catalog.</p>
<p>:return: A dict from stream name to the sync modes that should be applied to this stream.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sync_mode_overrides(self) -&gt; Dict[str, SyncModeInfo]:
    &#34;&#34;&#34;
    The Singer Spec outlines a way for taps to declare in their catalog that their streams support incremental sync (valid-replication-keys,
    forced-replication-method, and others). However, many taps which are incremental don&#39;t actually declare that via the catalog, and just
    use their input state to perform an incremental sync without giving any hints to the user. An Airbyte Connector built on top of such a
    Singer Tap cannot automatically detect which streams are full refresh or incremental or what their cursors are. In those cases the developer
    needs to manually specify information about the sync modes.

    This method provides a way of doing that: the dict of stream names to SyncModeInfo returned from this method will be used to override each
    stream&#39;s sync mode information in the Airbyte Catalog output from the discover method. Only set fields provided in the SyncModeInfo are used.
    If a SyncModeInfo field is not set, it will not be overridden in the output catalog.

    :return: A dict from stream name to the sync modes that should be applied to this stream.
    &#34;&#34;&#34;
    return {}</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.SingerSource.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, logger:Â logging.Logger, config:Â <a title="airbyte_cdk.sources.singer.source.ConfigContainer" href="source.html#airbyte_cdk.sources.singer.source.ConfigContainer">ConfigContainer</a>, catalog_path:Â str, state_path:Â strÂ =Â None) â>Â Iterable[<a title="airbyte_cdk.models.airbyte_protocol.AirbyteMessage" href="../../models/airbyte_protocol.html#airbyte_cdk.models.airbyte_protocol.AirbyteMessage">AirbyteMessage</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the parent class read method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, logger: logging.Logger, config: ConfigContainer, catalog_path: str, state_path: str = None) -&gt; Iterable[AirbyteMessage]:
    &#34;&#34;&#34;
    Implements the parent class read method.
    &#34;&#34;&#34;
    catalogs = self._discover_internal(logger, config.config_path)
    masked_airbyte_catalog = ConfiguredAirbyteCatalog.parse_obj(self.read_config(catalog_path))
    selected_singer_catalog_path = SingerHelper.create_singer_catalog_with_selection(masked_airbyte_catalog, catalogs.singer_catalog)

    read_cmd = self.read_cmd(logger, config.config_path, selected_singer_catalog_path, state_path)
    return SingerHelper.read(logger, read_cmd)</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.SingerSource.read_catalog"><code class="name flex">
<span>def <span class="ident">read_catalog</span></span>(<span>self, catalog_path:Â str) â>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Since singer source don't need actual catalog object, we override this to return path only</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_catalog(self, catalog_path: str) -&gt; str:
    &#34;&#34;&#34;
    Since singer source don&#39;t need actual catalog object, we override this to return path only
    &#34;&#34;&#34;
    return catalog_path</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.SingerSource.read_cmd"><code class="name flex">
<span>def <span class="ident">read_cmd</span></span>(<span>self, logger:Â logging.Logger, config_path:Â str, catalog_path:Â str, state_path:Â strÂ =Â None) â>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the command used to read data from the singer tap. For example, if the bash command used to invoke the singer tap is <code>tap-postgres</code>,
and the config JSON lived in "/path/config.json", and the catalog was in "/path/catalog.json",
this method would return "tap-postgres &ndash;config /path/config.json &ndash;catalog /path/catalog.json"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_cmd(self, logger: logging.Logger, config_path: str, catalog_path: str, state_path: str = None) -&gt; str:
    &#34;&#34;&#34;
    Returns the command used to read data from the singer tap. For example, if the bash command used to invoke the singer tap is `tap-postgres`,
    and the config JSON lived in &#34;/path/config.json&#34;, and the catalog was in &#34;/path/catalog.json&#34;,
    this method would return &#34;tap-postgres --config /path/config.json --catalog /path/catalog.json&#34;
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.SingerSource.read_state"><code class="name flex">
<span>def <span class="ident">read_state</span></span>(<span>self, state_path:Â str) â>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Since singer source don't need actual state object, we override this to return path only</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_state(self, state_path: str) -&gt; str:
    &#34;&#34;&#34;
    Since singer source don&#39;t need actual state object, we override this to return path only
    &#34;&#34;&#34;
    return state_path</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.SingerSource.transform_config"><code class="name flex">
<span>def <span class="ident">transform_config</span></span>(<span>self, config:Â Mapping[str,Â Any]) â>Â Mapping[str,Â Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Singer source may need to adapt the Config object for the singer tap specifics</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_config(self, config: Mapping[str, Any]) -&gt; Mapping[str, Any]:
    &#34;&#34;&#34;
    Singer source may need to adapt the Config object for the singer tap specifics
    &#34;&#34;&#34;
    return config</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="airbyte_cdk.sources.source.BaseSource" href="../source.html#airbyte_cdk.sources.source.BaseSource">BaseSource</a></b></code>:
<ul class="hlist">
<li><code><a title="airbyte_cdk.sources.source.BaseSource.spec" href="../../connector.html#airbyte_cdk.connector.BaseConnector.spec">spec</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="airbyte_cdk.sources.singer.SyncModeInfo"><code class="flex name class">
<span>class <span class="ident">SyncModeInfo</span></span>
<span>(</span><span>supported_sync_modes:Â Optional[List[<a title="airbyte_cdk.models.airbyte_protocol.SyncMode" href="../../models/airbyte_protocol.html#airbyte_cdk.models.airbyte_protocol.SyncMode">SyncMode</a>]]Â =Â None, source_defined_cursor:Â Optional[bool]Â =Â None, default_cursor_field:Â Optional[List[str]]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>SyncModeInfo(supported_sync_modes: Optional[List[airbyte_cdk.models.airbyte_protocol.SyncMode]] = None, source_defined_cursor: Optional[bool] = None, default_cursor_field: Optional[List[str]] = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class SyncModeInfo:
    supported_sync_modes: Optional[List[SyncMode]] = None
    source_defined_cursor: Optional[bool] = None
    default_cursor_field: Optional[List[str]] = None</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="airbyte_cdk.sources.singer.SyncModeInfo.default_cursor_field"><code class="name">var <span class="ident">default_cursor_field</span> :Â Optional[List[str]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="airbyte_cdk.sources.singer.SyncModeInfo.source_defined_cursor"><code class="name">var <span class="ident">source_defined_cursor</span> :Â Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="airbyte_cdk.sources.singer.SyncModeInfo.supported_sync_modes"><code class="name">var <span class="ident">supported_sync_modes</span> :Â Optional[List[<a title="airbyte_cdk.models.airbyte_protocol.SyncMode" href="../../models/airbyte_protocol.html#airbyte_cdk.models.airbyte_protocol.SyncMode">SyncMode</a>]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="airbyte_cdk.sources" href="../index.html">airbyte_cdk.sources</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="airbyte_cdk.sources.singer.singer_helpers" href="singer_helpers.html">airbyte_cdk.sources.singer.singer_helpers</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source" href="source.html">airbyte_cdk.sources.singer.source</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="airbyte_cdk.sources.singer.ConfigContainer" href="#airbyte_cdk.sources.singer.ConfigContainer">ConfigContainer</a></code></h4>
<ul class="">
<li><code><a title="airbyte_cdk.sources.singer.ConfigContainer.config_path" href="#airbyte_cdk.sources.singer.ConfigContainer.config_path">config_path</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="airbyte_cdk.sources.singer.SingerHelper" href="#airbyte_cdk.sources.singer.SingerHelper">SingerHelper</a></code></h4>
<ul class="">
<li><code><a title="airbyte_cdk.sources.singer.SingerHelper.create_singer_catalog_with_selection" href="#airbyte_cdk.sources.singer.SingerHelper.create_singer_catalog_with_selection">create_singer_catalog_with_selection</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.SingerHelper.get_catalogs" href="#airbyte_cdk.sources.singer.SingerHelper.get_catalogs">get_catalogs</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.SingerHelper.read" href="#airbyte_cdk.sources.singer.SingerHelper.read">read</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.SingerHelper.singer_catalog_to_airbyte_catalog" href="#airbyte_cdk.sources.singer.SingerHelper.singer_catalog_to_airbyte_catalog">singer_catalog_to_airbyte_catalog</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="airbyte_cdk.sources.singer.SingerSource" href="#airbyte_cdk.sources.singer.SingerSource">SingerSource</a></code></h4>
<ul class="">
<li><code><a title="airbyte_cdk.sources.singer.SingerSource.check" href="#airbyte_cdk.sources.singer.SingerSource.check">check</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.SingerSource.check_config" href="#airbyte_cdk.sources.singer.SingerSource.check_config">check_config</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.SingerSource.check_config_against_spec" href="#airbyte_cdk.sources.singer.SingerSource.check_config_against_spec">check_config_against_spec</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.SingerSource.configure" href="#airbyte_cdk.sources.singer.SingerSource.configure">configure</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.SingerSource.discover" href="#airbyte_cdk.sources.singer.SingerSource.discover">discover</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.SingerSource.discover_cmd" href="#airbyte_cdk.sources.singer.SingerSource.discover_cmd">discover_cmd</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.SingerSource.get_excluded_streams" href="#airbyte_cdk.sources.singer.SingerSource.get_excluded_streams">get_excluded_streams</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.SingerSource.get_primary_key_overrides" href="#airbyte_cdk.sources.singer.SingerSource.get_primary_key_overrides">get_primary_key_overrides</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.SingerSource.get_sync_mode_overrides" href="#airbyte_cdk.sources.singer.SingerSource.get_sync_mode_overrides">get_sync_mode_overrides</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.SingerSource.read" href="#airbyte_cdk.sources.singer.SingerSource.read">read</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.SingerSource.read_catalog" href="#airbyte_cdk.sources.singer.SingerSource.read_catalog">read_catalog</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.SingerSource.read_cmd" href="#airbyte_cdk.sources.singer.SingerSource.read_cmd">read_cmd</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.SingerSource.read_state" href="#airbyte_cdk.sources.singer.SingerSource.read_state">read_state</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.SingerSource.transform_config" href="#airbyte_cdk.sources.singer.SingerSource.transform_config">transform_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="airbyte_cdk.sources.singer.SyncModeInfo" href="#airbyte_cdk.sources.singer.SyncModeInfo">SyncModeInfo</a></code></h4>
<ul class="">
<li><code><a title="airbyte_cdk.sources.singer.SyncModeInfo.default_cursor_field" href="#airbyte_cdk.sources.singer.SyncModeInfo.default_cursor_field">default_cursor_field</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.SyncModeInfo.source_defined_cursor" href="#airbyte_cdk.sources.singer.SyncModeInfo.source_defined_cursor">source_defined_cursor</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.SyncModeInfo.supported_sync_modes" href="#airbyte_cdk.sources.singer.SyncModeInfo.supported_sync_modes">supported_sync_modes</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>