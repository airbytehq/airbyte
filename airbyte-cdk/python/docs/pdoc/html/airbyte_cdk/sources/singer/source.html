<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>airbyte_cdk.sources.singer.source API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>airbyte_cdk.sources.singer.source</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# Copyright (c) 2022 Airbyte, Inc., all rights reserved.
#


import logging
import os
from typing import Any, Dict, Iterable, List, Mapping, Type

from airbyte_cdk.models import AirbyteCatalog, AirbyteConnectionStatus, AirbyteMessage, ConfiguredAirbyteCatalog, Status
from airbyte_cdk.sources.source import BaseSource
from airbyte_cdk.sources.utils.catalog_helpers import CatalogHelper

from .singer_helpers import Catalogs, SingerHelper, SyncModeInfo


class ConfigContainer(Dict[str, Any]):
    config_path: str

    def __init__(self, config, config_path):
        super().__init__(config)
        self.config_path = config_path


class SingerSource(BaseSource[ConfigContainer, str, str]):
    def configure(self, config: Mapping[str, Any], temp_dir: str) -&gt; ConfigContainer:
        &#34;&#34;&#34;
        Persist raw_config in temporary directory to run the Source job
        This can be overridden if extra temporary files need to be persisted in the temp dir
        &#34;&#34;&#34;
        config_path = os.path.join(temp_dir, &#34;config.json&#34;)
        config = ConfigContainer(self.transform_config(config), config_path)
        self.write_config(config, config_path)
        return config

    # Can be overridden to change an input config
    def transform_config(self, config: Mapping[str, Any]) -&gt; Mapping[str, Any]:
        &#34;&#34;&#34;
        Singer source may need to adapt the Config object for the singer tap specifics
        &#34;&#34;&#34;
        return config

    def read_catalog(self, catalog_path: str) -&gt; str:
        &#34;&#34;&#34;
        Since singer source don&#39;t need actual catalog object, we override this to return path only
        &#34;&#34;&#34;
        return catalog_path

    def read_state(self, state_path: str) -&gt; str:
        &#34;&#34;&#34;
        Since singer source don&#39;t need actual state object, we override this to return path only
        &#34;&#34;&#34;
        return state_path

    def check_config(self, logger: logging.Logger, config_path: str, config: ConfigContainer) -&gt; AirbyteConnectionStatus:
        &#34;&#34;&#34;
        Some Singer source may perform check using config_path or config to
        tests if the input configuration can be used to successfully connect to the integration
        &#34;&#34;&#34;
        raise NotImplementedError

    def discover_cmd(self, logger: logging.Logger, config_path: str) -&gt; str:
        &#34;&#34;&#34;
        Returns the command used to run discovery in the singer tap. For example, if the bash command used to invoke the singer tap is `tap-postgres`,
        and the config JSON lived in &#34;/path/config.json&#34;, this method would return &#34;tap-postgres --config /path/config.json&#34;
        &#34;&#34;&#34;
        raise NotImplementedError

    def read_cmd(self, logger: logging.Logger, config_path: str, catalog_path: str, state_path: str = None) -&gt; str:
        &#34;&#34;&#34;
        Returns the command used to read data from the singer tap. For example, if the bash command used to invoke the singer tap is `tap-postgres`,
        and the config JSON lived in &#34;/path/config.json&#34;, and the catalog was in &#34;/path/catalog.json&#34;,
        this method would return &#34;tap-postgres --config /path/config.json --catalog /path/catalog.json&#34;
        &#34;&#34;&#34;
        raise NotImplementedError

    def _discover_internal(self, logger: logging.Logger, config_path: str) -&gt; Catalogs:
        cmd = self.discover_cmd(logger, config_path)
        catalogs = SingerHelper.get_catalogs(
            logger, cmd, self.get_sync_mode_overrides(), self.get_primary_key_overrides(), self.get_excluded_streams()
        )
        return catalogs

    def check(self, logger: logging.Logger, config: ConfigContainer) -&gt; AirbyteConnectionStatus:
        &#34;&#34;&#34;
        Tests if the input configuration can be used to successfully connect to the integration
        &#34;&#34;&#34;
        return self.check_config(logger, config.config_path, config)

    def discover(self, logger: logging.Logger, config: ConfigContainer) -&gt; AirbyteCatalog:
        &#34;&#34;&#34;
        Implements the parent class discover method.
        &#34;&#34;&#34;
        return self._discover_internal(logger, config.config_path).airbyte_catalog

    def read(self, logger: logging.Logger, config: ConfigContainer, catalog_path: str, state_path: str = None) -&gt; Iterable[AirbyteMessage]:
        &#34;&#34;&#34;
        Implements the parent class read method.
        &#34;&#34;&#34;
        catalogs = self._discover_internal(logger, config.config_path)
        masked_airbyte_catalog = ConfiguredAirbyteCatalog.parse_obj(self.read_config(catalog_path))
        selected_singer_catalog_path = SingerHelper.create_singer_catalog_with_selection(masked_airbyte_catalog, catalogs.singer_catalog)

        read_cmd = self.read_cmd(logger, config.config_path, selected_singer_catalog_path, state_path)
        return SingerHelper.read(logger, read_cmd)

    def get_sync_mode_overrides(self) -&gt; Dict[str, SyncModeInfo]:
        &#34;&#34;&#34;
        The Singer Spec outlines a way for taps to declare in their catalog that their streams support incremental sync (valid-replication-keys,
        forced-replication-method, and others). However, many taps which are incremental don&#39;t actually declare that via the catalog, and just
        use their input state to perform an incremental sync without giving any hints to the user. An Airbyte Connector built on top of such a
        Singer Tap cannot automatically detect which streams are full refresh or incremental or what their cursors are. In those cases the developer
        needs to manually specify information about the sync modes.

        This method provides a way of doing that: the dict of stream names to SyncModeInfo returned from this method will be used to override each
        stream&#39;s sync mode information in the Airbyte Catalog output from the discover method. Only set fields provided in the SyncModeInfo are used.
        If a SyncModeInfo field is not set, it will not be overridden in the output catalog.

        :return: A dict from stream name to the sync modes that should be applied to this stream.
        &#34;&#34;&#34;
        return {}

    def get_primary_key_overrides(self) -&gt; Dict[str, List[str]]:
        &#34;&#34;&#34;
        Similar to get_sync_mode_overrides but for primary keys.

        :return: A dict from stream name to the list of primary key fields for the stream.
        &#34;&#34;&#34;
        return {}

    def get_excluded_streams(self) -&gt; List[str]:
        &#34;&#34;&#34;
        This method provide ability to exclude some streams from catalog

        :return: A list of excluded stream names
        &#34;&#34;&#34;
        return []


class BaseSingerSource(SingerSource):
    force_full_refresh = False

    def check_config(self, logger: logging.Logger, config_path: str, config: Mapping[str, Any]) -&gt; AirbyteConnectionStatus:
        try:
            self.try_connect(logger, config)
        except self.api_error as err:
            logger.error(f&#34;Exception while connecting to {self.tap_name}: {err}&#34;)
            # this should be in UI
            error_msg = f&#34;Unable to connect to {self.tap_name} with the provided credentials. Error: {err}&#34;
            return AirbyteConnectionStatus(status=Status.FAILED, message=error_msg)
        return AirbyteConnectionStatus(status=Status.SUCCEEDED)

    def discover_cmd(self, logger: logging.Logger, config_path: str) -&gt; str:
        return f&#34;{self.tap_cmd} --config {config_path} --discover&#34;

    def read_cmd(self, logger: logging.Logger, config_path: str, catalog_path: str, state_path: str = None) -&gt; str:
        state_path = None if self.force_full_refresh else state_path
        args = {&#34;--config&#34;: config_path, &#34;--catalog&#34;: catalog_path, &#34;--state&#34;: state_path}
        cmd = &#34; &#34;.join([f&#34;{k} {v}&#34; for k, v in args.items() if v is not None])

        return f&#34;{self.tap_cmd} {cmd}&#34;

    def discover(self, logger: logging.Logger, config: ConfigContainer) -&gt; AirbyteCatalog:
        catalog = super().discover(logger, config)
        if self.force_full_refresh:
            return CatalogHelper.coerce_catalog_as_full_refresh(catalog)
        return catalog

    def try_connect(self, logger: logging.Logger, config: Mapping[str, Any]):
        &#34;&#34;&#34;Test provided credentials, raises self.api_error if something goes wrong&#34;&#34;&#34;
        raise NotImplementedError

    @property
    def api_error(self) -&gt; Type[Exception]:
        &#34;&#34;&#34;Class/Base class of the exception that will be thrown if the tap is misconfigured or service unavailable&#34;&#34;&#34;
        raise NotImplementedError

    @property
    def tap_cmd(self) -&gt; str:
        &#34;&#34;&#34;Tap command&#34;&#34;&#34;
        raise NotImplementedError

    @property
    def tap_name(self) -&gt; str:
        &#34;&#34;&#34;Tap name&#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="airbyte_cdk.sources.singer.source.BaseSingerSource"><code class="flex name class">
<span>class <span class="ident">BaseSingerSource</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseSingerSource(SingerSource):
    force_full_refresh = False

    def check_config(self, logger: logging.Logger, config_path: str, config: Mapping[str, Any]) -&gt; AirbyteConnectionStatus:
        try:
            self.try_connect(logger, config)
        except self.api_error as err:
            logger.error(f&#34;Exception while connecting to {self.tap_name}: {err}&#34;)
            # this should be in UI
            error_msg = f&#34;Unable to connect to {self.tap_name} with the provided credentials. Error: {err}&#34;
            return AirbyteConnectionStatus(status=Status.FAILED, message=error_msg)
        return AirbyteConnectionStatus(status=Status.SUCCEEDED)

    def discover_cmd(self, logger: logging.Logger, config_path: str) -&gt; str:
        return f&#34;{self.tap_cmd} --config {config_path} --discover&#34;

    def read_cmd(self, logger: logging.Logger, config_path: str, catalog_path: str, state_path: str = None) -&gt; str:
        state_path = None if self.force_full_refresh else state_path
        args = {&#34;--config&#34;: config_path, &#34;--catalog&#34;: catalog_path, &#34;--state&#34;: state_path}
        cmd = &#34; &#34;.join([f&#34;{k} {v}&#34; for k, v in args.items() if v is not None])

        return f&#34;{self.tap_cmd} {cmd}&#34;

    def discover(self, logger: logging.Logger, config: ConfigContainer) -&gt; AirbyteCatalog:
        catalog = super().discover(logger, config)
        if self.force_full_refresh:
            return CatalogHelper.coerce_catalog_as_full_refresh(catalog)
        return catalog

    def try_connect(self, logger: logging.Logger, config: Mapping[str, Any]):
        &#34;&#34;&#34;Test provided credentials, raises self.api_error if something goes wrong&#34;&#34;&#34;
        raise NotImplementedError

    @property
    def api_error(self) -&gt; Type[Exception]:
        &#34;&#34;&#34;Class/Base class of the exception that will be thrown if the tap is misconfigured or service unavailable&#34;&#34;&#34;
        raise NotImplementedError

    @property
    def tap_cmd(self) -&gt; str:
        &#34;&#34;&#34;Tap command&#34;&#34;&#34;
        raise NotImplementedError

    @property
    def tap_name(self) -&gt; str:
        &#34;&#34;&#34;Tap name&#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="airbyte_cdk.sources.singer.source.SingerSource" href="#airbyte_cdk.sources.singer.source.SingerSource">SingerSource</a></li>
<li><a title="airbyte_cdk.sources.source.BaseSource" href="../source.html#airbyte_cdk.sources.source.BaseSource">BaseSource</a></li>
<li><a title="airbyte_cdk.connector.BaseConnector" href="../../connector.html#airbyte_cdk.connector.BaseConnector">BaseConnector</a></li>
<li>abc.ABC</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="airbyte_cdk.sources.singer.source.BaseSingerSource.check_config_against_spec"><code class="name">var <span class="ident">check_config_against_spec</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="airbyte_cdk.sources.singer.source.BaseSingerSource.force_full_refresh"><code class="name">var <span class="ident">force_full_refresh</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="airbyte_cdk.sources.singer.source.BaseSingerSource.api_error"><code class="name">var <span class="ident">api_error</span> : Type[Exception]</code></dt>
<dd>
<div class="desc"><p>Class/Base class of the exception that will be thrown if the tap is misconfigured or service unavailable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def api_error(self) -&gt; Type[Exception]:
    &#34;&#34;&#34;Class/Base class of the exception that will be thrown if the tap is misconfigured or service unavailable&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.source.BaseSingerSource.tap_cmd"><code class="name">var <span class="ident">tap_cmd</span> : str</code></dt>
<dd>
<div class="desc"><p>Tap command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tap_cmd(self) -&gt; str:
    &#34;&#34;&#34;Tap command&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.source.BaseSingerSource.tap_name"><code class="name">var <span class="ident">tap_name</span> : str</code></dt>
<dd>
<div class="desc"><p>Tap name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tap_name(self) -&gt; str:
    &#34;&#34;&#34;Tap name&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="airbyte_cdk.sources.singer.source.BaseSingerSource.try_connect"><code class="name flex">
<span>def <span class="ident">try_connect</span></span>(<span>self, logger: logging.Logger, config: Mapping[str, Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Test provided credentials, raises self.api_error if something goes wrong</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_connect(self, logger: logging.Logger, config: Mapping[str, Any]):
    &#34;&#34;&#34;Test provided credentials, raises self.api_error if something goes wrong&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="airbyte_cdk.sources.singer.source.SingerSource" href="#airbyte_cdk.sources.singer.source.SingerSource">SingerSource</a></b></code>:
<ul class="hlist">
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.check" href="#airbyte_cdk.sources.singer.source.SingerSource.check">check</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.check_config" href="#airbyte_cdk.sources.singer.source.SingerSource.check_config">check_config</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.configure" href="#airbyte_cdk.sources.singer.source.SingerSource.configure">configure</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.discover" href="#airbyte_cdk.sources.singer.source.SingerSource.discover">discover</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.discover_cmd" href="#airbyte_cdk.sources.singer.source.SingerSource.discover_cmd">discover_cmd</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.get_excluded_streams" href="#airbyte_cdk.sources.singer.source.SingerSource.get_excluded_streams">get_excluded_streams</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.get_primary_key_overrides" href="#airbyte_cdk.sources.singer.source.SingerSource.get_primary_key_overrides">get_primary_key_overrides</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.get_sync_mode_overrides" href="#airbyte_cdk.sources.singer.source.SingerSource.get_sync_mode_overrides">get_sync_mode_overrides</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.read" href="#airbyte_cdk.sources.singer.source.SingerSource.read">read</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.read_catalog" href="#airbyte_cdk.sources.singer.source.SingerSource.read_catalog">read_catalog</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.read_cmd" href="#airbyte_cdk.sources.singer.source.SingerSource.read_cmd">read_cmd</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.read_state" href="#airbyte_cdk.sources.singer.source.SingerSource.read_state">read_state</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.spec" href="../../connector.html#airbyte_cdk.connector.BaseConnector.spec">spec</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.transform_config" href="#airbyte_cdk.sources.singer.source.SingerSource.transform_config">transform_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="airbyte_cdk.sources.singer.source.ConfigContainer"><code class="flex name class">
<span>class <span class="ident">ConfigContainer</span></span>
<span>(</span><span>config, config_path)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConfigContainer(Dict[str, Any]):
    config_path: str

    def __init__(self, config, config_path):
        super().__init__(config)
        self.config_path = config_path</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="airbyte_cdk.sources.singer.source.ConfigContainer.config_path"><code class="name">var <span class="ident">config_path</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="airbyte_cdk.sources.singer.source.SingerSource"><code class="flex name class">
<span>class <span class="ident">SingerSource</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SingerSource(BaseSource[ConfigContainer, str, str]):
    def configure(self, config: Mapping[str, Any], temp_dir: str) -&gt; ConfigContainer:
        &#34;&#34;&#34;
        Persist raw_config in temporary directory to run the Source job
        This can be overridden if extra temporary files need to be persisted in the temp dir
        &#34;&#34;&#34;
        config_path = os.path.join(temp_dir, &#34;config.json&#34;)
        config = ConfigContainer(self.transform_config(config), config_path)
        self.write_config(config, config_path)
        return config

    # Can be overridden to change an input config
    def transform_config(self, config: Mapping[str, Any]) -&gt; Mapping[str, Any]:
        &#34;&#34;&#34;
        Singer source may need to adapt the Config object for the singer tap specifics
        &#34;&#34;&#34;
        return config

    def read_catalog(self, catalog_path: str) -&gt; str:
        &#34;&#34;&#34;
        Since singer source don&#39;t need actual catalog object, we override this to return path only
        &#34;&#34;&#34;
        return catalog_path

    def read_state(self, state_path: str) -&gt; str:
        &#34;&#34;&#34;
        Since singer source don&#39;t need actual state object, we override this to return path only
        &#34;&#34;&#34;
        return state_path

    def check_config(self, logger: logging.Logger, config_path: str, config: ConfigContainer) -&gt; AirbyteConnectionStatus:
        &#34;&#34;&#34;
        Some Singer source may perform check using config_path or config to
        tests if the input configuration can be used to successfully connect to the integration
        &#34;&#34;&#34;
        raise NotImplementedError

    def discover_cmd(self, logger: logging.Logger, config_path: str) -&gt; str:
        &#34;&#34;&#34;
        Returns the command used to run discovery in the singer tap. For example, if the bash command used to invoke the singer tap is `tap-postgres`,
        and the config JSON lived in &#34;/path/config.json&#34;, this method would return &#34;tap-postgres --config /path/config.json&#34;
        &#34;&#34;&#34;
        raise NotImplementedError

    def read_cmd(self, logger: logging.Logger, config_path: str, catalog_path: str, state_path: str = None) -&gt; str:
        &#34;&#34;&#34;
        Returns the command used to read data from the singer tap. For example, if the bash command used to invoke the singer tap is `tap-postgres`,
        and the config JSON lived in &#34;/path/config.json&#34;, and the catalog was in &#34;/path/catalog.json&#34;,
        this method would return &#34;tap-postgres --config /path/config.json --catalog /path/catalog.json&#34;
        &#34;&#34;&#34;
        raise NotImplementedError

    def _discover_internal(self, logger: logging.Logger, config_path: str) -&gt; Catalogs:
        cmd = self.discover_cmd(logger, config_path)
        catalogs = SingerHelper.get_catalogs(
            logger, cmd, self.get_sync_mode_overrides(), self.get_primary_key_overrides(), self.get_excluded_streams()
        )
        return catalogs

    def check(self, logger: logging.Logger, config: ConfigContainer) -&gt; AirbyteConnectionStatus:
        &#34;&#34;&#34;
        Tests if the input configuration can be used to successfully connect to the integration
        &#34;&#34;&#34;
        return self.check_config(logger, config.config_path, config)

    def discover(self, logger: logging.Logger, config: ConfigContainer) -&gt; AirbyteCatalog:
        &#34;&#34;&#34;
        Implements the parent class discover method.
        &#34;&#34;&#34;
        return self._discover_internal(logger, config.config_path).airbyte_catalog

    def read(self, logger: logging.Logger, config: ConfigContainer, catalog_path: str, state_path: str = None) -&gt; Iterable[AirbyteMessage]:
        &#34;&#34;&#34;
        Implements the parent class read method.
        &#34;&#34;&#34;
        catalogs = self._discover_internal(logger, config.config_path)
        masked_airbyte_catalog = ConfiguredAirbyteCatalog.parse_obj(self.read_config(catalog_path))
        selected_singer_catalog_path = SingerHelper.create_singer_catalog_with_selection(masked_airbyte_catalog, catalogs.singer_catalog)

        read_cmd = self.read_cmd(logger, config.config_path, selected_singer_catalog_path, state_path)
        return SingerHelper.read(logger, read_cmd)

    def get_sync_mode_overrides(self) -&gt; Dict[str, SyncModeInfo]:
        &#34;&#34;&#34;
        The Singer Spec outlines a way for taps to declare in their catalog that their streams support incremental sync (valid-replication-keys,
        forced-replication-method, and others). However, many taps which are incremental don&#39;t actually declare that via the catalog, and just
        use their input state to perform an incremental sync without giving any hints to the user. An Airbyte Connector built on top of such a
        Singer Tap cannot automatically detect which streams are full refresh or incremental or what their cursors are. In those cases the developer
        needs to manually specify information about the sync modes.

        This method provides a way of doing that: the dict of stream names to SyncModeInfo returned from this method will be used to override each
        stream&#39;s sync mode information in the Airbyte Catalog output from the discover method. Only set fields provided in the SyncModeInfo are used.
        If a SyncModeInfo field is not set, it will not be overridden in the output catalog.

        :return: A dict from stream name to the sync modes that should be applied to this stream.
        &#34;&#34;&#34;
        return {}

    def get_primary_key_overrides(self) -&gt; Dict[str, List[str]]:
        &#34;&#34;&#34;
        Similar to get_sync_mode_overrides but for primary keys.

        :return: A dict from stream name to the list of primary key fields for the stream.
        &#34;&#34;&#34;
        return {}

    def get_excluded_streams(self) -&gt; List[str]:
        &#34;&#34;&#34;
        This method provide ability to exclude some streams from catalog

        :return: A list of excluded stream names
        &#34;&#34;&#34;
        return []</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="airbyte_cdk.sources.source.BaseSource" href="../source.html#airbyte_cdk.sources.source.BaseSource">BaseSource</a></li>
<li><a title="airbyte_cdk.connector.BaseConnector" href="../../connector.html#airbyte_cdk.connector.BaseConnector">BaseConnector</a></li>
<li>abc.ABC</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="airbyte_cdk.sources.singer.source.BaseSingerSource" href="#airbyte_cdk.sources.singer.source.BaseSingerSource">BaseSingerSource</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="airbyte_cdk.sources.singer.source.SingerSource.check_config_against_spec"><code class="name">var <span class="ident">check_config_against_spec</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="airbyte_cdk.sources.singer.source.SingerSource.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, logger: logging.Logger, config: <a title="airbyte_cdk.sources.singer.source.ConfigContainer" href="#airbyte_cdk.sources.singer.source.ConfigContainer">ConfigContainer</a>) ‑> <a title="airbyte_cdk.models.airbyte_protocol.AirbyteConnectionStatus" href="../../models/airbyte_protocol.html#airbyte_cdk.models.airbyte_protocol.AirbyteConnectionStatus">AirbyteConnectionStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Tests if the input configuration can be used to successfully connect to the integration</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check(self, logger: logging.Logger, config: ConfigContainer) -&gt; AirbyteConnectionStatus:
    &#34;&#34;&#34;
    Tests if the input configuration can be used to successfully connect to the integration
    &#34;&#34;&#34;
    return self.check_config(logger, config.config_path, config)</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.source.SingerSource.check_config"><code class="name flex">
<span>def <span class="ident">check_config</span></span>(<span>self, logger: logging.Logger, config_path: str, config: <a title="airbyte_cdk.sources.singer.source.ConfigContainer" href="#airbyte_cdk.sources.singer.source.ConfigContainer">ConfigContainer</a>) ‑> <a title="airbyte_cdk.models.airbyte_protocol.AirbyteConnectionStatus" href="../../models/airbyte_protocol.html#airbyte_cdk.models.airbyte_protocol.AirbyteConnectionStatus">AirbyteConnectionStatus</a></span>
</code></dt>
<dd>
<div class="desc"><p>Some Singer source may perform check using config_path or config to
tests if the input configuration can be used to successfully connect to the integration</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_config(self, logger: logging.Logger, config_path: str, config: ConfigContainer) -&gt; AirbyteConnectionStatus:
    &#34;&#34;&#34;
    Some Singer source may perform check using config_path or config to
    tests if the input configuration can be used to successfully connect to the integration
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.source.SingerSource.configure"><code class="name flex">
<span>def <span class="ident">configure</span></span>(<span>self, config: Mapping[str, Any], temp_dir: str) ‑> <a title="airbyte_cdk.sources.singer.source.ConfigContainer" href="#airbyte_cdk.sources.singer.source.ConfigContainer">ConfigContainer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Persist raw_config in temporary directory to run the Source job
This can be overridden if extra temporary files need to be persisted in the temp dir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure(self, config: Mapping[str, Any], temp_dir: str) -&gt; ConfigContainer:
    &#34;&#34;&#34;
    Persist raw_config in temporary directory to run the Source job
    This can be overridden if extra temporary files need to be persisted in the temp dir
    &#34;&#34;&#34;
    config_path = os.path.join(temp_dir, &#34;config.json&#34;)
    config = ConfigContainer(self.transform_config(config), config_path)
    self.write_config(config, config_path)
    return config</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.source.SingerSource.discover"><code class="name flex">
<span>def <span class="ident">discover</span></span>(<span>self, logger: logging.Logger, config: <a title="airbyte_cdk.sources.singer.source.ConfigContainer" href="#airbyte_cdk.sources.singer.source.ConfigContainer">ConfigContainer</a>) ‑> <a title="airbyte_cdk.models.airbyte_protocol.AirbyteCatalog" href="../../models/airbyte_protocol.html#airbyte_cdk.models.airbyte_protocol.AirbyteCatalog">AirbyteCatalog</a></span>
</code></dt>
<dd>
<div class="desc"><p>Implements the parent class discover method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discover(self, logger: logging.Logger, config: ConfigContainer) -&gt; AirbyteCatalog:
    &#34;&#34;&#34;
    Implements the parent class discover method.
    &#34;&#34;&#34;
    return self._discover_internal(logger, config.config_path).airbyte_catalog</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.source.SingerSource.discover_cmd"><code class="name flex">
<span>def <span class="ident">discover_cmd</span></span>(<span>self, logger: logging.Logger, config_path: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the command used to run discovery in the singer tap. For example, if the bash command used to invoke the singer tap is <code>tap-postgres</code>,
and the config JSON lived in "/path/config.json", this method would return "tap-postgres &ndash;config /path/config.json"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discover_cmd(self, logger: logging.Logger, config_path: str) -&gt; str:
    &#34;&#34;&#34;
    Returns the command used to run discovery in the singer tap. For example, if the bash command used to invoke the singer tap is `tap-postgres`,
    and the config JSON lived in &#34;/path/config.json&#34;, this method would return &#34;tap-postgres --config /path/config.json&#34;
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.source.SingerSource.get_excluded_streams"><code class="name flex">
<span>def <span class="ident">get_excluded_streams</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>This method provide ability to exclude some streams from catalog</p>
<p>:return: A list of excluded stream names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_excluded_streams(self) -&gt; List[str]:
    &#34;&#34;&#34;
    This method provide ability to exclude some streams from catalog

    :return: A list of excluded stream names
    &#34;&#34;&#34;
    return []</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.source.SingerSource.get_primary_key_overrides"><code class="name flex">
<span>def <span class="ident">get_primary_key_overrides</span></span>(<span>self) ‑> Dict[str, List[str]]</span>
</code></dt>
<dd>
<div class="desc"><p>Similar to get_sync_mode_overrides but for primary keys.</p>
<p>:return: A dict from stream name to the list of primary key fields for the stream.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_primary_key_overrides(self) -&gt; Dict[str, List[str]]:
    &#34;&#34;&#34;
    Similar to get_sync_mode_overrides but for primary keys.

    :return: A dict from stream name to the list of primary key fields for the stream.
    &#34;&#34;&#34;
    return {}</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.source.SingerSource.get_sync_mode_overrides"><code class="name flex">
<span>def <span class="ident">get_sync_mode_overrides</span></span>(<span>self) ‑> Dict[str, <a title="airbyte_cdk.sources.singer.singer_helpers.SyncModeInfo" href="singer_helpers.html#airbyte_cdk.sources.singer.singer_helpers.SyncModeInfo">SyncModeInfo</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>The Singer Spec outlines a way for taps to declare in their catalog that their streams support incremental sync (valid-replication-keys,
forced-replication-method, and others). However, many taps which are incremental don't actually declare that via the catalog, and just
use their input state to perform an incremental sync without giving any hints to the user. An Airbyte Connector built on top of such a
Singer Tap cannot automatically detect which streams are full refresh or incremental or what their cursors are. In those cases the developer
needs to manually specify information about the sync modes.</p>
<p>This method provides a way of doing that: the dict of stream names to SyncModeInfo returned from this method will be used to override each
stream's sync mode information in the Airbyte Catalog output from the discover method. Only set fields provided in the SyncModeInfo are used.
If a SyncModeInfo field is not set, it will not be overridden in the output catalog.</p>
<p>:return: A dict from stream name to the sync modes that should be applied to this stream.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sync_mode_overrides(self) -&gt; Dict[str, SyncModeInfo]:
    &#34;&#34;&#34;
    The Singer Spec outlines a way for taps to declare in their catalog that their streams support incremental sync (valid-replication-keys,
    forced-replication-method, and others). However, many taps which are incremental don&#39;t actually declare that via the catalog, and just
    use their input state to perform an incremental sync without giving any hints to the user. An Airbyte Connector built on top of such a
    Singer Tap cannot automatically detect which streams are full refresh or incremental or what their cursors are. In those cases the developer
    needs to manually specify information about the sync modes.

    This method provides a way of doing that: the dict of stream names to SyncModeInfo returned from this method will be used to override each
    stream&#39;s sync mode information in the Airbyte Catalog output from the discover method. Only set fields provided in the SyncModeInfo are used.
    If a SyncModeInfo field is not set, it will not be overridden in the output catalog.

    :return: A dict from stream name to the sync modes that should be applied to this stream.
    &#34;&#34;&#34;
    return {}</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.source.SingerSource.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, logger: logging.Logger, config: <a title="airbyte_cdk.sources.singer.source.ConfigContainer" href="#airbyte_cdk.sources.singer.source.ConfigContainer">ConfigContainer</a>, catalog_path: str, state_path: str = None) ‑> Iterable[<a title="airbyte_cdk.models.airbyte_protocol.AirbyteMessage" href="../../models/airbyte_protocol.html#airbyte_cdk.models.airbyte_protocol.AirbyteMessage">AirbyteMessage</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the parent class read method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, logger: logging.Logger, config: ConfigContainer, catalog_path: str, state_path: str = None) -&gt; Iterable[AirbyteMessage]:
    &#34;&#34;&#34;
    Implements the parent class read method.
    &#34;&#34;&#34;
    catalogs = self._discover_internal(logger, config.config_path)
    masked_airbyte_catalog = ConfiguredAirbyteCatalog.parse_obj(self.read_config(catalog_path))
    selected_singer_catalog_path = SingerHelper.create_singer_catalog_with_selection(masked_airbyte_catalog, catalogs.singer_catalog)

    read_cmd = self.read_cmd(logger, config.config_path, selected_singer_catalog_path, state_path)
    return SingerHelper.read(logger, read_cmd)</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.source.SingerSource.read_catalog"><code class="name flex">
<span>def <span class="ident">read_catalog</span></span>(<span>self, catalog_path: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Since singer source don't need actual catalog object, we override this to return path only</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_catalog(self, catalog_path: str) -&gt; str:
    &#34;&#34;&#34;
    Since singer source don&#39;t need actual catalog object, we override this to return path only
    &#34;&#34;&#34;
    return catalog_path</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.source.SingerSource.read_cmd"><code class="name flex">
<span>def <span class="ident">read_cmd</span></span>(<span>self, logger: logging.Logger, config_path: str, catalog_path: str, state_path: str = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the command used to read data from the singer tap. For example, if the bash command used to invoke the singer tap is <code>tap-postgres</code>,
and the config JSON lived in "/path/config.json", and the catalog was in "/path/catalog.json",
this method would return "tap-postgres &ndash;config /path/config.json &ndash;catalog /path/catalog.json"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_cmd(self, logger: logging.Logger, config_path: str, catalog_path: str, state_path: str = None) -&gt; str:
    &#34;&#34;&#34;
    Returns the command used to read data from the singer tap. For example, if the bash command used to invoke the singer tap is `tap-postgres`,
    and the config JSON lived in &#34;/path/config.json&#34;, and the catalog was in &#34;/path/catalog.json&#34;,
    this method would return &#34;tap-postgres --config /path/config.json --catalog /path/catalog.json&#34;
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.source.SingerSource.read_state"><code class="name flex">
<span>def <span class="ident">read_state</span></span>(<span>self, state_path: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Since singer source don't need actual state object, we override this to return path only</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_state(self, state_path: str) -&gt; str:
    &#34;&#34;&#34;
    Since singer source don&#39;t need actual state object, we override this to return path only
    &#34;&#34;&#34;
    return state_path</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.singer.source.SingerSource.transform_config"><code class="name flex">
<span>def <span class="ident">transform_config</span></span>(<span>self, config: Mapping[str, Any]) ‑> Mapping[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Singer source may need to adapt the Config object for the singer tap specifics</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_config(self, config: Mapping[str, Any]) -&gt; Mapping[str, Any]:
    &#34;&#34;&#34;
    Singer source may need to adapt the Config object for the singer tap specifics
    &#34;&#34;&#34;
    return config</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="airbyte_cdk.sources.source.BaseSource" href="../source.html#airbyte_cdk.sources.source.BaseSource">BaseSource</a></b></code>:
<ul class="hlist">
<li><code><a title="airbyte_cdk.sources.source.BaseSource.spec" href="../../connector.html#airbyte_cdk.connector.BaseConnector.spec">spec</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="airbyte_cdk.sources.singer" href="index.html">airbyte_cdk.sources.singer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="airbyte_cdk.sources.singer.source.BaseSingerSource" href="#airbyte_cdk.sources.singer.source.BaseSingerSource">BaseSingerSource</a></code></h4>
<ul class="">
<li><code><a title="airbyte_cdk.sources.singer.source.BaseSingerSource.api_error" href="#airbyte_cdk.sources.singer.source.BaseSingerSource.api_error">api_error</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.BaseSingerSource.check_config_against_spec" href="#airbyte_cdk.sources.singer.source.BaseSingerSource.check_config_against_spec">check_config_against_spec</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.BaseSingerSource.force_full_refresh" href="#airbyte_cdk.sources.singer.source.BaseSingerSource.force_full_refresh">force_full_refresh</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.BaseSingerSource.tap_cmd" href="#airbyte_cdk.sources.singer.source.BaseSingerSource.tap_cmd">tap_cmd</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.BaseSingerSource.tap_name" href="#airbyte_cdk.sources.singer.source.BaseSingerSource.tap_name">tap_name</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.BaseSingerSource.try_connect" href="#airbyte_cdk.sources.singer.source.BaseSingerSource.try_connect">try_connect</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="airbyte_cdk.sources.singer.source.ConfigContainer" href="#airbyte_cdk.sources.singer.source.ConfigContainer">ConfigContainer</a></code></h4>
<ul class="">
<li><code><a title="airbyte_cdk.sources.singer.source.ConfigContainer.config_path" href="#airbyte_cdk.sources.singer.source.ConfigContainer.config_path">config_path</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="airbyte_cdk.sources.singer.source.SingerSource" href="#airbyte_cdk.sources.singer.source.SingerSource">SingerSource</a></code></h4>
<ul class="">
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.check" href="#airbyte_cdk.sources.singer.source.SingerSource.check">check</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.check_config" href="#airbyte_cdk.sources.singer.source.SingerSource.check_config">check_config</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.check_config_against_spec" href="#airbyte_cdk.sources.singer.source.SingerSource.check_config_against_spec">check_config_against_spec</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.configure" href="#airbyte_cdk.sources.singer.source.SingerSource.configure">configure</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.discover" href="#airbyte_cdk.sources.singer.source.SingerSource.discover">discover</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.discover_cmd" href="#airbyte_cdk.sources.singer.source.SingerSource.discover_cmd">discover_cmd</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.get_excluded_streams" href="#airbyte_cdk.sources.singer.source.SingerSource.get_excluded_streams">get_excluded_streams</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.get_primary_key_overrides" href="#airbyte_cdk.sources.singer.source.SingerSource.get_primary_key_overrides">get_primary_key_overrides</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.get_sync_mode_overrides" href="#airbyte_cdk.sources.singer.source.SingerSource.get_sync_mode_overrides">get_sync_mode_overrides</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.read" href="#airbyte_cdk.sources.singer.source.SingerSource.read">read</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.read_catalog" href="#airbyte_cdk.sources.singer.source.SingerSource.read_catalog">read_catalog</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.read_cmd" href="#airbyte_cdk.sources.singer.source.SingerSource.read_cmd">read_cmd</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.read_state" href="#airbyte_cdk.sources.singer.source.SingerSource.read_state">read_state</a></code></li>
<li><code><a title="airbyte_cdk.sources.singer.source.SingerSource.transform_config" href="#airbyte_cdk.sources.singer.source.SingerSource.transform_config">transform_config</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>