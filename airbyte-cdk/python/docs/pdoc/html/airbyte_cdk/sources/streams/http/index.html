<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>airbyte_cdk.sources.streams.http API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>airbyte_cdk.sources.streams.http</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# Copyright (c) 2021 Airbyte, Inc., all rights reserved.
#

# Initialize Streams Package
from .exceptions import UserDefinedBackoffException
from .http import HttpStream, HttpSubStream

__all__ = [&#34;HttpStream&#34;, &#34;HttpSubStream&#34;, &#34;UserDefinedBackoffException&#34;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="airbyte_cdk.sources.streams.http.auth" href="auth/index.html">airbyte_cdk.sources.streams.http.auth</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="airbyte_cdk.sources.streams.http.exceptions" href="exceptions.html">airbyte_cdk.sources.streams.http.exceptions</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="airbyte_cdk.sources.streams.http.http" href="http.html">airbyte_cdk.sources.streams.http.http</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="airbyte_cdk.sources.streams.http.rate_limiting" href="rate_limiting.html">airbyte_cdk.sources.streams.http.rate_limiting</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="airbyte_cdk.sources.streams.http.requests_native_auth" href="requests_native_auth/index.html">airbyte_cdk.sources.streams.http.requests_native_auth</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="airbyte_cdk.sources.streams.http.HttpStream"><code class="flex name class">
<span>class <span class="ident">HttpStream</span></span>
<span>(</span><span>authenticator: Union[requests.auth.AuthBase, <a title="airbyte_cdk.sources.streams.http.auth.core.HttpAuthenticator" href="auth/core.html#airbyte_cdk.sources.streams.http.auth.core.HttpAuthenticator">HttpAuthenticator</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base abstract class for an Airbyte Stream using the HTTP protocol. Basic building block for users building an Airbyte source for a HTTP API.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HttpStream(Stream, ABC):
    &#34;&#34;&#34;
    Base abstract class for an Airbyte Stream using the HTTP protocol. Basic building block for users building an Airbyte source for a HTTP API.
    &#34;&#34;&#34;

    source_defined_cursor = True  # Most HTTP streams use a source defined cursor (i.e: the user can&#39;t configure it like on a SQL table)
    page_size: Optional[int] = None  # Use this variable to define page size for API http requests with pagination support

    # TODO: remove legacy HttpAuthenticator authenticator references
    def __init__(self, authenticator: Union[AuthBase, HttpAuthenticator] = None):
        self._session = requests.Session()

        self._authenticator: HttpAuthenticator = NoAuth()
        if isinstance(authenticator, AuthBase):
            self._session.auth = authenticator
        elif authenticator:
            self._authenticator = authenticator

        if self.use_cache:
            self.cache_file = self.request_cache()
            # we need this attr to get metadata about cassettes, such as record play count, all records played, etc.
            self.cassete = None

    @property
    def cache_filename(self):
        &#34;&#34;&#34;
        Override if needed. Return the name of cache file
        &#34;&#34;&#34;
        return f&#34;{self.name}.yml&#34;

    @property
    def use_cache(self):
        &#34;&#34;&#34;
        Override if needed. If True, all records will be cached.
        &#34;&#34;&#34;
        return False

    def request_cache(self) -&gt; Cassette:
        &#34;&#34;&#34;
        Builds VCR instance.
        It deletes file everytime we create it, normally should be called only once.
        We can&#39;t use NamedTemporaryFile here because yaml serializer doesn&#39;t work well with empty files.
        &#34;&#34;&#34;

        try:
            os.remove(self.cache_filename)
        except FileNotFoundError:
            pass

        return vcr.use_cassette(self.cache_filename, record_mode=&#34;new_episodes&#34;, serializer=&#34;yaml&#34;)

    @property
    @abstractmethod
    def url_base(self) -&gt; str:
        &#34;&#34;&#34;
        :return: URL base for the  API endpoint e.g: if you wanted to hit https://myapi.com/v1/some_entity then this should return &#34;https://myapi.com/v1/&#34;
        &#34;&#34;&#34;

    @property
    def http_method(self) -&gt; str:
        &#34;&#34;&#34;
        Override if needed. See get_request_data/get_request_json if using POST/PUT/PATCH.
        &#34;&#34;&#34;
        return &#34;GET&#34;

    @property
    def raise_on_http_errors(self) -&gt; bool:
        &#34;&#34;&#34;
        Override if needed. If set to False, allows opting-out of raising HTTP code exception.
        &#34;&#34;&#34;
        return True

    @property
    def max_retries(self) -&gt; Union[int, None]:
        &#34;&#34;&#34;
        Override if needed. Specifies maximum amount of retries for backoff policy. Return None for no limit.
        &#34;&#34;&#34;
        return 5

    @property
    def retry_factor(self) -&gt; float:
        &#34;&#34;&#34;
        Override if needed. Specifies factor for backoff policy.
        &#34;&#34;&#34;
        return 5

    @property
    def authenticator(self) -&gt; HttpAuthenticator:
        return self._authenticator

    @abstractmethod
    def next_page_token(self, response: requests.Response) -&gt; Optional[Mapping[str, Any]]:
        &#34;&#34;&#34;
        Override this method to define a pagination strategy.

        The value returned from this method is passed to most other methods in this class. Use it to form a request e.g: set headers or query params.

        :return: The token for the next page from the input response object. Returning None means there are no more pages to read in this response.
        &#34;&#34;&#34;

    @abstractmethod
    def path(
        self,
        *,
        stream_state: Mapping[str, Any] = None,
        stream_slice: Mapping[str, Any] = None,
        next_page_token: Mapping[str, Any] = None,
    ) -&gt; str:
        &#34;&#34;&#34;
        Returns the URL path for the API endpoint e.g: if you wanted to hit https://myapi.com/v1/some_entity then this should return &#34;some_entity&#34;
        &#34;&#34;&#34;

    def request_params(
        self,
        stream_state: Mapping[str, Any],
        stream_slice: Mapping[str, Any] = None,
        next_page_token: Mapping[str, Any] = None,
    ) -&gt; MutableMapping[str, Any]:
        &#34;&#34;&#34;
        Override this method to define the query parameters that should be set on an outgoing HTTP request given the inputs.

        E.g: you might want to define query parameters for paging if next_page_token is not None.
        &#34;&#34;&#34;
        return {}

    def request_headers(
        self, stream_state: Mapping[str, Any], stream_slice: Mapping[str, Any] = None, next_page_token: Mapping[str, Any] = None
    ) -&gt; Mapping[str, Any]:
        &#34;&#34;&#34;
        Override to return any non-auth headers. Authentication headers will overwrite any overlapping headers returned from this method.
        &#34;&#34;&#34;
        return {}

    def request_body_data(
        self,
        stream_state: Mapping[str, Any],
        stream_slice: Mapping[str, Any] = None,
        next_page_token: Mapping[str, Any] = None,
    ) -&gt; Optional[Union[Mapping, str]]:
        &#34;&#34;&#34;
        Override when creating POST/PUT/PATCH requests to populate the body of the request with a non-JSON payload.

        If returns a ready text that it will be sent as is.
        If returns a dict that it will be converted to a urlencoded form.
        E.g. {&#34;key1&#34;: &#34;value1&#34;, &#34;key2&#34;: &#34;value2&#34;} =&gt; &#34;key1=value1&amp;key2=value2&#34;

        At the same time only one of the &#39;request_body_data&#39; and &#39;request_body_json&#39; functions can be overridden.
        &#34;&#34;&#34;
        return None

    def request_body_json(
        self,
        stream_state: Mapping[str, Any],
        stream_slice: Mapping[str, Any] = None,
        next_page_token: Mapping[str, Any] = None,
    ) -&gt; Optional[Mapping]:
        &#34;&#34;&#34;
        Override when creating POST/PUT/PATCH requests to populate the body of the request with a JSON payload.

        At the same time only one of the &#39;request_body_data&#39; and &#39;request_body_json&#39; functions can be overridden.
        &#34;&#34;&#34;
        return None

    def request_kwargs(
        self,
        stream_state: Mapping[str, Any],
        stream_slice: Mapping[str, Any] = None,
        next_page_token: Mapping[str, Any] = None,
    ) -&gt; Mapping[str, Any]:
        &#34;&#34;&#34;
        Override to return a mapping of keyword arguments to be used when creating the HTTP request.
        Any option listed in https://docs.python-requests.org/en/latest/api/#requests.adapters.BaseAdapter.send for can be returned from
        this method. Note that these options do not conflict with request-level options such as headers, request params, etc..
        &#34;&#34;&#34;
        return {}

    @abstractmethod
    def parse_response(
        self,
        response: requests.Response,
        *,
        stream_state: Mapping[str, Any],
        stream_slice: Mapping[str, Any] = None,
        next_page_token: Mapping[str, Any] = None,
    ) -&gt; Iterable[Mapping]:
        &#34;&#34;&#34;
        Parses the raw response object into a list of records.
        By default, this returns an iterable containing the input. Override to parse differently.
        :param response:
        :param stream_state:
        :param stream_slice:
        :param next_page_token:
        :return: An iterable containing the parsed response
        &#34;&#34;&#34;

    # TODO move all the retry logic to a functor/decorator which is input as an init parameter
    def should_retry(self, response: requests.Response) -&gt; bool:
        &#34;&#34;&#34;
        Override to set different conditions for backoff based on the response from the server.

        By default, back off on the following HTTP response statuses:
         - 429 (Too Many Requests) indicating rate limiting
         - 500s to handle transient server errors

        Unexpected but transient exceptions (connection timeout, DNS resolution failed, etc..) are retried by default.
        &#34;&#34;&#34;
        return response.status_code == 429 or 500 &lt;= response.status_code &lt; 600

    def backoff_time(self, response: requests.Response) -&gt; Optional[float]:
        &#34;&#34;&#34;
        Override this method to dynamically determine backoff time e.g: by reading the X-Retry-After header.

        This method is called only if should_backoff() returns True for the input request.

        :param response:
        :return how long to backoff in seconds. The return value may be a floating point number for subsecond precision. Returning None defers backoff
        to the default backoff behavior (e.g using an exponential algorithm).
        &#34;&#34;&#34;
        return None

    def _create_prepared_request(
        self,
        path: str,
        headers: Mapping = None,
        params: Mapping = None,
        json: Any = None,
        data: Any = None,
    ) -&gt; requests.PreparedRequest:
        args = {&#34;method&#34;: self.http_method, &#34;url&#34;: urljoin(self.url_base, path), &#34;headers&#34;: headers, &#34;params&#34;: params}
        if self.http_method.upper() in BODY_REQUEST_METHODS:
            if json and data:
                raise RequestBodyException(
                    &#34;At the same time only one of the &#39;request_body_data&#39; and &#39;request_body_json&#39; functions can return data&#34;
                )
            elif json:
                args[&#34;json&#34;] = json
            elif data:
                args[&#34;data&#34;] = data

        return self._session.prepare_request(requests.Request(**args))

    def _send(self, request: requests.PreparedRequest, request_kwargs: Mapping[str, Any]) -&gt; requests.Response:
        &#34;&#34;&#34;
        Wraps sending the request in rate limit and error handlers.
        Please note that error handling for HTTP status codes will be ignored if raise_on_http_errors is set to False

        This method handles two types of exceptions:
            1. Expected transient exceptions e.g: 429 status code.
            2. Unexpected transient exceptions e.g: timeout.

        To trigger a backoff, we raise an exception that is handled by the backoff decorator. If an exception is not handled by the decorator will
        fail the sync.

        For expected transient exceptions, backoff time is determined by the type of exception raised:
            1. CustomBackoffException uses the user-provided backoff value
            2. DefaultBackoffException falls back on the decorator&#39;s default behavior e.g: exponential backoff

        Unexpected transient exceptions use the default backoff parameters.
        Unexpected persistent exceptions are not handled and will cause the sync to fail.
        &#34;&#34;&#34;
        response: requests.Response = self._session.send(request, **request_kwargs)

        if self.should_retry(response):
            custom_backoff_time = self.backoff_time(response)
            if custom_backoff_time:
                raise UserDefinedBackoffException(backoff=custom_backoff_time, request=request, response=response)
            else:
                raise DefaultBackoffException(request=request, response=response)
        elif self.raise_on_http_errors:
            # Raise any HTTP exceptions that happened in case there were unexpected ones
            try:
                response.raise_for_status()
            except requests.HTTPError as exc:
                self.logger.error(response.text)
                raise exc
        return response

    def _send_request(self, request: requests.PreparedRequest, request_kwargs: Mapping[str, Any]) -&gt; requests.Response:
        &#34;&#34;&#34;
        Creates backoff wrappers which are responsible for retry logic
        &#34;&#34;&#34;

        &#34;&#34;&#34;
        Backoff package has max_tries parameter that means total number of
        tries before giving up, so if this number is 0 no calls expected to be done.
        But for this class we call it max_REtries assuming there would be at
        least one attempt and some retry attempts, to comply this logic we add
        1 to expected retries attempts.
        &#34;&#34;&#34;
        max_tries = self.max_retries
        &#34;&#34;&#34;
        According to backoff max_tries docstring:
            max_tries: The maximum number of attempts to make before giving
                up ...The default value of None means there is no limit to
                the number of tries.
        This implies that if max_tries is explicitly set to None there is no
        limit to retry attempts, otherwise it is limited number of tries. But
        this is not true for current version of backoff packages (1.8.0). Setting
        max_tries to 0 or negative number would result in endless retry attempts.
        Add this condition to avoid an endless loop if it hasn&#39;t been set
        explicitly (i.e. max_retries is not None).
        &#34;&#34;&#34;
        if max_tries is not None:
            max_tries = max(0, max_tries) + 1

        user_backoff_handler = user_defined_backoff_handler(max_tries=max_tries)(self._send)
        backoff_handler = default_backoff_handler(max_tries=max_tries, factor=self.retry_factor)
        return backoff_handler(user_backoff_handler)(request, request_kwargs)

    def parse_response_error_message(self, response: requests.Response) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Parses the raw response object from a failed request into a user-friendly error message.
        By default, this method tries to grab the error message from JSON responses by following common API patterns. Override to parse differently.

        :param response:
        :return: A user-friendly message that indicates the cause of the error
        &#34;&#34;&#34;

        # default logic to grab error from common fields
        def _try_get_error(value):
            if isinstance(value, str):
                return value
            elif isinstance(value, list):
                return &#34;, &#34;.join(_try_get_error(v) for v in value)
            elif isinstance(value, dict):
                new_value = (
                    value.get(&#34;message&#34;)
                    or value.get(&#34;messages&#34;)
                    or value.get(&#34;error&#34;)
                    or value.get(&#34;errors&#34;)
                    or value.get(&#34;failures&#34;)
                    or value.get(&#34;failure&#34;)
                )
                return _try_get_error(new_value)
            return None

        try:
            body = response.json()
            return _try_get_error(body)
        except requests.exceptions.JSONDecodeError:
            return None

    def get_error_display_message(self, exception: BaseException) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Retrieves the user-friendly display message that corresponds to an exception.
        This will be called when encountering an exception while reading records from the stream, and used to build the AirbyteTraceMessage.

        The default implementation of this method only handles HTTPErrors by passing the response to self.parse_response_error_message().
        The method should be overriden as needed to handle any additional exception types.

        :param exception: The exception that was raised
        :return: A user-friendly message that indicates the cause of the error
        &#34;&#34;&#34;
        if isinstance(exception, requests.HTTPError):
            return self.parse_response_error_message(exception.response)
        return None

    def read_records(
        self,
        sync_mode: SyncMode,
        cursor_field: List[str] = None,
        stream_slice: Mapping[str, Any] = None,
        stream_state: Mapping[str, Any] = None,
    ) -&gt; Iterable[Mapping[str, Any]]:
        stream_state = stream_state or {}
        pagination_complete = False

        next_page_token = None
        while not pagination_complete:
            request_headers = self.request_headers(stream_state=stream_state, stream_slice=stream_slice, next_page_token=next_page_token)
            request = self._create_prepared_request(
                path=self.path(stream_state=stream_state, stream_slice=stream_slice, next_page_token=next_page_token),
                headers=dict(request_headers, **self.authenticator.get_auth_header()),
                params=self.request_params(stream_state=stream_state, stream_slice=stream_slice, next_page_token=next_page_token),
                json=self.request_body_json(stream_state=stream_state, stream_slice=stream_slice, next_page_token=next_page_token),
                data=self.request_body_data(stream_state=stream_state, stream_slice=stream_slice, next_page_token=next_page_token),
            )
            request_kwargs = self.request_kwargs(stream_state=stream_state, stream_slice=stream_slice, next_page_token=next_page_token)

            if self.use_cache:
                # use context manager to handle and store cassette metadata
                with self.cache_file as cass:
                    self.cassete = cass
                    # vcr tries to find records based on the request, if such records exist, return from cache file
                    # else make a request and save record in cache file
                    response = self._send_request(request, request_kwargs)

            else:
                response = self._send_request(request, request_kwargs)
            yield from self.parse_response(response, stream_state=stream_state, stream_slice=stream_slice)

            next_page_token = self.next_page_token(response)
            if not next_page_token:
                pagination_complete = True

        # Always return an empty generator just in case no records were ever yielded
        yield from []</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="airbyte_cdk.sources.streams.core.Stream" href="../core.html#airbyte_cdk.sources.streams.core.Stream">Stream</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="airbyte_cdk.sources.declarative.retrievers.simple_retriever.SimpleRetriever" href="../../declarative/retrievers/simple_retriever.html#airbyte_cdk.sources.declarative.retrievers.simple_retriever.SimpleRetriever">SimpleRetriever</a></li>
<li><a title="airbyte_cdk.sources.streams.http.http.HttpSubStream" href="http.html#airbyte_cdk.sources.streams.http.http.HttpSubStream">HttpSubStream</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.page_size"><code class="name">var <span class="ident">page_size</span> : Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.authenticator"><code class="name">var <span class="ident">authenticator</span> : <a title="airbyte_cdk.sources.streams.http.auth.core.HttpAuthenticator" href="auth/core.html#airbyte_cdk.sources.streams.http.auth.core.HttpAuthenticator">HttpAuthenticator</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def authenticator(self) -&gt; HttpAuthenticator:
    return self._authenticator</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.cache_filename"><code class="name">var <span class="ident">cache_filename</span></code></dt>
<dd>
<div class="desc"><p>Override if needed. Return the name of cache file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cache_filename(self):
    &#34;&#34;&#34;
    Override if needed. Return the name of cache file
    &#34;&#34;&#34;
    return f&#34;{self.name}.yml&#34;</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.http_method"><code class="name">var <span class="ident">http_method</span> : str</code></dt>
<dd>
<div class="desc"><p>Override if needed. See get_request_data/get_request_json if using POST/PUT/PATCH.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def http_method(self) -&gt; str:
    &#34;&#34;&#34;
    Override if needed. See get_request_data/get_request_json if using POST/PUT/PATCH.
    &#34;&#34;&#34;
    return &#34;GET&#34;</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.max_retries"><code class="name">var <span class="ident">max_retries</span> : Optional[int]</code></dt>
<dd>
<div class="desc"><p>Override if needed. Specifies maximum amount of retries for backoff policy. Return None for no limit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_retries(self) -&gt; Union[int, None]:
    &#34;&#34;&#34;
    Override if needed. Specifies maximum amount of retries for backoff policy. Return None for no limit.
    &#34;&#34;&#34;
    return 5</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.raise_on_http_errors"><code class="name">var <span class="ident">raise_on_http_errors</span> : bool</code></dt>
<dd>
<div class="desc"><p>Override if needed. If set to False, allows opting-out of raising HTTP code exception.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raise_on_http_errors(self) -&gt; bool:
    &#34;&#34;&#34;
    Override if needed. If set to False, allows opting-out of raising HTTP code exception.
    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.retry_factor"><code class="name">var <span class="ident">retry_factor</span> : float</code></dt>
<dd>
<div class="desc"><p>Override if needed. Specifies factor for backoff policy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def retry_factor(self) -&gt; float:
    &#34;&#34;&#34;
    Override if needed. Specifies factor for backoff policy.
    &#34;&#34;&#34;
    return 5</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.url_base"><code class="name">var <span class="ident">url_base</span> : str</code></dt>
<dd>
<div class="desc"><p>:return: URL base for the
API endpoint e.g: if you wanted to hit <a href="https://myapi.com/v1/some_entity">https://myapi.com/v1/some_entity</a> then this should return "https://myapi.com/v1/"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def url_base(self) -&gt; str:
    &#34;&#34;&#34;
    :return: URL base for the  API endpoint e.g: if you wanted to hit https://myapi.com/v1/some_entity then this should return &#34;https://myapi.com/v1/&#34;
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.use_cache"><code class="name">var <span class="ident">use_cache</span></code></dt>
<dd>
<div class="desc"><p>Override if needed. If True, all records will be cached.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def use_cache(self):
    &#34;&#34;&#34;
    Override if needed. If True, all records will be cached.
    &#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.backoff_time"><code class="name flex">
<span>def <span class="ident">backoff_time</span></span>(<span>self, response: requests.models.Response) ‑> Optional[float]</span>
</code></dt>
<dd>
<div class="desc"><p>Override this method to dynamically determine backoff time e.g: by reading the X-Retry-After header.</p>
<p>This method is called only if should_backoff() returns True for the input request.</p>
<p>:param response:
:return how long to backoff in seconds. The return value may be a floating point number for subsecond precision. Returning None defers backoff
to the default backoff behavior (e.g using an exponential algorithm).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def backoff_time(self, response: requests.Response) -&gt; Optional[float]:
    &#34;&#34;&#34;
    Override this method to dynamically determine backoff time e.g: by reading the X-Retry-After header.

    This method is called only if should_backoff() returns True for the input request.

    :param response:
    :return how long to backoff in seconds. The return value may be a floating point number for subsecond precision. Returning None defers backoff
    to the default backoff behavior (e.g using an exponential algorithm).
    &#34;&#34;&#34;
    return None</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.get_error_display_message"><code class="name flex">
<span>def <span class="ident">get_error_display_message</span></span>(<span>self, exception: BaseException) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the user-friendly display message that corresponds to an exception.
This will be called when encountering an exception while reading records from the stream, and used to build the AirbyteTraceMessage.</p>
<p>The default implementation of this method only handles HTTPErrors by passing the response to self.parse_response_error_message().
The method should be overriden as needed to handle any additional exception types.</p>
<p>:param exception: The exception that was raised
:return: A user-friendly message that indicates the cause of the error</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_error_display_message(self, exception: BaseException) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Retrieves the user-friendly display message that corresponds to an exception.
    This will be called when encountering an exception while reading records from the stream, and used to build the AirbyteTraceMessage.

    The default implementation of this method only handles HTTPErrors by passing the response to self.parse_response_error_message().
    The method should be overriden as needed to handle any additional exception types.

    :param exception: The exception that was raised
    :return: A user-friendly message that indicates the cause of the error
    &#34;&#34;&#34;
    if isinstance(exception, requests.HTTPError):
        return self.parse_response_error_message(exception.response)
    return None</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.next_page_token"><code class="name flex">
<span>def <span class="ident">next_page_token</span></span>(<span>self, response: requests.models.Response) ‑> Optional[Mapping[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Override this method to define a pagination strategy.</p>
<p>The value returned from this method is passed to most other methods in this class. Use it to form a request e.g: set headers or query params.</p>
<p>:return: The token for the next page from the input response object. Returning None means there are no more pages to read in this response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def next_page_token(self, response: requests.Response) -&gt; Optional[Mapping[str, Any]]:
    &#34;&#34;&#34;
    Override this method to define a pagination strategy.

    The value returned from this method is passed to most other methods in this class. Use it to form a request e.g: set headers or query params.

    :return: The token for the next page from the input response object. Returning None means there are no more pages to read in this response.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.parse_response"><code class="name flex">
<span>def <span class="ident">parse_response</span></span>(<span>self, response: requests.models.Response, *, stream_state: Mapping[str, Any], stream_slice: Mapping[str, Any] = None, next_page_token: Mapping[str, Any] = None) ‑> Iterable[Mapping]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the raw response object into a list of records.
By default, this returns an iterable containing the input. Override to parse differently.
:param response:
:param stream_state:
:param stream_slice:
:param next_page_token:
:return: An iterable containing the parsed response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def parse_response(
    self,
    response: requests.Response,
    *,
    stream_state: Mapping[str, Any],
    stream_slice: Mapping[str, Any] = None,
    next_page_token: Mapping[str, Any] = None,
) -&gt; Iterable[Mapping]:
    &#34;&#34;&#34;
    Parses the raw response object into a list of records.
    By default, this returns an iterable containing the input. Override to parse differently.
    :param response:
    :param stream_state:
    :param stream_slice:
    :param next_page_token:
    :return: An iterable containing the parsed response
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.parse_response_error_message"><code class="name flex">
<span>def <span class="ident">parse_response_error_message</span></span>(<span>self, response: requests.models.Response) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the raw response object from a failed request into a user-friendly error message.
By default, this method tries to grab the error message from JSON responses by following common API patterns. Override to parse differently.</p>
<p>:param response:
:return: A user-friendly message that indicates the cause of the error</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_response_error_message(self, response: requests.Response) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Parses the raw response object from a failed request into a user-friendly error message.
    By default, this method tries to grab the error message from JSON responses by following common API patterns. Override to parse differently.

    :param response:
    :return: A user-friendly message that indicates the cause of the error
    &#34;&#34;&#34;

    # default logic to grab error from common fields
    def _try_get_error(value):
        if isinstance(value, str):
            return value
        elif isinstance(value, list):
            return &#34;, &#34;.join(_try_get_error(v) for v in value)
        elif isinstance(value, dict):
            new_value = (
                value.get(&#34;message&#34;)
                or value.get(&#34;messages&#34;)
                or value.get(&#34;error&#34;)
                or value.get(&#34;errors&#34;)
                or value.get(&#34;failures&#34;)
                or value.get(&#34;failure&#34;)
            )
            return _try_get_error(new_value)
        return None

    try:
        body = response.json()
        return _try_get_error(body)
    except requests.exceptions.JSONDecodeError:
        return None</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.path"><code class="name flex">
<span>def <span class="ident">path</span></span>(<span>self, *, stream_state: Mapping[str, Any] = None, stream_slice: Mapping[str, Any] = None, next_page_token: Mapping[str, Any] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the URL path for the API endpoint e.g: if you wanted to hit <a href="https://myapi.com/v1/some_entity">https://myapi.com/v1/some_entity</a> then this should return "some_entity"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def path(
    self,
    *,
    stream_state: Mapping[str, Any] = None,
    stream_slice: Mapping[str, Any] = None,
    next_page_token: Mapping[str, Any] = None,
) -&gt; str:
    &#34;&#34;&#34;
    Returns the URL path for the API endpoint e.g: if you wanted to hit https://myapi.com/v1/some_entity then this should return &#34;some_entity&#34;
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.request_body_data"><code class="name flex">
<span>def <span class="ident">request_body_data</span></span>(<span>self, stream_state: Mapping[str, Any], stream_slice: Mapping[str, Any] = None, next_page_token: Mapping[str, Any] = None) ‑> Union[Mapping, str, ForwardRef(None)]</span>
</code></dt>
<dd>
<div class="desc"><p>Override when creating POST/PUT/PATCH requests to populate the body of the request with a non-JSON payload.</p>
<p>If returns a ready text that it will be sent as is.
If returns a dict that it will be converted to a urlencoded form.
E.g. {"key1": "value1", "key2": "value2"} =&gt; "key1=value1&amp;key2=value2"</p>
<p>At the same time only one of the 'request_body_data' and 'request_body_json' functions can be overridden.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request_body_data(
    self,
    stream_state: Mapping[str, Any],
    stream_slice: Mapping[str, Any] = None,
    next_page_token: Mapping[str, Any] = None,
) -&gt; Optional[Union[Mapping, str]]:
    &#34;&#34;&#34;
    Override when creating POST/PUT/PATCH requests to populate the body of the request with a non-JSON payload.

    If returns a ready text that it will be sent as is.
    If returns a dict that it will be converted to a urlencoded form.
    E.g. {&#34;key1&#34;: &#34;value1&#34;, &#34;key2&#34;: &#34;value2&#34;} =&gt; &#34;key1=value1&amp;key2=value2&#34;

    At the same time only one of the &#39;request_body_data&#39; and &#39;request_body_json&#39; functions can be overridden.
    &#34;&#34;&#34;
    return None</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.request_body_json"><code class="name flex">
<span>def <span class="ident">request_body_json</span></span>(<span>self, stream_state: Mapping[str, Any], stream_slice: Mapping[str, Any] = None, next_page_token: Mapping[str, Any] = None) ‑> Optional[Mapping]</span>
</code></dt>
<dd>
<div class="desc"><p>Override when creating POST/PUT/PATCH requests to populate the body of the request with a JSON payload.</p>
<p>At the same time only one of the 'request_body_data' and 'request_body_json' functions can be overridden.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request_body_json(
    self,
    stream_state: Mapping[str, Any],
    stream_slice: Mapping[str, Any] = None,
    next_page_token: Mapping[str, Any] = None,
) -&gt; Optional[Mapping]:
    &#34;&#34;&#34;
    Override when creating POST/PUT/PATCH requests to populate the body of the request with a JSON payload.

    At the same time only one of the &#39;request_body_data&#39; and &#39;request_body_json&#39; functions can be overridden.
    &#34;&#34;&#34;
    return None</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.request_cache"><code class="name flex">
<span>def <span class="ident">request_cache</span></span>(<span>self) ‑> <module 'vcr.cassette' from '/Users/alex/code/airbyte/airbyte-integrations/connectors/source-github/.venv/lib/python3.9/site-packages/vcr/cassette.py'></span>
</code></dt>
<dd>
<div class="desc"><p>Builds VCR instance.
It deletes file everytime we create it, normally should be called only once.
We can't use NamedTemporaryFile here because yaml serializer doesn't work well with empty files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request_cache(self) -&gt; Cassette:
    &#34;&#34;&#34;
    Builds VCR instance.
    It deletes file everytime we create it, normally should be called only once.
    We can&#39;t use NamedTemporaryFile here because yaml serializer doesn&#39;t work well with empty files.
    &#34;&#34;&#34;

    try:
        os.remove(self.cache_filename)
    except FileNotFoundError:
        pass

    return vcr.use_cassette(self.cache_filename, record_mode=&#34;new_episodes&#34;, serializer=&#34;yaml&#34;)</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.request_headers"><code class="name flex">
<span>def <span class="ident">request_headers</span></span>(<span>self, stream_state: Mapping[str, Any], stream_slice: Mapping[str, Any] = None, next_page_token: Mapping[str, Any] = None) ‑> Mapping[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Override to return any non-auth headers. Authentication headers will overwrite any overlapping headers returned from this method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request_headers(
    self, stream_state: Mapping[str, Any], stream_slice: Mapping[str, Any] = None, next_page_token: Mapping[str, Any] = None
) -&gt; Mapping[str, Any]:
    &#34;&#34;&#34;
    Override to return any non-auth headers. Authentication headers will overwrite any overlapping headers returned from this method.
    &#34;&#34;&#34;
    return {}</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.request_kwargs"><code class="name flex">
<span>def <span class="ident">request_kwargs</span></span>(<span>self, stream_state: Mapping[str, Any], stream_slice: Mapping[str, Any] = None, next_page_token: Mapping[str, Any] = None) ‑> Mapping[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Override to return a mapping of keyword arguments to be used when creating the HTTP request.
Any option listed in <a href="https://docs.python-requests.org/en/latest/api/#requests.adapters.BaseAdapter.send">https://docs.python-requests.org/en/latest/api/#requests.adapters.BaseAdapter.send</a> for can be returned from
this method. Note that these options do not conflict with request-level options such as headers, request params, etc..</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request_kwargs(
    self,
    stream_state: Mapping[str, Any],
    stream_slice: Mapping[str, Any] = None,
    next_page_token: Mapping[str, Any] = None,
) -&gt; Mapping[str, Any]:
    &#34;&#34;&#34;
    Override to return a mapping of keyword arguments to be used when creating the HTTP request.
    Any option listed in https://docs.python-requests.org/en/latest/api/#requests.adapters.BaseAdapter.send for can be returned from
    this method. Note that these options do not conflict with request-level options such as headers, request params, etc..
    &#34;&#34;&#34;
    return {}</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.request_params"><code class="name flex">
<span>def <span class="ident">request_params</span></span>(<span>self, stream_state: Mapping[str, Any], stream_slice: Mapping[str, Any] = None, next_page_token: Mapping[str, Any] = None) ‑> MutableMapping[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Override this method to define the query parameters that should be set on an outgoing HTTP request given the inputs.</p>
<p>E.g: you might want to define query parameters for paging if next_page_token is not None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request_params(
    self,
    stream_state: Mapping[str, Any],
    stream_slice: Mapping[str, Any] = None,
    next_page_token: Mapping[str, Any] = None,
) -&gt; MutableMapping[str, Any]:
    &#34;&#34;&#34;
    Override this method to define the query parameters that should be set on an outgoing HTTP request given the inputs.

    E.g: you might want to define query parameters for paging if next_page_token is not None.
    &#34;&#34;&#34;
    return {}</code></pre>
</details>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpStream.should_retry"><code class="name flex">
<span>def <span class="ident">should_retry</span></span>(<span>self, response: requests.models.Response) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Override to set different conditions for backoff based on the response from the server.</p>
<p>By default, back off on the following HTTP response statuses:
- 429 (Too Many Requests) indicating rate limiting
- 500s to handle transient server errors</p>
<p>Unexpected but transient exceptions (connection timeout, DNS resolution failed, etc..) are retried by default.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def should_retry(self, response: requests.Response) -&gt; bool:
    &#34;&#34;&#34;
    Override to set different conditions for backoff based on the response from the server.

    By default, back off on the following HTTP response statuses:
     - 429 (Too Many Requests) indicating rate limiting
     - 500s to handle transient server errors

    Unexpected but transient exceptions (connection timeout, DNS resolution failed, etc..) are retried by default.
    &#34;&#34;&#34;
    return response.status_code == 429 or 500 &lt;= response.status_code &lt; 600</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="airbyte_cdk.sources.streams.core.Stream" href="../core.html#airbyte_cdk.sources.streams.core.Stream">Stream</a></b></code>:
<ul class="hlist">
<li><code><a title="airbyte_cdk.sources.streams.core.Stream.cursor_field" href="../core.html#airbyte_cdk.sources.streams.core.Stream.cursor_field">cursor_field</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.core.Stream.get_json_schema" href="../core.html#airbyte_cdk.sources.streams.core.Stream.get_json_schema">get_json_schema</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.core.Stream.get_updated_state" href="../core.html#airbyte_cdk.sources.streams.core.Stream.get_updated_state">get_updated_state</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.core.Stream.name" href="../core.html#airbyte_cdk.sources.streams.core.Stream.name">name</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.core.Stream.namespace" href="../core.html#airbyte_cdk.sources.streams.core.Stream.namespace">namespace</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.core.Stream.primary_key" href="../core.html#airbyte_cdk.sources.streams.core.Stream.primary_key">primary_key</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.core.Stream.read_records" href="../core.html#airbyte_cdk.sources.streams.core.Stream.read_records">read_records</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.core.Stream.source_defined_cursor" href="../core.html#airbyte_cdk.sources.streams.core.Stream.source_defined_cursor">source_defined_cursor</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.core.Stream.state_checkpoint_interval" href="../core.html#airbyte_cdk.sources.streams.core.Stream.state_checkpoint_interval">state_checkpoint_interval</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.core.Stream.stream_slices" href="../core.html#airbyte_cdk.sources.streams.core.Stream.stream_slices">stream_slices</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.core.Stream.supports_incremental" href="../core.html#airbyte_cdk.sources.streams.core.Stream.supports_incremental">supports_incremental</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="airbyte_cdk.sources.streams.http.HttpSubStream"><code class="flex name class">
<span>class <span class="ident">HttpSubStream</span></span>
<span>(</span><span>parent: <a title="airbyte_cdk.sources.streams.http.http.HttpStream" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream">HttpStream</a>, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base abstract class for an Airbyte Stream using the HTTP protocol. Basic building block for users building an Airbyte source for a HTTP API.</p>
<p>:param parent: should be the instance of HttpStream class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HttpSubStream(HttpStream, ABC):
    def __init__(self, parent: HttpStream, **kwargs):
        &#34;&#34;&#34;
        :param parent: should be the instance of HttpStream class
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.parent = parent

    def stream_slices(
        self, sync_mode: SyncMode, cursor_field: List[str] = None, stream_state: Mapping[str, Any] = None
    ) -&gt; Iterable[Optional[Mapping[str, Any]]]:
        parent_stream_slices = self.parent.stream_slices(
            sync_mode=SyncMode.full_refresh, cursor_field=cursor_field, stream_state=stream_state
        )

        # iterate over all parent stream_slices
        for stream_slice in parent_stream_slices:
            parent_records = self.parent.read_records(
                sync_mode=SyncMode.full_refresh, cursor_field=cursor_field, stream_slice=stream_slice, stream_state=stream_state
            )

            # iterate over all parent records with current stream_slice
            for record in parent_records:
                yield {&#34;parent&#34;: record}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="airbyte_cdk.sources.streams.http.http.HttpStream" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream">HttpStream</a></li>
<li><a title="airbyte_cdk.sources.streams.core.Stream" href="../core.html#airbyte_cdk.sources.streams.core.Stream">Stream</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="airbyte_cdk.sources.streams.http.HttpSubStream.page_size"><code class="name">var <span class="ident">page_size</span> : Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="airbyte_cdk.sources.streams.http.http.HttpStream" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream">HttpStream</a></b></code>:
<ul class="hlist">
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.backoff_time" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.backoff_time">backoff_time</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.cache_filename" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.cache_filename">cache_filename</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.cursor_field" href="../core.html#airbyte_cdk.sources.streams.core.Stream.cursor_field">cursor_field</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.get_error_display_message" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.get_error_display_message">get_error_display_message</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.get_json_schema" href="../core.html#airbyte_cdk.sources.streams.core.Stream.get_json_schema">get_json_schema</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.get_updated_state" href="../core.html#airbyte_cdk.sources.streams.core.Stream.get_updated_state">get_updated_state</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.http_method" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.http_method">http_method</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.max_retries" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.max_retries">max_retries</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.name" href="../core.html#airbyte_cdk.sources.streams.core.Stream.name">name</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.namespace" href="../core.html#airbyte_cdk.sources.streams.core.Stream.namespace">namespace</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.next_page_token" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.next_page_token">next_page_token</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.parse_response" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.parse_response">parse_response</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.parse_response_error_message" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.parse_response_error_message">parse_response_error_message</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.path" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.path">path</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.primary_key" href="../core.html#airbyte_cdk.sources.streams.core.Stream.primary_key">primary_key</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.raise_on_http_errors" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.raise_on_http_errors">raise_on_http_errors</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.read_records" href="../core.html#airbyte_cdk.sources.streams.core.Stream.read_records">read_records</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.request_body_data" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.request_body_data">request_body_data</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.request_body_json" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.request_body_json">request_body_json</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.request_cache" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.request_cache">request_cache</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.request_headers" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.request_headers">request_headers</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.request_kwargs" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.request_kwargs">request_kwargs</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.request_params" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.request_params">request_params</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.retry_factor" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.retry_factor">retry_factor</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.should_retry" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.should_retry">should_retry</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.state_checkpoint_interval" href="../core.html#airbyte_cdk.sources.streams.core.Stream.state_checkpoint_interval">state_checkpoint_interval</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.stream_slices" href="../core.html#airbyte_cdk.sources.streams.core.Stream.stream_slices">stream_slices</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.supports_incremental" href="../core.html#airbyte_cdk.sources.streams.core.Stream.supports_incremental">supports_incremental</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.url_base" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.url_base">url_base</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http.HttpStream.use_cache" href="http.html#airbyte_cdk.sources.streams.http.http.HttpStream.use_cache">use_cache</a></code></li>
</ul>
</li>
<li><code><b><a title="airbyte_cdk.sources.streams.core.Stream" href="../core.html#airbyte_cdk.sources.streams.core.Stream">Stream</a></b></code>:
<ul class="hlist">
<li><code><a title="airbyte_cdk.sources.streams.core.Stream.source_defined_cursor" href="../core.html#airbyte_cdk.sources.streams.core.Stream.source_defined_cursor">source_defined_cursor</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="airbyte_cdk.sources.streams.http.UserDefinedBackoffException"><code class="flex name class">
<span>class <span class="ident">UserDefinedBackoffException</span></span>
<span>(</span><span>backoff: Union[int, float], request: requests.models.PreparedRequest, response: requests.models.Response)</span>
</code></dt>
<dd>
<div class="desc"><p>An exception that exposes how long it attempted to backoff</p>
<p>:param backoff: how long to backoff in seconds
:param request: the request that triggered this backoff exception
:param response: the response that triggered the backoff exception</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UserDefinedBackoffException(BaseBackoffException):
    &#34;&#34;&#34;
    An exception that exposes how long it attempted to backoff
    &#34;&#34;&#34;

    def __init__(self, backoff: Union[int, float], request: requests.PreparedRequest, response: requests.Response):
        &#34;&#34;&#34;
        :param backoff: how long to backoff in seconds
        :param request: the request that triggered this backoff exception
        :param response: the response that triggered the backoff exception
        &#34;&#34;&#34;
        self.backoff = backoff
        super().__init__(request=request, response=response)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="airbyte_cdk.sources.streams.http.exceptions.BaseBackoffException" href="exceptions.html#airbyte_cdk.sources.streams.http.exceptions.BaseBackoffException">BaseBackoffException</a></li>
<li>requests.exceptions.HTTPError</li>
<li>requests.exceptions.RequestException</li>
<li>builtins.OSError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="airbyte_cdk.sources.streams" href="../index.html">airbyte_cdk.sources.streams</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="airbyte_cdk.sources.streams.http.auth" href="auth/index.html">airbyte_cdk.sources.streams.http.auth</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.exceptions" href="exceptions.html">airbyte_cdk.sources.streams.http.exceptions</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.http" href="http.html">airbyte_cdk.sources.streams.http.http</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.rate_limiting" href="rate_limiting.html">airbyte_cdk.sources.streams.http.rate_limiting</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.requests_native_auth" href="requests_native_auth/index.html">airbyte_cdk.sources.streams.http.requests_native_auth</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="airbyte_cdk.sources.streams.http.HttpStream" href="#airbyte_cdk.sources.streams.http.HttpStream">HttpStream</a></code></h4>
<ul class="">
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.authenticator" href="#airbyte_cdk.sources.streams.http.HttpStream.authenticator">authenticator</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.backoff_time" href="#airbyte_cdk.sources.streams.http.HttpStream.backoff_time">backoff_time</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.cache_filename" href="#airbyte_cdk.sources.streams.http.HttpStream.cache_filename">cache_filename</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.get_error_display_message" href="#airbyte_cdk.sources.streams.http.HttpStream.get_error_display_message">get_error_display_message</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.http_method" href="#airbyte_cdk.sources.streams.http.HttpStream.http_method">http_method</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.max_retries" href="#airbyte_cdk.sources.streams.http.HttpStream.max_retries">max_retries</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.next_page_token" href="#airbyte_cdk.sources.streams.http.HttpStream.next_page_token">next_page_token</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.page_size" href="#airbyte_cdk.sources.streams.http.HttpStream.page_size">page_size</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.parse_response" href="#airbyte_cdk.sources.streams.http.HttpStream.parse_response">parse_response</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.parse_response_error_message" href="#airbyte_cdk.sources.streams.http.HttpStream.parse_response_error_message">parse_response_error_message</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.path" href="#airbyte_cdk.sources.streams.http.HttpStream.path">path</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.raise_on_http_errors" href="#airbyte_cdk.sources.streams.http.HttpStream.raise_on_http_errors">raise_on_http_errors</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.request_body_data" href="#airbyte_cdk.sources.streams.http.HttpStream.request_body_data">request_body_data</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.request_body_json" href="#airbyte_cdk.sources.streams.http.HttpStream.request_body_json">request_body_json</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.request_cache" href="#airbyte_cdk.sources.streams.http.HttpStream.request_cache">request_cache</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.request_headers" href="#airbyte_cdk.sources.streams.http.HttpStream.request_headers">request_headers</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.request_kwargs" href="#airbyte_cdk.sources.streams.http.HttpStream.request_kwargs">request_kwargs</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.request_params" href="#airbyte_cdk.sources.streams.http.HttpStream.request_params">request_params</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.retry_factor" href="#airbyte_cdk.sources.streams.http.HttpStream.retry_factor">retry_factor</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.should_retry" href="#airbyte_cdk.sources.streams.http.HttpStream.should_retry">should_retry</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.url_base" href="#airbyte_cdk.sources.streams.http.HttpStream.url_base">url_base</a></code></li>
<li><code><a title="airbyte_cdk.sources.streams.http.HttpStream.use_cache" href="#airbyte_cdk.sources.streams.http.HttpStream.use_cache">use_cache</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="airbyte_cdk.sources.streams.http.HttpSubStream" href="#airbyte_cdk.sources.streams.http.HttpSubStream">HttpSubStream</a></code></h4>
<ul class="">
<li><code><a title="airbyte_cdk.sources.streams.http.HttpSubStream.page_size" href="#airbyte_cdk.sources.streams.http.HttpSubStream.page_size">page_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="airbyte_cdk.sources.streams.http.UserDefinedBackoffException" href="#airbyte_cdk.sources.streams.http.UserDefinedBackoffException">UserDefinedBackoffException</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>