#
# Copyright (c) 2022 Airbyte, Inc., all rights reserved.
#

# generated by datamodel-codegen:
#   filename:  well_known_types.yaml

from __future__ import annotations

from enum import Enum
from typing import Any, Union

from pydantic import BaseModel, Field, constr


class Model(BaseModel):
    __root__: Any


class String(BaseModel):
    __root__: str = Field(..., description="Arbitrary text")


class BinaryData(BaseModel):
    __root__: constr(regex=r"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$") = Field(
        ...,
        description="Arbitrary binary data. Represented as base64-encoded strings in the JSON transport. In the future, if we support other transports, may be encoded differently.\n",
    )


class Date(BaseModel):
    __root__: constr(regex=r"^\d{4}-\d{2}-\d{2}( BC)?$") = Field(
        ..., description="RFC 3339§5.6's full-date format, extended with BC era support"
    )


class TimestampWithTimezone(BaseModel):
    __root__: constr(regex=r"^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+\-]\d{1,2}:\d{2})( BC)?$") = Field(
        ...,
        description='An instant in time. Frequently simply referred to as just a timestamp, or timestamptz. Uses RFC 3339§5.6\'s date-time format, requiring a "T" separator, and extended with BC era support. Note that we do _not_ accept Unix epochs here.\n',
    )


class TimestampWithoutTimezone(BaseModel):
    __root__: constr(regex=r"^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?( BC)?$") = Field(
        ...,
        description='Also known as a localdatetime, or just datetime. Under RFC 3339§5.6, this would be represented as `full-date "T" partial-time`, extended with BC era support.\n',
    )


class TimeWithTimezone(BaseModel):
    __root__: constr(regex=r"^\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+\-]\d{1,2}:\d{2})$") = Field(..., description="An RFC 3339§5.6 full-time")


class TimeWithoutTimezone(BaseModel):
    __root__: constr(regex=r"^\d{2}:\d{2}:\d{2}(\.\d+)?$") = Field(..., description="An RFC 3339§5.6 partial-time")


class NumberEnum(Enum):
    Infinity = "Infinity"
    _Infinity = "-Infinity"
    NaN = "NaN"


class Number(BaseModel):
    __root__: Union[Any, NumberEnum] = Field(
        ...,
        description="Note the mix of regex validation for normal numbers, and enum validation for special values.",
    )


class IntegerEnum(Enum):
    Infinity = "Infinity"
    _Infinity = "-Infinity"
    NaN = "NaN"


class Integer(BaseModel):
    __root__: Union[Any, IntegerEnum]


class Boolean(BaseModel):
    __root__: bool = Field(
        ...,
        description="Note the direct usage of a primitive boolean rather than string. Unlike Numbers and Integers, we don't expect unusual values  here.",
    )
