#
# Copyright (c) 2022 Airbyte, Inc., all rights reserved.
#
# This file was auto-generated from Airbyte's custom OpenAPI templates. Do not edit it manually.
# coding: utf-8

import inspect
from abc import ABC, abstractmethod
from typing import Callable, Dict, List  # noqa: F401

from fastapi import (  # noqa: F401
    APIRouter,
    Body,
    Cookie,
    Depends,
    Form,
    Header,
    Path,
    Query,
    Response,
    Security,
    status,
)

from {{modelPackage}}.extra_models import TokenModel  # noqa: F401


{{#imports}}
{{import}}
{{/imports}}


{{#operations}}
class {{classname}}(ABC):
    """
    NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
    Do not edit the class manually.
    """

    {{#operation}}
    @abstractmethod
    async def {{operationId}}(
        self, 
         {{#allParams}}
        {{>endpoint_argument_definition}},
        {{/allParams}}
        {{#hasAuthMethods}}
        {{#authMethods}}
        token_{{name}}: TokenModel = Security(
            get_token_{{name}}{{#isOAuth}}, scopes=[{{#scopes}}"{{scope}}"{{^-last}}, {{/-last}}{{/scopes}}]{{/isOAuth}}
        ),
        {{/authMethods}}
        {{/hasAuthMethods}}
    ) -> {{returnType}}{{^returnType}}None{{/returnType}}:
        """
        {{summary}}
        """

    {{/operation}}
    {{/operations}}

def _assert_signature_is_set(method: Callable) -> None:
    """
    APIRouter().add_api_route expects the input method to have a signature. It gets signatures
    by running inspect.signature(method) under the hood. 

    In the case that an instance method does not declare "self" as an input parameter (due to developer error 
    for example), then the call to inspect.signature() raises a ValueError and fails.

    Ideally, we'd automatically detect & correct this problem. To do that, we'd need to do
    setattr(method, "__signature__", <correct_signature>) but that's not possible because instance
    methods (i.e the input to this function) are object subclasses, and you can't use setattr on objects
    (https://stackoverflow.com/a/12839070/3237889)

    The workaround this method implements is to raise an exception at runtime if the input method fails
    when inspect.signature() is called. This is good enough because the error will be detected
    immediately when the developer tries to run the server, so builds should very quickly fail and this
    will practically never make it to a production scenario.
    """
    try:
        inspect.signature(method)
    except ValueError as e:
        # Based on empirical observation, the call to inspect fails with a ValueError
        # with exactly one argument: "invalid method signature"
        if e.args and len(e.args) == 1 and e.args[0] == "invalid method signature":
            # I couldn't figure out how to setattr on a "method" object to populate the signature. For now just kick
            # it back to the developer and tell them to set the "self" variable
            raise Exception(f"Method {method.__name__} in class {type(method.__self__).__name__} must declare the variable 'self'. ")
        else:
            raise


{{#operations}}
def initialize_router(api: {{classname}}) -> APIRouter:
    router = APIRouter()

    {{#operation}}
    _assert_signature_is_set(api.{{operationId}})
    router.add_api_route(
        "{{path}}",
        endpoint=api.{{operationId}},
        methods=["{{#lambda.uppercase}}{{httpMethod}}{{/lambda.uppercase}}"],
        responses={
            {{#responses}}
            {{code}}: {{=<% %>=}}{<%#dataType%>"model": <%dataType%>, "description": "<%message%>"<%/dataType%><%^dataType%>"description": "<%message%>"<%/dataType%>}<%={{ }}=%>,
            {{/responses}}
        },
        tags=[{{#tags}}"{{name}}"{{^-last}},{{/-last}}{{/tags}}],
        {{#summary}}
        summary="{{.}}",
        {{/summary}}
        {{#description}}
        description = "{{.}}",
        {{/description}}
        response_model_by_alias=True,
    )

    {{/operation}}
    {{/operations}}
    
    return router
