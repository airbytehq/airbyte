import com.github.spotbugs.snom.Confidence
import com.github.spotbugs.snom.Effort
import com.github.spotbugs.snom.SpotBugsTask

plugins {
    id 'base'
    id 'com.github.spotbugs' version '6.0.7'
    id 'version-catalog'
}


Properties env = new Properties()
rootProject.file('gradle.properties').withInputStream { env.load(it) }

if (!env.containsKey('VERSION')) {
    throw new Exception('Version not specified in .env file...')
}

// `version` is used as the application build version for artifacts like jars
// `image_tag` is used as the docker tag applied to built images.
// These values are the same for building an specific Airbyte release or branch via the 'VERSION' environment variable.
// For local development builds, the 'VERSION' environment variable is unset, and built images are tagged with 'dev'.
ext {
    version = System.getenv("VERSION") ?: env.VERSION
    image_tag = System.getenv("VERSION") ?: 'dev'
    skipSlowTests = (System.getProperty('skipSlowTests', 'false') != 'false')
}

def isConnectorProject = { Project project ->
    if (project.parent == null || project.parent.name != 'connectors') {
        return false
    }
    return project.name.startsWith("source-") || project.name.startsWith("destination-")
}

allprojects {
    apply plugin: 'base'

    // by default gradle uses directory as the project name. That works very well in a single project environment but
    // projects clobber each other in an environments with subprojects when projects are in directories named identically.
    def sub = rootDir.relativePath(projectDir.parentFile).replace('/', '.')
    group = "io.${rootProject.name}${sub.isEmpty() ? '' : ".$sub"}"
    project.base.archivesName = "${project.group}-${project.name}"

    version = rootProject.ext.version
}


def getCDKTargetVersion() {
    def props = new Properties()
    file("airbyte-cdk/java/airbyte-cdk/src/main/resources/version.properties").withInputStream { props.load(it) }
    return props.getProperty('version')
}
static def getLatestFileModifiedTimeFromFiles(files) {
    if (files.isEmpty()) {
        return null
    }
    return files.findAll { it.isFile() }
        .collect { it.lastModified() }
        .max()
}
def checkCDKJarExists(requiredSnapshotVersion) {
    if (requiredSnapshotVersion == null) {
        // Connector does not require CDK snapshot.
        return
    }
    final boolean checkFileChanges = true
    final cdkTargetVersion = getCDKTargetVersion()
    if (requiredSnapshotVersion != cdkTargetVersion) {
        if (!cdkTargetVersion.contains("-SNAPSHOT")) {
            throw new GradleException(
                "CDK JAR version is not publishing snapshot but connector requires version ${requiredSnapshotVersion}.\n" +
                "Please check that the version in the CDK properties file matches the connector build.gradle."
            )
        }
        throw new GradleException(
            "CDK JAR version ${cdkTargetVersion} does not match connector's required version ${requiredSnapshotVersion}.\n" +
            "Please check that the version in the CDK properties file matches the connector build.gradle."
        )
    }

    def cdkJar = file("${System.properties['user.home']}/.m2/repository/io/airbyte/airbyte-cdk/${cdkTargetVersion}/airbyte-cdk-${cdkTargetVersion}.jar")
    if (!cdkJar.exists()) {
        println("WARNING: CDK JAR does not exist at ${cdkJar.path}.\nPlease run './gradlew :airbyte-cdk:java:airbyte-cdk:build'.")
    }
    if (checkFileChanges) {
        def latestJavaFileTimestamp = getLatestFileModifiedTimeFromFiles(file("${rootDir}/airbyte-cdk/java/airbyte-cdk/src").listFiles().findAll { it.isFile() })
        if (cdkJar.lastModified() < latestJavaFileTimestamp) {
            throw new GradleException("CDK JAR is out of date. Please run './gradlew :airbyte-cdk:java:airbyte-cdk:build'.")
        }
    }
}
static def getCDKSnapshotRequirement(dependenciesList) {
    def cdkSnapshotRequirement = dependenciesList.find {
        it.requested instanceof ModuleComponentSelector &&
        it.requested.group == 'io.airbyte' &&
        it.requested.module == 'airbyte-cdk' &&
        it.requested.version.endsWith('-SNAPSHOT')
    }
    if (cdkSnapshotRequirement == null) {
        return null
    } else {
        return cdkSnapshotRequirement.requested.version
    }
}

// Common configurations for 'assemble'.
allprojects {

    tasks.withType(Tar).configureEach {
        duplicatesStrategy DuplicatesStrategy.INCLUDE
    }

    tasks.withType(Zip).configureEach {
        duplicatesStrategy DuplicatesStrategy.INCLUDE
        // Disabling distZip causes the build to break for some reason, so: instead of disabling it, make it fast.
        entryCompression ZipEntryCompression.STORED
    }
}

// Java projects common configurations.
subprojects { subproj ->

    if (!subproj.file('src/main/java').directory) {
        return
    }

    apply plugin: 'java'
    apply plugin: 'java-test-fixtures'
    apply plugin: 'com.github.spotbugs'

    java {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
        compileJava {
            options.compilerArgs += ["-Werror", "-Xlint:all,-serial,-processing"]
        }
        compileTestJava {
            //rawtypes and unchecked are necessary for mockito
            //deprecation and removal are removed from error since we should still test those constructs.
            options.compilerArgs += ["-Werror", "-Xlint:all,-serial,-processing,-rawtypes,-unchecked,-deprecation,-removal"]
        }
        compileTestFixturesJava {
            //rawtypes and unchecked are necessary for mockito
            options.compilerArgs += ["-Werror", "-Xlint:all,-serial,-processing,-rawtypes,-unchecked"]
        }
    }

    if (isConnectorProject(subproj)) {
        // This is a Java connector project.

        if (!gradle.startParameter.taskNames.any { it.contains(':airbyte-cdk:') } &&
            gradle.startParameter.taskNames.any { it.contains(':source-') || it.contains(':destination-') }) {
            // We are building a connector. Warn if the CDK JAR is missing or out of date.
            final String cdkRelativePath = 'airbyte-cdk/java/airbyte-cdk'
            afterEvaluate {
                def cdkVersionNeeded = getCDKSnapshotRequirement(configurations.compileClasspath.incoming.resolutionResult.allDependencies)
                checkCDKJarExists(cdkVersionNeeded)
            }
        }
    }

    spotbugs {
        ignoreFailures = false
        effort = Effort.valueOf(rootProject.ext.skipSlowTests ? 'MIN' : 'MAX')
        excludeFilter.set rootProject.file('spotbugs-exclude-filter-file.xml')
        reportLevel = Confidence.valueOf('HIGH')
        showProgress = false
        toolVersion = '4.8.3'
    }

    test {
        useJUnitPlatform()
        testLogging() {
            events 'skipped', 'started', 'passed', 'failed'
            exceptionFormat 'full'
            // Swallow the logs when running in airbyte-ci, rely on test reports instead.
            showStandardStreams = !System.getenv().containsKey("RUN_IN_AIRBYTE_CI")
        }
        reports {
            junitXml {
                outputPerTestCase = true
            }
        }

        // This is required by mockito, see https://github.com/mockito/mockito/issues/3037.
        jvmArgs "-XX:+EnableDynamicAgentLoading"
        // This is also required, to prevent stderr spam starting with
        //   "OpenJDK 64-Bit Server VM warning: Sharing is only supported for boot loader cl..."
        jvmArgs "-Xshare:off"

        // Set the timezone to UTC instead of picking up the host machine's timezone,
        // which on a developer's laptop is more likely to be PST.
        systemProperty 'user.timezone', 'UTC'

        // Enable parallel test execution in JUnit by default.
        // This is to support @Execution(ExecutionMode.CONCURRENT) annotations
        // See https://junit.org/junit5/docs/current/user-guide/#writing-tests-parallel-execution for details.
        systemProperty 'junit.jupiter.execution.parallel.enabled', 'true'
        // Concurrency takes place at the class level.
        systemProperty 'junit.jupiter.execution.parallel.mode.classes.default', 'concurrent'
        // Within a class, the test methods are still run serially on the same thread.
        systemProperty 'junit.jupiter.execution.parallel.mode.default', 'same_thread'
        // Effectively disable JUnit concurrency by running tests in only one thread by default.
        systemProperty 'junit.jupiter.execution.parallel.config.strategy', 'fixed'
        systemProperty 'junit.jupiter.execution.parallel.config.fixed.parallelism', 1
        // Order test classes by annotation.
        systemProperty 'junit.jupiter.testclass.order.default', 'org.junit.jupiter.api.ClassOrderer$OrderAnnotation'

        if (!subproj.hasProperty('testExecutionConcurrency')) {
            // By default, let gradle spawn as many independent workers as it wants.
            maxParallelForks = Runtime.runtime.availableProcessors()
            maxHeapSize = '3G'
        } else {
            // Otherwise, run tests within the same JVM.
            // Let gradle spawn only one worker.
            maxParallelForks = 1
            maxHeapSize = '8G'
            // Manage test execution concurrency in JUnit.
            String concurrency = subproj.property('testExecutionConcurrency').toString()
            if (concurrency.isInteger() && (concurrency as int) > 0) {
                // Define a fixed number of threads when the property is set to a positive integer.
                systemProperty 'junit.jupiter.execution.parallel.config.fixed.parallelism', concurrency
            } else {
                // Otherwise let JUnit manage the concurrency dynamically.
                systemProperty 'junit.jupiter.execution.parallel.config.strategy', 'dynamic'
            }
        }

        // Exclude all connector unit tests upon request.
        if (rootProject.ext.skipSlowTests) {
            exclude '**/io/airbyte/integrations/source/**'
            exclude '**/io/airbyte/integrations/destination/**'
        }
    }

    dependencies {
        // Lombok dependencies
        compileOnly libs.lombok
        annotationProcessor libs.lombok
        testCompileOnly libs.lombok
        testAnnotationProcessor libs.lombok
        testFixturesCompileOnly libs.lombok
        testFixturesAnnotationProcessor libs.lombok

        // JUnit dependencies
        testRuntimeOnly libs.junit.jupiter.engine
        testImplementation libs.bundles.junit
        testImplementation libs.assertj.core
        testImplementation libs.junit.pioneer
        testFixturesImplementation libs.bundles.junit
        testFixturesImplementation libs.assertj.core
        testFixturesImplementation libs.junit.pioneer

        // adds owasp plugin
        implementation 'com.github.spotbugs:spotbugs-annotations:4.8.3'
    }

    tasks.withType(SpotBugsTask).configureEach {
        // Reports can be found under each subproject in build/spotbugs/
        reports {
            xml.required = false
            html.required = true
        }
    }

    javadoc.options.addStringOption('Xdoclint:none', '-quiet')
}

// convenience task to list all dependencies per project
subprojects {
    tasks.register('listAllDependencies', DependencyReportTask) {}
}

// produce reproducible archives
// (see https://docs.gradle.org/current/userguide/working_with_files.html#sec:reproducible_archives)
tasks.withType(AbstractArchiveTask).configureEach {
    preserveFileTimestamps = false
    reproducibleFileOrder = true
}

// pin dependency versions according to ./deps.toml
catalog {
    versionCatalog {
        from(files("deps.toml"))
    }
}
