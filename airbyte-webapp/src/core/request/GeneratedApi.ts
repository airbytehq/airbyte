/**
 * Generated by orval v6.7.1 ðŸº
 * Do not edit manually.
 * Airbyte Configuration API
 * Airbyte Configuration API
[https://airbyte.io](https://airbyte.io).

This API is a collection of HTTP RPC-style methods. While it is not a REST API, those familiar with REST should find the conventions of this API recognizable.

Here are some conventions that this API follows:
* All endpoints are http POST methods.
* All endpoints accept data via `application/json` request bodies. The API does not accept any data via query params.
* The naming convention for endpoints is: localhost:8000/{VERSION}/{METHOD_FAMILY}/{METHOD_NAME} e.g. `localhost:8000/v1/connections/create`.
* For all `update` methods, the whole object must be passed in, even the fields that did not change.

Change Management:
* The major version of the API endpoint can be determined / specified in the URL `localhost:8080/v1/connections/create`
* Minor version bumps will be invisible to the end user. The user cannot specify minor versions in requests.
* All backwards incompatible changes will happen in major version bumps. We will not make backwards incompatible changes in minor version bumps. Examples of non-breaking changes (includes but not limited to...):
  * Adding fields to request or response bodies.
  * Adding new HTTP endpoints.
* All `web_backend` APIs are not considered public APIs and are not guaranteeing backwards compatibility.

 * OpenAPI spec version: 1.0.0
 */
import { useApiOverride } from "./useApiOverride";
/**
 * Input failed validation
 */
export type InvalidInputResponseResponse = InvalidInputExceptionInfo;

export interface KnownExceptionInfo {
  message: string;
  exceptionClassName?: string;
  exceptionStack?: string[];
  rootCauseExceptionClassName?: string;
  rootCauseExceptionStack?: string[];
}

/**
 * Exception occurred; see message for details.
 */
export type ExceptionResponseResponse = KnownExceptionInfo;

export interface NotFoundKnownExceptionInfo {
  id?: string;
  message: string;
  exceptionClassName?: string;
  exceptionStack?: string[];
  rootCauseExceptionClassName?: string;
  rootCauseExceptionStack?: string[];
}

/**
 * Object with given id was not found.
 */
export type NotFoundResponseResponse = NotFoundKnownExceptionInfo;

export interface InvalidInputProperty {
  propertyPath: string;
  invalidValue?: string;
  message?: string;
}

export interface InvalidInputExceptionInfo {
  message: string;
  exceptionClassName?: string;
  exceptionStack?: string[];
  validationErrors: InvalidInputProperty[];
}

export type UploadReadStatus = "succeeded" | "failed";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UploadReadStatus = {
  succeeded: "succeeded" as UploadReadStatus,
  failed: "failed" as UploadReadStatus,
};

export type ResourceId = string;

export interface ImportRequestBody {
  resourceId: ResourceId;
  workspaceId: WorkspaceId;
}

export interface UploadRead {
  status: UploadReadStatus;
  resourceId?: ResourceId;
}

export type ImportReadStatus = "succeeded" | "failed";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ImportReadStatus = {
  succeeded: "succeeded" as ImportReadStatus,
  failed: "failed" as ImportReadStatus,
};

export interface ImportRead {
  status: ImportReadStatus;
  reason?: string;
}

/**
 * Tarball Archive (.tar.gz) of Airbyte Configuration and Database
 */
export type AirbyteArchive = Blob;

export type DestinationSyncMode = "append" | "overwrite" | "append_dedup";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DestinationSyncMode = {
  append: "append" as DestinationSyncMode,
  overwrite: "overwrite" as DestinationSyncMode,
  append_dedup: "append_dedup" as DestinationSyncMode,
};

export type SyncMode = "full_refresh" | "incremental";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SyncMode = {
  full_refresh: "full_refresh" as SyncMode,
  incremental: "incremental" as SyncMode,
};

export interface WebBackendConnectionRead {
  connectionId: ConnectionId;
  name: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId: SourceId;
  destinationId: DestinationId;
  syncCatalog: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  operationIds?: OperationId[];
  source: SourceRead;
  destination: DestinationRead;
  operations?: OperationRead[];
  /** epoch time of the latest sync job. null if no sync job has taken place. */
  latestSyncJobCreatedAt?: number;
  latestSyncJobStatus?: JobStatus;
  isSyncing: boolean;
  resourceRequirements?: ResourceRequirements;
}

export interface WebBackendConnectionReadList {
  connections: WebBackendConnectionRead[];
}

export type SetInstancewideDestinationOauthParamsRequestBodyParams = { [key: string]: any };

export interface SetInstancewideDestinationOauthParamsRequestBody {
  destinationDefinitionId: DestinationDefinitionId;
  params: SetInstancewideDestinationOauthParamsRequestBodyParams;
}

export type SetInstancewideSourceOauthParamsRequestBodyParams = { [key: string]: any };

export interface SetInstancewideSourceOauthParamsRequestBody {
  sourceDefinitionId: SourceDefinitionId;
  params: SetInstancewideSourceOauthParamsRequestBodyParams;
}

export interface CompleteOAuthResponse {
  [key: string]: any;
}

/**
 * The query parameters present in the redirect URL after a user granted consent e.g auth code
 */
export type CompleteDestinationOAuthRequestQueryParams = { [key: string]: any };

/**
 * The query parameters present in the redirect URL after a user granted consent e.g auth code
 */
export type CompleteSourceOauthRequestQueryParams = { [key: string]: any };

export interface CompleteSourceOauthRequest {
  sourceDefinitionId: SourceDefinitionId;
  workspaceId: WorkspaceId;
  /** When completing OAuth flow to gain an access token, some API sometimes requires to verify that the app re-send the redirectUrl that was used when consent was given. */
  redirectUrl?: string;
  /** The query parameters present in the redirect URL after a user granted consent e.g auth code */
  queryParams?: CompleteSourceOauthRequestQueryParams;
  oAuthInputConfiguration?: OAuthInputConfiguration;
}

export interface OAuthConsentRead {
  consentUrl: string;
}

export interface DestinationOauthConsentRequest {
  destinationDefinitionId: DestinationDefinitionId;
  workspaceId: WorkspaceId;
  /** The url to redirect to after getting the user consent */
  redirectUrl: string;
  oAuthInputConfiguration?: OAuthInputConfiguration;
}

export interface SourceOauthConsentRequest {
  sourceDefinitionId: SourceDefinitionId;
  workspaceId: WorkspaceId;
  /** The url to redirect to after getting the user consent */
  redirectUrl: string;
  oAuthInputConfiguration?: OAuthInputConfiguration;
}

export interface OAuthConfigSpecification {
  /** OAuth specific blob. This is a Json Schema used to validate Json configurations used as input to OAuth.
Must be a valid non-nested JSON that refers to properties from ConnectorSpecification.connectionSpecification
using special annotation 'path_in_connector_config'.
These are input values the user is entering through the UI to authenticate to the connector, that might also shared
as inputs for syncing data via the connector.

Examples:

if no connector values is shared during oauth flow, oauth_user_input_from_connector_config_specification=[]
if connector values such as 'app_id' inside the top level are used to generate the API url for the oauth flow,
  oauth_user_input_from_connector_config_specification={
    app_id: {
      type: string
      path_in_connector_config: ['app_id']
    }
  }
if connector values such as 'info.app_id' nested inside another object are used to generate the API url for the oauth flow,
  oauth_user_input_from_connector_config_specification={
    app_id: {
      type: string
      path_in_connector_config: ['info', 'app_id']
    }
  } */
  oauthUserInputFromConnectorConfigSpecification?: OAuthConfiguration;
  /** OAuth specific blob. This is a Json Schema used to validate Json configurations produced by the OAuth flows as they are
returned by the distant OAuth APIs.
Must be a valid JSON describing the fields to merge back to `ConnectorSpecification.connectionSpecification`.
For each field, a special annotation `path_in_connector_config` can be specified to determine where to merge it,

Examples:

    complete_oauth_output_specification={
      refresh_token: {
        type: string,
        path_in_connector_config: ['credentials', 'refresh_token']
      }
    } */
  completeOAuthOutputSpecification?: OAuthConfiguration;
  /** OAuth specific blob. This is a Json Schema used to validate Json configurations persisted as Airbyte Server configurations.
Must be a valid non-nested JSON describing additional fields configured by the Airbyte Instance or Workspace Admins to be used by the
server when completing an OAuth flow (typically exchanging an auth code for refresh token).

Examples:

    complete_oauth_server_input_specification={
      client_id: {
        type: string
      },
      client_secret: {
        type: string
      }
    } */
  completeOAuthServerInputSpecification?: OAuthConfiguration;
  /** OAuth specific blob. This is a Json Schema used to validate Json configurations persisted as Airbyte Server configurations that
also need to be merged back into the connector configuration at runtime.
This is a subset configuration of `complete_oauth_server_input_specification` that filters fields out to retain only the ones that
are necessary for the connector to function with OAuth. (some fields could be used during oauth flows but not needed afterwards, therefore
they would be listed in the `complete_oauth_server_input_specification` but not `complete_oauth_server_output_specification`)
Must be a valid non-nested JSON describing additional fields configured by the Airbyte Instance or Workspace Admins to be used by the
connector when using OAuth flow APIs.
These fields are to be merged back to `ConnectorSpecification.connectionSpecification`.
For each field, a special annotation `path_in_connector_config` can be specified to determine where to merge it,

Examples:

      complete_oauth_server_output_specification={
        client_id: {
          type: string,
          path_in_connector_config: ['credentials', 'client_id']
        },
        client_secret: {
          type: string,
          path_in_connector_config: ['credentials', 'client_secret']
        }
      } */
  completeOAuthServerOutputSpecification?: OAuthConfiguration;
}

export type AdvancedAuthAuthFlowType = "oauth2.0" | "oauth1.0";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AdvancedAuthAuthFlowType = {
  oauth20: "oauth2.0" as AdvancedAuthAuthFlowType,
  oauth10: "oauth1.0" as AdvancedAuthAuthFlowType,
};

export interface AdvancedAuth {
  authFlowType?: AdvancedAuthAuthFlowType;
  /** Json Path to a field in the connectorSpecification that should exist for the advanced auth to be applicable. */
  predicateKey?: string[];
  /** Value of the predicate_key fields for the advanced auth to be applicable. */
  predicateValue?: string;
  oauthConfigSpecification?: OAuthConfigSpecification;
}

/**
 * OAuth specific blob.
 */
export type OAuthConfiguration = unknown;

/**
 * The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
 */
export type OAuthInputConfiguration = OAuthConfiguration;

export interface CompleteDestinationOAuthRequest {
  destinationDefinitionId: DestinationDefinitionId;
  workspaceId: WorkspaceId;
  /** When completing OAuth flow to gain an access token, some API sometimes requires to verify that the app re-send the redirectUrl that was used when consent was given. */
  redirectUrl?: string;
  /** The query parameters present in the redirect URL after a user granted consent e.g auth code */
  queryParams?: CompleteDestinationOAuthRequestQueryParams;
  oAuthInputConfiguration?: OAuthInputConfiguration;
}

export type DbMigrationState =
  | "pending"
  | "above_target"
  | "below_baseline"
  | "baseline"
  | "ignored"
  | "missing_success"
  | "missing_failed"
  | "success"
  | "undone"
  | "available"
  | "failed"
  | "out_of_order"
  | "future_success"
  | "future_failed"
  | "outdated"
  | "superseded"
  | "deleted";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DbMigrationState = {
  pending: "pending" as DbMigrationState,
  above_target: "above_target" as DbMigrationState,
  below_baseline: "below_baseline" as DbMigrationState,
  baseline: "baseline" as DbMigrationState,
  ignored: "ignored" as DbMigrationState,
  missing_success: "missing_success" as DbMigrationState,
  missing_failed: "missing_failed" as DbMigrationState,
  success: "success" as DbMigrationState,
  undone: "undone" as DbMigrationState,
  available: "available" as DbMigrationState,
  failed: "failed" as DbMigrationState,
  out_of_order: "out_of_order" as DbMigrationState,
  future_success: "future_success" as DbMigrationState,
  future_failed: "future_failed" as DbMigrationState,
  outdated: "outdated" as DbMigrationState,
  superseded: "superseded" as DbMigrationState,
  deleted: "deleted" as DbMigrationState,
};

export interface DbMigrationRead {
  migrationType: string;
  migrationVersion: string;
  migrationDescription: string;
  migrationState?: DbMigrationState;
  migratedBy?: string;
  migratedAt?: number;
  migrationScript?: string;
}

export interface DbMigrationExecutionRead {
  initialVersion?: string;
  targetVersion?: string;
  executedMigrations?: DbMigrationRead[];
}

export interface DbMigrationReadList {
  migrations?: DbMigrationRead[];
}

/**
 * optional resource requirements to run workers (blank for unbounded allocations)
 */
export interface ResourceRequirements {
  cpu_request?: string;
  cpu_limit?: string;
  memory_request?: string;
  memory_limit?: string;
}

/**
 * enum that describes the different types of jobs that the platform runs.
 */
export type JobType =
  | "get_spec"
  | "check_connection"
  | "discover_schema"
  | "sync"
  | "reset_connection"
  | "connection_updater"
  | "replicate";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JobType = {
  get_spec: "get_spec" as JobType,
  check_connection: "check_connection" as JobType,
  discover_schema: "discover_schema" as JobType,
  sync: "sync" as JobType,
  reset_connection: "reset_connection" as JobType,
  connection_updater: "connection_updater" as JobType,
  replicate: "replicate" as JobType,
};

/**
 * sets resource requirements for a specific job type for an actor definition. these values override the default, if both are set.
 */
export interface JobTypeResourceLimit {
  jobType: JobType;
  resourceRequirements: ResourceRequirements;
}

/**
 * actor definition specific resource requirements. if default is set, these are the requirements that should be set for ALL jobs run for this actor definition. it is overriden by the job type specific configurations. if not set, the platform will use defaults. these values will be overriden by configuration at the connection level.
 */
export interface ActorDefinitionResourceRequirements {
  default?: ResourceRequirements;
  jobSpecific?: JobTypeResourceLimit[];
}

export interface ConnectionStateObject {
  [key: string]: any;
}

export interface ConnectionState {
  connectionId: ConnectionId;
  state?: ConnectionStateObject;
}

export type CheckConnectionReadStatus = "succeeded" | "failed";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CheckConnectionReadStatus = {
  succeeded: "succeeded" as CheckConnectionReadStatus,
  failed: "failed" as CheckConnectionReadStatus,
};

export interface CheckConnectionRead {
  status: CheckConnectionReadStatus;
  message?: string;
  jobInfo: SynchronousJobRead;
}

export interface HealthCheckRead {
  available: boolean;
}

export interface Pagination {
  pageSize?: number;
  rowOffset?: number;
}

export interface LogRead {
  logLines: string[];
}

export interface SynchronousJobRead {
  id: string;
  configType: JobConfigType;
  /** only present if a config id was provided. */
  configId?: string;
  createdAt: number;
  endedAt: number;
  succeeded: boolean;
  logs?: LogRead;
}

export interface AttemptInfoRead {
  attempt: AttemptRead;
  logs: LogRead;
}

export interface JobDebugInfoRead {
  job: JobDebugRead;
  attempts: AttemptInfoRead[];
}

export interface JobInfoRead {
  job: JobRead;
  attempts: AttemptInfoRead[];
}

export interface JobReadList {
  jobs: JobWithAttemptsRead[];
}

export type AttemptStatus = "running" | "failed" | "succeeded";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AttemptStatus = {
  running: "running" as AttemptStatus,
  failed: "failed" as AttemptStatus,
  succeeded: "succeeded" as AttemptStatus,
};

/**
 * Categorizes well known errors into types for programmatic handling. If not set, the type of error is not well known.
 */
export type AttemptFailureType = "config_error" | "system_error" | "manual_cancellation";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AttemptFailureType = {
  config_error: "config_error" as AttemptFailureType,
  system_error: "system_error" as AttemptFailureType,
  manual_cancellation: "manual_cancellation" as AttemptFailureType,
};

/**
 * Indicates where the error originated. If not set, the origin of error is not well known.
 */
export type AttemptFailureOrigin = "source" | "destination" | "replication" | "persistence" | "normalization" | "dbt";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AttemptFailureOrigin = {
  source: "source" as AttemptFailureOrigin,
  destination: "destination" as AttemptFailureOrigin,
  replication: "replication" as AttemptFailureOrigin,
  persistence: "persistence" as AttemptFailureOrigin,
  normalization: "normalization" as AttemptFailureOrigin,
  dbt: "dbt" as AttemptFailureOrigin,
};

export interface AttemptFailureReason {
  failureOrigin?: AttemptFailureOrigin;
  failureType?: AttemptFailureType;
  externalMessage?: string;
  stacktrace?: string;
  /** True if it is known that retrying may succeed, e.g. for a transient failure. False if it is known that a retry will not succeed, e.g. for a configuration issue. If not set, retryable status is not well known. */
  retryable?: boolean;
  timestamp: number;
}

export interface AttemptFailureSummary {
  failures: AttemptFailureReason[];
  /** True if the number of committed records for this attempt was greater than 0. False if 0 records were committed. If not set, the number of committed records is unknown. */
  partialSuccess?: boolean;
}

export interface AttemptStats {
  recordsEmitted?: number;
  bytesEmitted?: number;
  stateMessagesEmitted?: number;
  recordsCommitted?: number;
}

export interface AttemptStreamStats {
  streamName: string;
  stats: AttemptStats;
}

export interface AttemptRead {
  id: number;
  status: AttemptStatus;
  createdAt: number;
  updatedAt: number;
  endedAt?: number;
  bytesSynced?: number;
  recordsSynced?: number;
  totalStats?: AttemptStats;
  streamStats?: AttemptStreamStats[];
  failureSummary?: AttemptFailureSummary;
}

export type JobStatus = "pending" | "running" | "incomplete" | "failed" | "succeeded" | "cancelled";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JobStatus = {
  pending: "pending" as JobStatus,
  running: "running" as JobStatus,
  incomplete: "incomplete" as JobStatus,
  failed: "failed" as JobStatus,
  succeeded: "succeeded" as JobStatus,
  cancelled: "cancelled" as JobStatus,
};

export interface JobWithAttemptsRead {
  job?: JobRead;
  attempts?: AttemptRead[];
}

export type JobConfigType =
  | "check_connection_source"
  | "check_connection_destination"
  | "discover_schema"
  | "get_spec"
  | "sync"
  | "reset_connection";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JobConfigType = {
  check_connection_source: "check_connection_source" as JobConfigType,
  check_connection_destination: "check_connection_destination" as JobConfigType,
  discover_schema: "discover_schema" as JobConfigType,
  get_spec: "get_spec" as JobConfigType,
  sync: "sync" as JobConfigType,
  reset_connection: "reset_connection" as JobConfigType,
};

export interface JobListRequestBody {
  configTypes: JobConfigType[];
  configId: string;
  pagination?: Pagination;
}

export type JobId = number;

export interface JobDebugRead {
  id: JobId;
  configType: JobConfigType;
  configId: string;
  status: JobStatus;
  airbyteVersion: string;
  sourceDefinition: SourceDefinitionRead;
  destinationDefinition: DestinationDefinitionRead;
}

export interface JobRead {
  id: JobId;
  configType: JobConfigType;
  configId: string;
  createdAt: number;
  updatedAt: number;
  status: JobStatus;
}

export interface JobIdRequestBody {
  id: JobId;
}

export type DataType = "string" | "number" | "boolean" | "object" | "array";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DataType = {
  string: "string" as DataType,
  number: "number" as DataType,
  boolean: "boolean" as DataType,
  object: "object" as DataType,
  array: "array" as DataType,
};

/**
 * the mutable part of the stream to configure the destination
 */
export interface AirbyteStreamConfiguration {
  syncMode: SyncMode;
  /** Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental`. Otherwise it is ignored. */
  cursorField?: string[];
  destinationSyncMode: DestinationSyncMode;
  /** Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup`. Otherwise it is ignored. */
  primaryKey?: string[][];
  /** Alias name to the stream to be used in the destination */
  aliasName?: string;
  selected?: boolean;
}

export interface StreamJsonSchema {
  [key: string]: any;
}

/**
 * the immutable schema defined by the source
 */
export interface AirbyteStream {
  /** Stream's name. */
  name: string;
  /** Stream schema using Json Schema specs. */
  jsonSchema?: StreamJsonSchema;
  supportedSyncModes?: SyncMode[];
  /** If the source defines the cursor field, then any other cursor field inputs will be ignored. If it does not, either the user_provided one is used, or the default one is used as a backup. */
  sourceDefinedCursor?: boolean;
  /** Path to the field that will be used to determine if a record is new or modified since the last sync. If not provided by the source, the end user will have to specify the comparable themselves. */
  defaultCursorField?: string[];
  /** If the source defines the primary key, paths to the fields that will be used as a primary key. If not provided by the source, the end user will have to specify the primary key themselves. */
  sourceDefinedPrimaryKey?: string[][];
  /** Optional Source-defined namespace. Airbyte streams from the same sources should have the same namespace. Currently only used by JDBC destinations to determine what schema to write to. */
  namespace?: string;
}

/**
 * each stream is split in two parts; the immutable schema from source and mutable configuration for destination
 */
export interface AirbyteStreamAndConfiguration {
  stream?: AirbyteStream;
  config?: AirbyteStreamConfiguration;
}

/**
 * describes the available schema (catalog).
 */
export interface AirbyteCatalog {
  streams: AirbyteStreamAndConfiguration[];
}

/**
 * type/source of logs produced
 */
export type LogType = "server" | "scheduler";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LogType = {
  server: "server" as LogType,
  scheduler: "scheduler" as LogType,
};

export interface LogsRequestBody {
  logType: LogType;
}

export type CheckOperationReadStatus = "succeeded" | "failed";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CheckOperationReadStatus = {
  succeeded: "succeeded" as CheckOperationReadStatus,
  failed: "failed" as CheckOperationReadStatus,
};

export interface CheckOperationRead {
  status: CheckOperationReadStatus;
  message?: string;
}

export interface OperatorDbt {
  gitRepoUrl: string;
  gitRepoBranch?: string;
  dockerImage?: string;
  dbtArguments?: string;
}

export type OperatorNormalizationOption = "basic";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OperatorNormalizationOption = {
  basic: "basic" as OperatorNormalizationOption,
};

export interface OperatorNormalization {
  option?: OperatorNormalizationOption;
}

export type OperatorType = "normalization" | "dbt";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OperatorType = {
  normalization: "normalization" as OperatorType,
  dbt: "dbt" as OperatorType,
};

export interface OperatorConfiguration {
  operatorType: OperatorType;
  normalization?: OperatorNormalization;
  dbt?: OperatorDbt;
}

export interface OperationRead {
  workspaceId: WorkspaceId;
  operationId: OperationId;
  name: string;
  operatorConfiguration: OperatorConfiguration;
}

export interface OperationReadList {
  operations: OperationRead[];
}

export interface OperationCreate {
  workspaceId: WorkspaceId;
  name: string;
  operatorConfiguration: OperatorConfiguration;
}

export type OperationId = string;

export interface OperationUpdate {
  operationId: OperationId;
  name: string;
  operatorConfiguration: OperatorConfiguration;
}

export interface OperationIdRequestBody {
  operationId: OperationId;
}

/**
 * Method used for computing final namespace in destination
 */
export type NamespaceDefinitionType = "source" | "destination" | "customformat";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NamespaceDefinitionType = {
  source: "source" as NamespaceDefinitionType,
  destination: "destination" as NamespaceDefinitionType,
  customformat: "customformat" as NamespaceDefinitionType,
};

export type ConnectionScheduleTimeUnit = "minutes" | "hours" | "days" | "weeks" | "months";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConnectionScheduleTimeUnit = {
  minutes: "minutes" as ConnectionScheduleTimeUnit,
  hours: "hours" as ConnectionScheduleTimeUnit,
  days: "days" as ConnectionScheduleTimeUnit,
  weeks: "weeks" as ConnectionScheduleTimeUnit,
  months: "months" as ConnectionScheduleTimeUnit,
};

/**
 * if null, then no schedule is set.
 */
export type ConnectionSchedule = {
  units: number;
  timeUnit: ConnectionScheduleTimeUnit;
} | null;

/**
 * Active means that data is flowing through the connection. Inactive means it is not. Deprecated means the connection is off and cannot be re-activated. the schema field describes the elements of the schema that will be synced.
 */
export type ConnectionStatus = "active" | "inactive" | "deprecated";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConnectionStatus = {
  active: "active" as ConnectionStatus,
  inactive: "inactive" as ConnectionStatus,
  deprecated: "deprecated" as ConnectionStatus,
};

export interface ConnectionReadList {
  connections: ConnectionRead[];
}

export interface WebBackendConnectionUpdate {
  /** Name that will be set to the connection */
  name?: string;
  connectionId: ConnectionId;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  operationIds?: OperationId[];
  syncCatalog: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
  withRefreshedCatalog?: boolean;
  operations?: WebBackendOperationCreateOrUpdate[];
}

export interface WebBackendConnectionCreate {
  /** Optional name of the connection */
  name?: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId: SourceId;
  destinationId: DestinationId;
  operationIds?: OperationId[];
  syncCatalog?: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
  operations?: OperationCreate[];
}

export interface ConnectionCreate {
  /** Optional name of the connection */
  name?: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId: SourceId;
  destinationId: DestinationId;
  operationIds?: OperationId[];
  syncCatalog?: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
}

export interface DbMigrationRequestBody {
  database: string;
}

export type ConnectionId = string;

export interface ConnectionSearch {
  connectionId?: ConnectionId;
  name?: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId?: SourceId;
  destinationId?: DestinationId;
  schedule?: ConnectionSchedule;
  status?: ConnectionStatus;
  source?: SourceSearch;
  destination?: DestinationSearch;
}

export interface ConnectionUpdate {
  connectionId: ConnectionId;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Name that will be set to this connection */
  name?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  operationIds?: OperationId[];
  syncCatalog: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
}

export interface WebBackendConnectionRequestBody {
  withRefreshedCatalog?: boolean;
  connectionId: ConnectionId;
}

export interface ConnectionIdRequestBody {
  connectionId: ConnectionId;
}

export type ReleaseStage = "alpha" | "beta" | "generally_available" | "custom";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReleaseStage = {
  alpha: "alpha" as ReleaseStage,
  beta: "beta" as ReleaseStage,
  generally_available: "generally_available" as ReleaseStage,
  custom: "custom" as ReleaseStage,
};

/**
 * The values required to configure the destination. The schema for this must match the schema return by destination_definition_specifications/get for the destinationDefinition.
 */
export type DestinationConfiguration = unknown;

export interface DestinationSearch {
  destinationDefinitionId?: DestinationDefinitionId;
  destinationId?: DestinationId;
  workspaceId?: WorkspaceId;
  connectionConfiguration?: DestinationConfiguration;
  name?: string;
  destinationName?: string;
}

export interface DestinationRead {
  destinationDefinitionId: DestinationDefinitionId;
  destinationId: DestinationId;
  workspaceId: WorkspaceId;
  connectionConfiguration: DestinationConfiguration;
  name: string;
  destinationName: string;
}

export interface DestinationReadList {
  destinations: DestinationRead[];
}

export interface DestinationUpdate {
  destinationId: DestinationId;
  connectionConfiguration: DestinationConfiguration;
  name: string;
}

export interface DestinationCreate {
  workspaceId: WorkspaceId;
  name: string;
  destinationDefinitionId: DestinationDefinitionId;
  connectionConfiguration: DestinationConfiguration;
}

export interface DestinationCoreConfig {
  destinationDefinitionId: DestinationDefinitionId;
  connectionConfiguration: DestinationConfiguration;
}

export type DestinationId = string;

export interface WebBackendConnectionSearch {
  connectionId?: ConnectionId;
  name?: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId?: SourceId;
  destinationId?: DestinationId;
  schedule?: ConnectionSchedule;
  status?: ConnectionStatus;
  source?: SourceSearch;
  destination?: DestinationSearch;
}

export interface ConnectionRead {
  connectionId: ConnectionId;
  name: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId: SourceId;
  destinationId: DestinationId;
  operationIds?: OperationId[];
  syncCatalog: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
}

export interface DestinationIdRequestBody {
  destinationId: DestinationId;
}

/**
 * The specification for what values are required to configure the destinationDefinition.
 */
export type DestinationDefinitionSpecification = unknown;

export interface DestinationDefinitionSpecificationRead {
  destinationDefinitionId: DestinationDefinitionId;
  documentationUrl?: string;
  connectionSpecification?: DestinationDefinitionSpecification;
  authSpecification?: DestinationAuthSpecification;
  advancedAuth?: AdvancedAuth;
  jobInfo: SynchronousJobRead;
  supportedDestinationSyncModes?: DestinationSyncMode[];
  supportsDbt?: boolean;
  supportsNormalization?: boolean;
}

export interface PrivateDestinationDefinitionRead {
  destinationDefinition: DestinationDefinitionRead;
  granted: boolean;
}

export interface PrivateDestinationDefinitionReadList {
  destinationDefinitions: PrivateDestinationDefinitionRead[];
}

export interface DestinationDefinitionIdWithWorkspaceId {
  destinationDefinitionId: DestinationDefinitionId;
  workspaceId: WorkspaceId;
}

export interface CustomDestinationDefinitionUpdate {
  workspaceId: WorkspaceId;
  destinationDefinition: DestinationDefinitionUpdate;
}

export interface CustomDestinationDefinitionCreate {
  workspaceId: WorkspaceId;
  destinationDefinition: DestinationDefinitionCreate;
}

export interface DestinationDefinitionRead {
  destinationDefinitionId: DestinationDefinitionId;
  name: string;
  dockerRepository: string;
  dockerImageTag: string;
  documentationUrl: string;
  icon?: string;
  releaseStage?: ReleaseStage;
  /** The date when this connector was first released, in yyyy-mm-dd format. */
  releaseDate?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface DestinationDefinitionReadList {
  destinationDefinitions: DestinationDefinitionRead[];
}

export interface DestinationDefinitionUpdate {
  destinationDefinitionId: DestinationDefinitionId;
  dockerImageTag?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface DestinationDefinitionCreate {
  name: string;
  dockerRepository: string;
  dockerImageTag: string;
  documentationUrl: string;
  icon?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface DestinationDefinitionIdRequestBody {
  destinationDefinitionId: DestinationDefinitionId;
}

export type DestinationAuthSpecification = AuthSpecification;

export type DestinationDefinitionId = string;

/**
 * Returns the results of a discover catalog job. If the job was not successful, the catalog field will not be present. jobInfo will aways be present and its status be used to determine if the job was successful or not.
 */
export interface SourceDiscoverSchemaRead {
  catalog?: AirbyteCatalog;
  jobInfo: SynchronousJobRead;
}

export interface SourceReadList {
  sources: SourceRead[];
}

export interface SourceDiscoverSchemaRequestBody {
  sourceId: SourceId;
  disable_cache?: boolean;
}

/**
 * The values required to configure the source. The schema for this must match the schema return by source_definition_specifications/get for the source.
 */
export type SourceConfiguration = unknown;

export interface SourceUpdate {
  sourceId: SourceId;
  connectionConfiguration: SourceConfiguration;
  name: string;
}

export interface SourceCreate {
  sourceDefinitionId: SourceDefinitionId;
  connectionConfiguration: SourceConfiguration;
  workspaceId: WorkspaceId;
  name: string;
}

export interface SourceCoreConfig {
  sourceDefinitionId: SourceDefinitionId;
  connectionConfiguration: SourceConfiguration;
}

export type SourceId = string;

export interface SourceRead {
  sourceDefinitionId: SourceDefinitionId;
  sourceId: SourceId;
  workspaceId: WorkspaceId;
  connectionConfiguration: SourceConfiguration;
  name: string;
  sourceName: string;
}

export interface SourceIdRequestBody {
  sourceId: SourceId;
}

/**
 * An object containing any metadata needed to describe this connector's Oauth flow
 */
export interface OAuth2Specification {
  /** A list of strings representing a pointer to the root object which contains any oauth parameters in the ConnectorSpecification.
Examples:
if oauth parameters were contained inside the top level, rootObject=[] If they were nested inside another object {'credentials': {'app_id' etc...}, rootObject=['credentials'] If they were inside a oneOf {'switch': {oneOf: [{client_id...}, {non_oauth_param]}},  rootObject=['switch', 0]  */
  rootObject: unknown[];
  /** Pointers to the fields in the rootObject needed to obtain the initial refresh/access tokens for the OAuth flow. Each inner array represents the path in the rootObject of the referenced field. For example. Assume the rootObject contains params 'app_secret', 'app_id' which are needed to get the initial refresh token. If they are not nested in the rootObject, then the array would look like this [['app_secret'], ['app_id']] If they are nested inside an object called 'auth_params' then this array would be [['auth_params', 'app_secret'], ['auth_params', 'app_id']] */
  oauthFlowInitParameters: string[][];
  /** Pointers to the fields in the rootObject which can be populated from successfully completing the oauth flow using the init parameters. This is typically a refresh/access token. Each inner array represents the path in the rootObject of the referenced field. */
  oauthFlowOutputParameters: string[][];
}

export type AuthSpecificationAuthType = "oauth2.0";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthSpecificationAuthType = {
  oauth20: "oauth2.0" as AuthSpecificationAuthType,
};

export interface AuthSpecification {
  auth_type?: AuthSpecificationAuthType;
  oauth2Specification?: OAuth2Specification;
}

export type SourceAuthSpecification = AuthSpecification;

/**
 * The specification for what values are required to configure the sourceDefinition.
 */
export interface SourceDefinitionSpecification {
  [key: string]: any;
}

export interface SourceDefinitionSpecificationRead {
  sourceDefinitionId: SourceDefinitionId;
  documentationUrl?: string;
  connectionSpecification?: SourceDefinitionSpecification;
  authSpecification?: SourceAuthSpecification;
  advancedAuth?: AdvancedAuth;
  jobInfo: SynchronousJobRead;
}

export interface PrivateSourceDefinitionRead {
  sourceDefinition: SourceDefinitionRead;
  granted: boolean;
}

export interface PrivateSourceDefinitionReadList {
  sourceDefinitions: PrivateSourceDefinitionRead[];
}

export interface CustomSourceDefinitionUpdate {
  workspaceId: WorkspaceId;
  sourceDefinition: SourceDefinitionUpdate;
}

export interface SourceDefinitionCreate {
  name: string;
  dockerRepository: string;
  dockerImageTag: string;
  documentationUrl: string;
  icon?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface CustomSourceDefinitionCreate {
  workspaceId: WorkspaceId;
  sourceDefinition: SourceDefinitionCreate;
}

export type SourceDefinitionId = string;

export interface SourceDefinitionIdWithWorkspaceId {
  sourceDefinitionId: SourceDefinitionId;
  workspaceId: WorkspaceId;
}

export interface SourceDefinitionRead {
  sourceDefinitionId: SourceDefinitionId;
  name: string;
  dockerRepository: string;
  dockerImageTag: string;
  documentationUrl?: string;
  icon?: string;
  releaseStage?: ReleaseStage;
  /** The date when this connector was first released, in yyyy-mm-dd format. */
  releaseDate?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface SourceDefinitionReadList {
  sourceDefinitions: SourceDefinitionRead[];
}

/**
 * Update the SourceDefinition. Currently, the only allowed attribute to update is the default docker image version.
 */
export interface SourceDefinitionUpdate {
  sourceDefinitionId: SourceDefinitionId;
  dockerImageTag: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface SourceDefinitionIdRequestBody {
  sourceDefinitionId: SourceDefinitionId;
}

export interface SlugRequestBody {
  slug: string;
}

export interface WebBackendWorkspaceStateResult {
  hasConnections: boolean;
  hasSources: boolean;
  hasDestinations: boolean;
}

export interface WebBackendWorkspaceState {
  workspaceId: WorkspaceId;
}

export interface WorkspaceGiveFeedback {
  workspaceId: WorkspaceId;
}

export interface WorkspaceUpdate {
  workspaceId: WorkspaceId;
  email?: string;
  initialSetupComplete: boolean;
  displaySetupWizard?: boolean;
  anonymousDataCollection: boolean;
  news: boolean;
  securityUpdates: boolean;
  notifications?: Notification[];
}

export interface WorkspaceUpdateName {
  workspaceId: WorkspaceId;
  name: string;
}

export interface WorkspaceRead {
  workspaceId: WorkspaceId;
  customerId: CustomerId;
  email?: string;
  name: string;
  slug: string;
  initialSetupComplete: boolean;
  displaySetupWizard?: boolean;
  anonymousDataCollection?: boolean;
  news?: boolean;
  securityUpdates?: boolean;
  notifications?: Notification[];
  firstCompletedSync?: boolean;
  feedbackDone?: boolean;
}

export interface WorkspaceReadList {
  workspaces: WorkspaceRead[];
}

export interface WorkspaceIdRequestBody {
  workspaceId: WorkspaceId;
}

export type NotificationReadStatus = "succeeded" | "failed";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationReadStatus = {
  succeeded: "succeeded" as NotificationReadStatus,
  failed: "failed" as NotificationReadStatus,
};

export interface NotificationRead {
  status: NotificationReadStatus;
  message?: string;
}

export type NotificationType = "slack" | "customerio";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationType = {
  slack: "slack" as NotificationType,
  customerio: "customerio" as NotificationType,
};

export interface CustomerioNotificationConfiguration {
  [key: string]: any;
}

export interface SlackNotificationConfiguration {
  webhook: string;
}

export interface Notification {
  notificationType: NotificationType;
  sendOnSuccess: boolean;
  sendOnFailure: boolean;
  slackConfiguration?: SlackNotificationConfiguration;
  customerioConfiguration?: CustomerioNotificationConfiguration;
}

export interface WorkspaceCreate {
  email?: string;
  anonymousDataCollection?: boolean;
  name: string;
  news?: boolean;
  securityUpdates?: boolean;
  notifications?: Notification[];
  displaySetupWizard?: boolean;
}

export type CustomerId = string;

export type WorkspaceId = string;

export interface WebBackendOperationCreateOrUpdate {
  operationId?: OperationId;
  workspaceId: WorkspaceId;
  name: string;
  operatorConfiguration: OperatorConfiguration;
}

export interface SourceSearch {
  sourceDefinitionId?: SourceDefinitionId;
  sourceId?: SourceId;
  workspaceId?: WorkspaceId;
  connectionConfiguration?: SourceConfiguration;
  name?: string;
  sourceName?: string;
}

/**
 * @summary Creates a workspace
 */
export const useCreateWorkspace = (workspaceCreate: WorkspaceCreate) => {
  return useApiOverride<WorkspaceRead>({
    url: `/v1/workspaces/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceCreate,
  });
};

/**
 * @summary Deletes a workspace
 */
export const useDeleteWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return useApiOverride<void>({
    url: `/v1/workspaces/delete`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary List all workspaces registered in the current Airbyte deployment
 */
export const useListWorkspaces = () => {
  return useApiOverride<WorkspaceReadList>({ url: `/v1/workspaces/list`, method: "post" });
};

/**
 * @summary Find workspace by ID
 */
export const useGetWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return useApiOverride<WorkspaceRead>({
    url: `/v1/workspaces/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary Find workspace by slug
 */
export const useGetWorkspaceBySlug = (slugRequestBody: SlugRequestBody) => {
  return useApiOverride<WorkspaceRead>({
    url: `/v1/workspaces/get_by_slug`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: slugRequestBody,
  });
};

/**
 * @summary Update workspace state
 */
export const useUpdateWorkspace = (workspaceUpdate: WorkspaceUpdate) => {
  return useApiOverride<WorkspaceRead>({
    url: `/v1/workspaces/update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceUpdate,
  });
};

/**
 * @summary Update workspace name
 */
export const useUpdateWorkspaceName = (workspaceUpdateName: WorkspaceUpdateName) => {
  return useApiOverride<WorkspaceRead>({
    url: `/v1/workspaces/update_name`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceUpdateName,
  });
};

/**
 * @summary Update workspace feedback state
 */
export const useUpdateWorkspaceFeedback = (workspaceGiveFeedback: WorkspaceGiveFeedback) => {
  return useApiOverride<void>({
    url: `/v1/workspaces/tag_feedback_status_as_done`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceGiveFeedback,
  });
};

/**
 * @summary Try sending a notifications
 */
export const useTryNotificationConfig = (notification: Notification) => {
  return useApiOverride<NotificationRead>({
    url: `/v1/notifications/try`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: notification,
  });
};

/**
 * @summary Creates a sourceDefinition
 */
export const useCreateSourceDefinition = (sourceDefinitionCreate: SourceDefinitionCreate) => {
  return useApiOverride<SourceDefinitionRead>({
    url: `/v1/source_definitions/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDefinitionCreate,
  });
};

/**
 * @summary Update a sourceDefinition
 */
export const useUpdateSourceDefinition = (sourceDefinitionUpdate: SourceDefinitionUpdate) => {
  return useApiOverride<SourceDefinitionRead>({
    url: `/v1/source_definitions/update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDefinitionUpdate,
  });
};

/**
 * @summary List all the sourceDefinitions the current Airbyte deployment is configured to use
 */
export const useListSourceDefinitions = () => {
  return useApiOverride<SourceDefinitionReadList>({ url: `/v1/source_definitions/list`, method: "post" });
};

/**
 * Guaranteed to retrieve the latest information on supported sources.
 * @summary List the latest sourceDefinitions Airbyte supports
 */
export const useListLatestSourceDefinitions = () => {
  return useApiOverride<SourceDefinitionReadList>({ url: `/v1/source_definitions/list_latest`, method: "post" });
};

/**
 * @summary Get source
 */
export const useGetSourceDefinition = (sourceDefinitionIdRequestBody: SourceDefinitionIdRequestBody) => {
  return useApiOverride<SourceDefinitionRead>({
    url: `/v1/source_definitions/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDefinitionIdRequestBody,
  });
};

/**
 * @summary Delete a source definition
 */
export const useDeleteSourceDefinition = (sourceDefinitionIdRequestBody: SourceDefinitionIdRequestBody) => {
  return useApiOverride<void>({
    url: `/v1/source_definitions/delete`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDefinitionIdRequestBody,
  });
};

/**
 * @summary List all private, non-custom sourceDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace's grants.
 */
export const useListPrivateSourceDefinitions = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return useApiOverride<PrivateSourceDefinitionReadList>({
    url: `/v1/source_definitions/list_private`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary List all the sourceDefinitions the given workspace is configured to use
 */
export const useListSourceDefinitionsForWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return useApiOverride<SourceDefinitionReadList>({
    url: `/v1/source_definitions/list_for_workspace`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary Creates a custom sourceDefinition for the given workspace
 */
export const useCreateCustomSourceDefinition = (customSourceDefinitionCreate: CustomSourceDefinitionCreate) => {
  return useApiOverride<SourceDefinitionRead>({
    url: `/v1/source_definitions/create_custom`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: customSourceDefinitionCreate,
  });
};

/**
 * @summary Get a sourceDefinition that is configured for the given workspace
 */
export const useGetSourceDefinitionForWorkspace = (
  sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId
) => {
  return useApiOverride<SourceDefinitionRead>({
    url: `/v1/source_definitions/get_for_workspace`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDefinitionIdWithWorkspaceId,
  });
};

/**
 * @summary Update a custom sourceDefinition for the given workspace
 */
export const useUpdateCustomSourceDefinition = (customSourceDefinitionUpdate: CustomSourceDefinitionUpdate) => {
  return useApiOverride<SourceDefinitionRead>({
    url: `/v1/source_definitions/update_custom`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: customSourceDefinitionUpdate,
  });
};

/**
 * @summary Delete a custom source definition for the given workspace
 */
export const useDeleteCustomSourceDefinition = (
  sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId
) => {
  return useApiOverride<void>({
    url: `/v1/source_definitions/delete_custom`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDefinitionIdWithWorkspaceId,
  });
};

/**
 * @summary grant a private, non-custom sourceDefinition to a given workspace
 */
export const useGrantSourceDefinitionToWorkspace = (
  sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId
) => {
  return useApiOverride<PrivateSourceDefinitionRead>({
    url: `/v1/source_definitions/grant_definition`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDefinitionIdWithWorkspaceId,
  });
};

/**
 * @summary revoke a grant to a private, non-custom sourceDefinition from a given workspace
 */
export const useRevokeSourceDefinitionFromWorkspace = (
  sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId
) => {
  return useApiOverride<void>({
    url: `/v1/source_definitions/revoke_definition`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDefinitionIdWithWorkspaceId,
  });
};

/**
 * @summary Get specification for a SourceDefinition.
 */
export const useGetSourceDefinitionSpecification = (sourceDefinitionIdRequestBody: SourceDefinitionIdRequestBody) => {
  return useApiOverride<SourceDefinitionSpecificationRead>({
    url: `/v1/source_definition_specifications/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDefinitionIdRequestBody,
  });
};

/**
 * @summary Create a source
 */
export const useCreateSource = (sourceCreate: SourceCreate) => {
  return useApiOverride<SourceRead>({
    url: `/v1/sources/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceCreate,
  });
};

/**
 * @summary Update a source
 */
export const useUpdateSource = (sourceUpdate: SourceUpdate) => {
  return useApiOverride<SourceRead>({
    url: `/v1/sources/update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceUpdate,
  });
};

/**
 * List sources for workspace. Does not return deleted sources.
 * @summary List sources for workspace
 */
export const useListSourcesForWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return useApiOverride<SourceReadList>({
    url: `/v1/sources/list`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary Get source
 */
export const useGetSource = (sourceIdRequestBody: SourceIdRequestBody) => {
  return useApiOverride<SourceRead>({
    url: `/v1/sources/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceIdRequestBody,
  });
};

/**
 * @summary Search sources
 */
export const useSearchSources = (sourceSearch: SourceSearch) => {
  return useApiOverride<SourceReadList>({
    url: `/v1/sources/search`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceSearch,
  });
};

/**
 * @summary Clone source
 */
export const useCloneSource = (sourceIdRequestBody: SourceIdRequestBody) => {
  return useApiOverride<SourceRead>({
    url: `/v1/sources/clone`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceIdRequestBody,
  });
};

/**
 * @summary Delete a source
 */
export const useDeleteSource = (sourceIdRequestBody: SourceIdRequestBody) => {
  return useApiOverride<void>({
    url: `/v1/sources/delete`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceIdRequestBody,
  });
};

/**
 * @summary Check connection to the source
 */
export const useCheckConnectionToSource = (sourceIdRequestBody: SourceIdRequestBody) => {
  return useApiOverride<CheckConnectionRead>({
    url: `/v1/sources/check_connection`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceIdRequestBody,
  });
};

/**
 * @summary Check connection for a proposed update to a source
 */
export const useCheckConnectionToSourceForUpdate = (sourceUpdate: SourceUpdate) => {
  return useApiOverride<CheckConnectionRead>({
    url: `/v1/sources/check_connection_for_update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceUpdate,
  });
};

/**
 * @summary Discover the schema catalog of the source
 */
export const useDiscoverSchemaForSource = (sourceDiscoverSchemaRequestBody: SourceDiscoverSchemaRequestBody) => {
  return useApiOverride<SourceDiscoverSchemaRead>({
    url: `/v1/sources/discover_schema`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDiscoverSchemaRequestBody,
  });
};

/**
 * @summary Creates a destinationsDefinition
 */
export const useCreateDestinationDefinition = (destinationDefinitionCreate: DestinationDefinitionCreate) => {
  return useApiOverride<DestinationDefinitionRead>({
    url: `/v1/destination_definitions/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationDefinitionCreate,
  });
};

/**
 * @summary Update destinationDefinition
 */
export const useUpdateDestinationDefinition = (destinationDefinitionUpdate: DestinationDefinitionUpdate) => {
  return useApiOverride<DestinationDefinitionRead>({
    url: `/v1/destination_definitions/update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationDefinitionUpdate,
  });
};

/**
 * @summary List all the destinationDefinitions the current Airbyte deployment is configured to use
 */
export const useListDestinationDefinitions = () => {
  return useApiOverride<DestinationDefinitionReadList>({ url: `/v1/destination_definitions/list`, method: "post" });
};

/**
 * Guaranteed to retrieve the latest information on supported destinations.
 * @summary List the latest destinationDefinitions Airbyte supports
 */
export const useListLatestDestinationDefinitions = () => {
  return useApiOverride<DestinationDefinitionReadList>({
    url: `/v1/destination_definitions/list_latest`,
    method: "post",
  });
};

/**
 * @summary Get destinationDefinition
 */
export const useGetDestinationDefinition = (destinationDefinitionIdRequestBody: DestinationDefinitionIdRequestBody) => {
  return useApiOverride<DestinationDefinitionRead>({
    url: `/v1/destination_definitions/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationDefinitionIdRequestBody,
  });
};

/**
 * @summary Delete a destination definition
 */
export const useDeleteDestinationDefinition = (
  destinationDefinitionIdRequestBody: DestinationDefinitionIdRequestBody
) => {
  return useApiOverride<void>({
    url: `/v1/destination_definitions/delete`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationDefinitionIdRequestBody,
  });
};

/**
 * @summary List all private, non-custom destinationDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace's grants.
 */
export const useListPrivateDestinationDefinitions = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return useApiOverride<PrivateDestinationDefinitionReadList>({
    url: `/v1/destination_definitions/list_private`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary List all the destinationDefinitions the given workspace is configured to use
 */
export const useListDestinationDefinitionsForWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return useApiOverride<DestinationDefinitionReadList>({
    url: `/v1/destination_definitions/list_for_workspace`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary Creates a custom destinationDefinition for the given workspace
 */
export const useCreateCustomDestinationDefinition = (
  customDestinationDefinitionCreate: CustomDestinationDefinitionCreate
) => {
  return useApiOverride<DestinationDefinitionRead>({
    url: `/v1/destination_definitions/create_custom`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: customDestinationDefinitionCreate,
  });
};

/**
 * @summary Get a destinationDefinition that is configured for the given workspace
 */
export const useGetDestinationDefinitionForWorkspace = (
  destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId
) => {
  return useApiOverride<DestinationDefinitionRead>({
    url: `/v1/destination_definitions/get_for_workspace`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationDefinitionIdWithWorkspaceId,
  });
};

/**
 * @summary Update a custom destinationDefinition for the given workspace
 */
export const useUpdateCustomDestinationDefinition = (
  customDestinationDefinitionUpdate: CustomDestinationDefinitionUpdate
) => {
  return useApiOverride<DestinationDefinitionRead>({
    url: `/v1/destination_definitions/update_custom`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: customDestinationDefinitionUpdate,
  });
};

/**
 * @summary Delete a custom destination definition for the given workspace
 */
export const useDeleteCustomDestinationDefinition = (
  destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId
) => {
  return useApiOverride<void>({
    url: `/v1/destination_definitions/delete_custom`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationDefinitionIdWithWorkspaceId,
  });
};

/**
 * @summary grant a private, non-custom destinationDefinition to a given workspace
 */
export const useGrantDestinationDefinitionToWorkspace = (
  destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId
) => {
  return useApiOverride<PrivateDestinationDefinitionRead>({
    url: `/v1/destination_definitions/grant_definition`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationDefinitionIdWithWorkspaceId,
  });
};

/**
 * @summary revoke a grant to a private, non-custom destinationDefinition from a given workspace
 */
export const useRevokeDestinationDefinitionFromWorkspace = (
  destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId
) => {
  return useApiOverride<void>({
    url: `/v1/destination_definitions/revoke_definition`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationDefinitionIdWithWorkspaceId,
  });
};

/**
 * @summary Get specification for a destinationDefinition
 */
export const useGetDestinationDefinitionSpecification = (
  destinationDefinitionIdRequestBody: DestinationDefinitionIdRequestBody
) => {
  return useApiOverride<DestinationDefinitionSpecificationRead>({
    url: `/v1/destination_definition_specifications/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationDefinitionIdRequestBody,
  });
};

/**
 * @summary Create a destination
 */
export const useCreateDestination = (destinationCreate: DestinationCreate) => {
  return useApiOverride<DestinationRead>({
    url: `/v1/destinations/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationCreate,
  });
};

/**
 * @summary Update a destination
 */
export const useUpdateDestination = (destinationUpdate: DestinationUpdate) => {
  return useApiOverride<DestinationRead>({
    url: `/v1/destinations/update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationUpdate,
  });
};

/**
 * @summary List configured destinations for a workspace
 */
export const useListDestinationsForWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return useApiOverride<DestinationReadList>({
    url: `/v1/destinations/list`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary Get configured destination
 */
export const useGetDestination = (destinationIdRequestBody: DestinationIdRequestBody) => {
  return useApiOverride<DestinationRead>({
    url: `/v1/destinations/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationIdRequestBody,
  });
};

/**
 * @summary Search destinations
 */
export const useSearchDestinations = (destinationSearch: DestinationSearch) => {
  return useApiOverride<DestinationReadList>({
    url: `/v1/destinations/search`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationSearch,
  });
};

/**
 * @summary Check connection to the destination
 */
export const useCheckConnectionToDestination = (destinationIdRequestBody: DestinationIdRequestBody) => {
  return useApiOverride<CheckConnectionRead>({
    url: `/v1/destinations/check_connection`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationIdRequestBody,
  });
};

/**
 * @summary Check connection for a proposed update to a destination
 */
export const useCheckConnectionToDestinationForUpdate = (destinationUpdate: DestinationUpdate) => {
  return useApiOverride<CheckConnectionRead>({
    url: `/v1/destinations/check_connection_for_update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationUpdate,
  });
};

/**
 * @summary Delete the destination
 */
export const useDeleteDestination = (destinationIdRequestBody: DestinationIdRequestBody) => {
  return useApiOverride<void>({
    url: `/v1/destinations/delete`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationIdRequestBody,
  });
};

/**
 * @summary Clone destination
 */
export const useCloneDestination = (destinationIdRequestBody: DestinationIdRequestBody) => {
  return useApiOverride<DestinationRead>({
    url: `/v1/destinations/clone`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationIdRequestBody,
  });
};

/**
 * @summary Create a connection between a source and a destination
 */
export const useCreateConnection = (connectionCreate: ConnectionCreate) => {
  return useApiOverride<ConnectionRead>({
    url: `/v1/connections/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: connectionCreate,
  });
};

/**
 * @summary Update a connection
 */
export const useUpdateConnection = (connectionUpdate: ConnectionUpdate) => {
  return useApiOverride<ConnectionRead>({
    url: `/v1/connections/update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: connectionUpdate,
  });
};

/**
 * List connections for workspace. Does not return deleted connections.
 * @summary Returns all connections for a workspace.
 */
export const useListConnectionsForWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return useApiOverride<ConnectionReadList>({
    url: `/v1/connections/list`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * List connections for workspace, including deleted connections.
 * @summary Returns all connections for a workspace, including deleted connections.
 */
export const useListAllConnectionsForWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return useApiOverride<ConnectionReadList>({
    url: `/v1/connections/list_all`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary Get a connection
 */
export const useGetConnection = (connectionIdRequestBody: ConnectionIdRequestBody) => {
  return useApiOverride<ConnectionRead>({
    url: `/v1/connections/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: connectionIdRequestBody,
  });
};

/**
 * @summary Fetch the current state for a connection.
 */
export const useGetState = (connectionIdRequestBody: ConnectionIdRequestBody) => {
  return useApiOverride<ConnectionState>({
    url: `/v1/state/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: connectionIdRequestBody,
  });
};

/**
 * @summary Search connections
 */
export const useSearchConnections = (connectionSearch: ConnectionSearch) => {
  return useApiOverride<ConnectionReadList>({
    url: `/v1/connections/search`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: connectionSearch,
  });
};

/**
 * @summary Delete a connection
 */
export const useDeleteConnection = (connectionIdRequestBody: ConnectionIdRequestBody) => {
  return useApiOverride<void>({
    url: `/v1/connections/delete`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: connectionIdRequestBody,
  });
};

/**
 * @summary Trigger a manual sync of the connection
 */
export const useSyncConnection = (connectionIdRequestBody: ConnectionIdRequestBody) => {
  return useApiOverride<JobInfoRead>({
    url: `/v1/connections/sync`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: connectionIdRequestBody,
  });
};

/**
 * @summary Reset the data for the connection. Deletes data generated by the connection in the destination. Resets any cursors back to initial state.
 */
export const useResetConnection = (connectionIdRequestBody: ConnectionIdRequestBody) => {
  return useApiOverride<JobInfoRead>({
    url: `/v1/connections/reset`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: connectionIdRequestBody,
  });
};

/**
 * @summary Check if an operation to be created is valid
 */
export const useCheckOperation = (operatorConfiguration: OperatorConfiguration) => {
  return useApiOverride<CheckOperationRead>({
    url: `/v1/operations/check`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: operatorConfiguration,
  });
};

/**
 * @summary Create an operation to be applied as part of a connection pipeline
 */
export const useCreateOperation = (operationCreate: OperationCreate) => {
  return useApiOverride<OperationRead>({
    url: `/v1/operations/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: operationCreate,
  });
};

/**
 * @summary Update an operation
 */
export const useUpdateOperation = (operationUpdate: OperationUpdate) => {
  return useApiOverride<OperationRead>({
    url: `/v1/operations/update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: operationUpdate,
  });
};

/**
 * List operations for connection.
 * @summary Returns all operations for a connection.
 */
export const useListOperationsForConnection = (connectionIdRequestBody: ConnectionIdRequestBody) => {
  return useApiOverride<OperationReadList>({
    url: `/v1/operations/list`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: connectionIdRequestBody,
  });
};

/**
 * @summary Returns an operation
 */
export const useGetOperation = (operationIdRequestBody: OperationIdRequestBody) => {
  return useApiOverride<OperationRead>({
    url: `/v1/operations/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: operationIdRequestBody,
  });
};

/**
 * @summary Delete an operation
 */
export const useDeleteOperation = (operationIdRequestBody: OperationIdRequestBody) => {
  return useApiOverride<void>({
    url: `/v1/operations/delete`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: operationIdRequestBody,
  });
};

/**
 * @summary Run check connection for a given source configuration
 */
export const useExecuteSourceCheckConnection = (sourceCoreConfig: SourceCoreConfig) => {
  return useApiOverride<CheckConnectionRead>({
    url: `/v1/scheduler/sources/check_connection`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceCoreConfig,
  });
};

/**
 * @summary Run discover schema for a given source a source configuration
 */
export const useExecuteSourceDiscoverSchema = (sourceCoreConfig: SourceCoreConfig) => {
  return useApiOverride<SourceDiscoverSchemaRead>({
    url: `/v1/scheduler/sources/discover_schema`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceCoreConfig,
  });
};

/**
 * @summary Run check connection for a given destination configuration
 */
export const useExecuteDestinationCheckConnection = (destinationCoreConfig: DestinationCoreConfig) => {
  return useApiOverride<CheckConnectionRead>({
    url: `/v1/scheduler/destinations/check_connection`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationCoreConfig,
  });
};

/**
 * @summary List all database migrations
 */
export const useListMigrations = (dbMigrationRequestBody: DbMigrationRequestBody) => {
  return useApiOverride<DbMigrationReadList>({
    url: `/v1/db_migrations/list`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: dbMigrationRequestBody,
  });
};

/**
 * @summary Migrate the database to the latest version
 */
export const useExecuteMigrations = (dbMigrationRequestBody: DbMigrationRequestBody) => {
  return useApiOverride<DbMigrationExecutionRead>({
    url: `/v1/db_migrations/migrate`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: dbMigrationRequestBody,
  });
};

/**
 * @summary Sets instancewide variables to be used for the oauth flow when creating this source. When set, these variables will be injected into a connector's configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company's Google Ads developer_token, client_id, and client_secret without the user having to know about these variables.

 */
export const useSetInstancewideSourceOauthParams = (
  setInstancewideSourceOauthParamsRequestBody: SetInstancewideSourceOauthParamsRequestBody
) => {
  return useApiOverride<void>({
    url: `/v1/source_oauths/oauth_params/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: setInstancewideSourceOauthParamsRequestBody,
  });
};

/**
 * @summary Given a source connector definition ID, return the URL to the consent screen where to redirect the user to.
 */
export const useGetSourceOAuthConsent = (sourceOauthConsentRequest: SourceOauthConsentRequest) => {
  return useApiOverride<OAuthConsentRead>({
    url: `/v1/source_oauths/get_consent_url`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceOauthConsentRequest,
  });
};

/**
 * @summary Given a source def ID generate an access/refresh token etc.
 */
export const useCompleteSourceOAuth = (completeSourceOauthRequest: CompleteSourceOauthRequest) => {
  return useApiOverride<CompleteOAuthResponse>({
    url: `/v1/source_oauths/complete_oauth`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: completeSourceOauthRequest,
  });
};

/**
 * @summary Given a destination connector definition ID, return the URL to the consent screen where to redirect the user to.
 */
export const useGetDestinationOAuthConsent = (destinationOauthConsentRequest: DestinationOauthConsentRequest) => {
  return useApiOverride<OAuthConsentRead>({
    url: `/v1/destination_oauths/get_consent_url`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationOauthConsentRequest,
  });
};

/**
 * @summary Given a destination def ID generate an access/refresh token etc.
 */
export const useCompleteDestinationOAuth = (completeDestinationOAuthRequest: CompleteDestinationOAuthRequest) => {
  return useApiOverride<CompleteOAuthResponse>({
    url: `/v1/destination_oauths/complete_oauth`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: completeDestinationOAuthRequest,
  });
};

/**
 * @summary Sets instancewide variables to be used for the oauth flow when creating this destination. When set, these variables will be injected into a connector's configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company's Google Ads developer_token, client_id, and client_secret without the user having to know about these variables.

 */
export const useSetInstancewideDestinationOauthParams = (
  setInstancewideDestinationOauthParamsRequestBody: SetInstancewideDestinationOauthParamsRequestBody
) => {
  return useApiOverride<void>({
    url: `/v1/destination_oauths/oauth_params/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: setInstancewideDestinationOauthParamsRequestBody,
  });
};

/**
 * @summary Returns all non-deleted connections for a workspace.
 */
export const useWebBackendListConnectionsForWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return useApiOverride<WebBackendConnectionReadList>({
    url: `/v1/web_backend/connections/list`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary Returns all connections for a workspace.
 */
export const useWebBackendListAllConnectionsForWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return useApiOverride<WebBackendConnectionReadList>({
    url: `/v1/web_backend/connections/list_all`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary Get a connection
 */
export const useWebBackendGetConnection = (webBackendConnectionRequestBody: WebBackendConnectionRequestBody) => {
  return useApiOverride<WebBackendConnectionRead>({
    url: `/v1/web_backend/connections/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: webBackendConnectionRequestBody,
  });
};

/**
 * @summary Create a connection
 */
export const useWebBackendCreateConnection = (webBackendConnectionCreate: WebBackendConnectionCreate) => {
  return useApiOverride<WebBackendConnectionRead>({
    url: `/v1/web_backend/connections/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: webBackendConnectionCreate,
  });
};

/**
 * @summary Update a connection
 */
export const useWebBackendUpdateConnection = (webBackendConnectionUpdate: WebBackendConnectionUpdate) => {
  return useApiOverride<WebBackendConnectionRead>({
    url: `/v1/web_backend/connections/update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: webBackendConnectionUpdate,
  });
};

/**
 * @summary Search connections
 */
export const useWebBackendSearchConnections = (webBackendConnectionSearch: WebBackendConnectionSearch) => {
  return useApiOverride<WebBackendConnectionReadList>({
    url: `/v1/web_backend/connections/search`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: webBackendConnectionSearch,
  });
};

/**
 * @summary Returns the current state of a workspace
 */
export const useWebBackendGetWorkspaceState = (webBackendWorkspaceState: WebBackendWorkspaceState) => {
  return useApiOverride<WebBackendWorkspaceStateResult>({
    url: `/v1/web_backend/workspace/state`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: webBackendWorkspaceState,
  });
};

/**
 * @summary Returns recent jobs for a connection. Jobs are returned in descending order by createdAt.
 */
export const useListJobsFor = (jobListRequestBody: JobListRequestBody) => {
  return useApiOverride<JobReadList>({
    url: `/v1/jobs/list`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: jobListRequestBody,
  });
};

/**
 * @summary Get information about a job
 */
export const useGetJobInfo = (jobIdRequestBody: JobIdRequestBody) => {
  return useApiOverride<JobInfoRead>({
    url: `/v1/jobs/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: jobIdRequestBody,
  });
};

/**
 * @summary Cancels a job
 */
export const useCancelJob = (jobIdRequestBody: JobIdRequestBody) => {
  return useApiOverride<JobInfoRead>({
    url: `/v1/jobs/cancel`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: jobIdRequestBody,
  });
};

/**
 * @summary Gets all information needed to debug this job
 */
export const useGetJobDebugInfo = (jobIdRequestBody: JobIdRequestBody) => {
  return useApiOverride<JobDebugInfoRead>({
    url: `/v1/jobs/get_debug_info`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: jobIdRequestBody,
  });
};

/**
 * @summary Health Check
 */
export const useGetHealthCheck = () => {
  return useApiOverride<HealthCheckRead>({ url: `/v1/health`, method: "get" });
};

/**
 * @summary Get logs
 */
export const useGetLogs = (logsRequestBody: LogsRequestBody) => {
  return useApiOverride<Blob>({
    url: `/v1/logs/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: logsRequestBody,
    responseType: "blob",
  });
};

/**
 * @summary Returns the openapi specification
 */
export const useGetOpenApiSpec = () => {
  return useApiOverride<Blob>({ url: `/v1/openapi`, method: "get", responseType: "blob" });
};

/**
 * @summary Export Airbyte Configuration and Data Archive
 */
export const useExportArchive = () => {
  return useApiOverride<AirbyteArchive>({ url: `/v1/deployment/export`, method: "post" });
};

/**
 * @summary Import Airbyte Configuration and Data Archive
 */
export const useImportArchive = (airbyteArchive: AirbyteArchive) => {
  return useApiOverride<ImportRead>({
    url: `/v1/deployment/import`,
    method: "post",
    headers: { "Content-Type": "application/x-gzip" },
    data: airbyteArchive,
  });
};

/**
 * @summary Export Airbyte Workspace Configuration
 */
export const useExportWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return useApiOverride<AirbyteArchive>({
    url: `/v1/deployment/export_workspace`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary Upload a GZIP archive tarball and stage it in the server's cache as a temporary resource
 */
export const useUploadArchiveResource = (airbyteArchive: AirbyteArchive) => {
  return useApiOverride<UploadRead>({
    url: `/v1/deployment/upload_archive_resource`,
    method: "post",
    headers: { "Content-Type": "application/x-gzip" },
    data: airbyteArchive,
  });
};

/**
 * @summary Import Airbyte Configuration into Workspace (this operation might change ids of imported configurations). Note, in order to use this api endpoint, you might need to upload a temporary archive resource with 'deployment/upload_archive_resource' first

 */
export const useImportIntoWorkspace = (importRequestBody: ImportRequestBody) => {
  return useApiOverride<ImportRead>({
    url: `/v1/deployment/import_into_workspace`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: importRequestBody,
  });
};

export type UseCreateWorkspaceResult = NonNullable<Awaited<ReturnType<typeof useCreateWorkspace>>>;
export type UseDeleteWorkspaceResult = NonNullable<Awaited<ReturnType<typeof useDeleteWorkspace>>>;
export type UseListWorkspacesResult = NonNullable<Awaited<ReturnType<typeof useListWorkspaces>>>;
export type UseGetWorkspaceResult = NonNullable<Awaited<ReturnType<typeof useGetWorkspace>>>;
export type UseGetWorkspaceBySlugResult = NonNullable<Awaited<ReturnType<typeof useGetWorkspaceBySlug>>>;
export type UseUpdateWorkspaceResult = NonNullable<Awaited<ReturnType<typeof useUpdateWorkspace>>>;
export type UseUpdateWorkspaceNameResult = NonNullable<Awaited<ReturnType<typeof useUpdateWorkspaceName>>>;
export type UseUpdateWorkspaceFeedbackResult = NonNullable<Awaited<ReturnType<typeof useUpdateWorkspaceFeedback>>>;
export type UseTryNotificationConfigResult = NonNullable<Awaited<ReturnType<typeof useTryNotificationConfig>>>;
export type UseCreateSourceDefinitionResult = NonNullable<Awaited<ReturnType<typeof useCreateSourceDefinition>>>;
export type UseUpdateSourceDefinitionResult = NonNullable<Awaited<ReturnType<typeof useUpdateSourceDefinition>>>;
export type UseListSourceDefinitionsResult = NonNullable<Awaited<ReturnType<typeof useListSourceDefinitions>>>;
export type UseListLatestSourceDefinitionsResult = NonNullable<
  Awaited<ReturnType<typeof useListLatestSourceDefinitions>>
>;
export type UseGetSourceDefinitionResult = NonNullable<Awaited<ReturnType<typeof useGetSourceDefinition>>>;
export type UseDeleteSourceDefinitionResult = NonNullable<Awaited<ReturnType<typeof useDeleteSourceDefinition>>>;
export type UseListPrivateSourceDefinitionsResult = NonNullable<
  Awaited<ReturnType<typeof useListPrivateSourceDefinitions>>
>;
export type UseListSourceDefinitionsForWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof useListSourceDefinitionsForWorkspace>>
>;
export type UseCreateCustomSourceDefinitionResult = NonNullable<
  Awaited<ReturnType<typeof useCreateCustomSourceDefinition>>
>;
export type UseGetSourceDefinitionForWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof useGetSourceDefinitionForWorkspace>>
>;
export type UseUpdateCustomSourceDefinitionResult = NonNullable<
  Awaited<ReturnType<typeof useUpdateCustomSourceDefinition>>
>;
export type UseDeleteCustomSourceDefinitionResult = NonNullable<
  Awaited<ReturnType<typeof useDeleteCustomSourceDefinition>>
>;
export type UseGrantSourceDefinitionToWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof useGrantSourceDefinitionToWorkspace>>
>;
export type UseRevokeSourceDefinitionFromWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof useRevokeSourceDefinitionFromWorkspace>>
>;
export type UseGetSourceDefinitionSpecificationResult = NonNullable<
  Awaited<ReturnType<typeof useGetSourceDefinitionSpecification>>
>;
export type UseCreateSourceResult = NonNullable<Awaited<ReturnType<typeof useCreateSource>>>;
export type UseUpdateSourceResult = NonNullable<Awaited<ReturnType<typeof useUpdateSource>>>;
export type UseListSourcesForWorkspaceResult = NonNullable<Awaited<ReturnType<typeof useListSourcesForWorkspace>>>;
export type UseGetSourceResult = NonNullable<Awaited<ReturnType<typeof useGetSource>>>;
export type UseSearchSourcesResult = NonNullable<Awaited<ReturnType<typeof useSearchSources>>>;
export type UseCloneSourceResult = NonNullable<Awaited<ReturnType<typeof useCloneSource>>>;
export type UseDeleteSourceResult = NonNullable<Awaited<ReturnType<typeof useDeleteSource>>>;
export type UseCheckConnectionToSourceResult = NonNullable<Awaited<ReturnType<typeof useCheckConnectionToSource>>>;
export type UseCheckConnectionToSourceForUpdateResult = NonNullable<
  Awaited<ReturnType<typeof useCheckConnectionToSourceForUpdate>>
>;
export type UseDiscoverSchemaForSourceResult = NonNullable<Awaited<ReturnType<typeof useDiscoverSchemaForSource>>>;
export type UseCreateDestinationDefinitionResult = NonNullable<
  Awaited<ReturnType<typeof useCreateDestinationDefinition>>
>;
export type UseUpdateDestinationDefinitionResult = NonNullable<
  Awaited<ReturnType<typeof useUpdateDestinationDefinition>>
>;
export type UseListDestinationDefinitionsResult = NonNullable<
  Awaited<ReturnType<typeof useListDestinationDefinitions>>
>;
export type UseListLatestDestinationDefinitionsResult = NonNullable<
  Awaited<ReturnType<typeof useListLatestDestinationDefinitions>>
>;
export type UseGetDestinationDefinitionResult = NonNullable<Awaited<ReturnType<typeof useGetDestinationDefinition>>>;
export type UseDeleteDestinationDefinitionResult = NonNullable<
  Awaited<ReturnType<typeof useDeleteDestinationDefinition>>
>;
export type UseListPrivateDestinationDefinitionsResult = NonNullable<
  Awaited<ReturnType<typeof useListPrivateDestinationDefinitions>>
>;
export type UseListDestinationDefinitionsForWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof useListDestinationDefinitionsForWorkspace>>
>;
export type UseCreateCustomDestinationDefinitionResult = NonNullable<
  Awaited<ReturnType<typeof useCreateCustomDestinationDefinition>>
>;
export type UseGetDestinationDefinitionForWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof useGetDestinationDefinitionForWorkspace>>
>;
export type UseUpdateCustomDestinationDefinitionResult = NonNullable<
  Awaited<ReturnType<typeof useUpdateCustomDestinationDefinition>>
>;
export type UseDeleteCustomDestinationDefinitionResult = NonNullable<
  Awaited<ReturnType<typeof useDeleteCustomDestinationDefinition>>
>;
export type UseGrantDestinationDefinitionToWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof useGrantDestinationDefinitionToWorkspace>>
>;
export type UseRevokeDestinationDefinitionFromWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof useRevokeDestinationDefinitionFromWorkspace>>
>;
export type UseGetDestinationDefinitionSpecificationResult = NonNullable<
  Awaited<ReturnType<typeof useGetDestinationDefinitionSpecification>>
>;
export type UseCreateDestinationResult = NonNullable<Awaited<ReturnType<typeof useCreateDestination>>>;
export type UseUpdateDestinationResult = NonNullable<Awaited<ReturnType<typeof useUpdateDestination>>>;
export type UseListDestinationsForWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof useListDestinationsForWorkspace>>
>;
export type UseGetDestinationResult = NonNullable<Awaited<ReturnType<typeof useGetDestination>>>;
export type UseSearchDestinationsResult = NonNullable<Awaited<ReturnType<typeof useSearchDestinations>>>;
export type UseCheckConnectionToDestinationResult = NonNullable<
  Awaited<ReturnType<typeof useCheckConnectionToDestination>>
>;
export type UseCheckConnectionToDestinationForUpdateResult = NonNullable<
  Awaited<ReturnType<typeof useCheckConnectionToDestinationForUpdate>>
>;
export type UseDeleteDestinationResult = NonNullable<Awaited<ReturnType<typeof useDeleteDestination>>>;
export type UseCloneDestinationResult = NonNullable<Awaited<ReturnType<typeof useCloneDestination>>>;
export type UseCreateConnectionResult = NonNullable<Awaited<ReturnType<typeof useCreateConnection>>>;
export type UseUpdateConnectionResult = NonNullable<Awaited<ReturnType<typeof useUpdateConnection>>>;
export type UseListConnectionsForWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof useListConnectionsForWorkspace>>
>;
export type UseListAllConnectionsForWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof useListAllConnectionsForWorkspace>>
>;
export type UseGetConnectionResult = NonNullable<Awaited<ReturnType<typeof useGetConnection>>>;
export type UseGetStateResult = NonNullable<Awaited<ReturnType<typeof useGetState>>>;
export type UseSearchConnectionsResult = NonNullable<Awaited<ReturnType<typeof useSearchConnections>>>;
export type UseDeleteConnectionResult = NonNullable<Awaited<ReturnType<typeof useDeleteConnection>>>;
export type UseSyncConnectionResult = NonNullable<Awaited<ReturnType<typeof useSyncConnection>>>;
export type UseResetConnectionResult = NonNullable<Awaited<ReturnType<typeof useResetConnection>>>;
export type UseCheckOperationResult = NonNullable<Awaited<ReturnType<typeof useCheckOperation>>>;
export type UseCreateOperationResult = NonNullable<Awaited<ReturnType<typeof useCreateOperation>>>;
export type UseUpdateOperationResult = NonNullable<Awaited<ReturnType<typeof useUpdateOperation>>>;
export type UseListOperationsForConnectionResult = NonNullable<
  Awaited<ReturnType<typeof useListOperationsForConnection>>
>;
export type UseGetOperationResult = NonNullable<Awaited<ReturnType<typeof useGetOperation>>>;
export type UseDeleteOperationResult = NonNullable<Awaited<ReturnType<typeof useDeleteOperation>>>;
export type UseExecuteSourceCheckConnectionResult = NonNullable<
  Awaited<ReturnType<typeof useExecuteSourceCheckConnection>>
>;
export type UseExecuteSourceDiscoverSchemaResult = NonNullable<
  Awaited<ReturnType<typeof useExecuteSourceDiscoverSchema>>
>;
export type UseExecuteDestinationCheckConnectionResult = NonNullable<
  Awaited<ReturnType<typeof useExecuteDestinationCheckConnection>>
>;
export type UseListMigrationsResult = NonNullable<Awaited<ReturnType<typeof useListMigrations>>>;
export type UseExecuteMigrationsResult = NonNullable<Awaited<ReturnType<typeof useExecuteMigrations>>>;
export type UseSetInstancewideSourceOauthParamsResult = NonNullable<
  Awaited<ReturnType<typeof useSetInstancewideSourceOauthParams>>
>;
export type UseGetSourceOAuthConsentResult = NonNullable<Awaited<ReturnType<typeof useGetSourceOAuthConsent>>>;
export type UseCompleteSourceOAuthResult = NonNullable<Awaited<ReturnType<typeof useCompleteSourceOAuth>>>;
export type UseGetDestinationOAuthConsentResult = NonNullable<
  Awaited<ReturnType<typeof useGetDestinationOAuthConsent>>
>;
export type UseCompleteDestinationOAuthResult = NonNullable<Awaited<ReturnType<typeof useCompleteDestinationOAuth>>>;
export type UseSetInstancewideDestinationOauthParamsResult = NonNullable<
  Awaited<ReturnType<typeof useSetInstancewideDestinationOauthParams>>
>;
export type UseWebBackendListConnectionsForWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof useWebBackendListConnectionsForWorkspace>>
>;
export type UseWebBackendListAllConnectionsForWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof useWebBackendListAllConnectionsForWorkspace>>
>;
export type UseWebBackendGetConnectionResult = NonNullable<Awaited<ReturnType<typeof useWebBackendGetConnection>>>;
export type UseWebBackendCreateConnectionResult = NonNullable<
  Awaited<ReturnType<typeof useWebBackendCreateConnection>>
>;
export type UseWebBackendUpdateConnectionResult = NonNullable<
  Awaited<ReturnType<typeof useWebBackendUpdateConnection>>
>;
export type UseWebBackendSearchConnectionsResult = NonNullable<
  Awaited<ReturnType<typeof useWebBackendSearchConnections>>
>;
export type UseWebBackendGetWorkspaceStateResult = NonNullable<
  Awaited<ReturnType<typeof useWebBackendGetWorkspaceState>>
>;
export type UseListJobsForResult = NonNullable<Awaited<ReturnType<typeof useListJobsFor>>>;
export type UseGetJobInfoResult = NonNullable<Awaited<ReturnType<typeof useGetJobInfo>>>;
export type UseCancelJobResult = NonNullable<Awaited<ReturnType<typeof useCancelJob>>>;
export type UseGetJobDebugInfoResult = NonNullable<Awaited<ReturnType<typeof useGetJobDebugInfo>>>;
export type UseGetHealthCheckResult = NonNullable<Awaited<ReturnType<typeof useGetHealthCheck>>>;
export type UseGetLogsResult = NonNullable<Awaited<ReturnType<typeof useGetLogs>>>;
export type UseGetOpenApiSpecResult = NonNullable<Awaited<ReturnType<typeof useGetOpenApiSpec>>>;
export type UseExportArchiveResult = NonNullable<Awaited<ReturnType<typeof useExportArchive>>>;
export type UseImportArchiveResult = NonNullable<Awaited<ReturnType<typeof useImportArchive>>>;
export type UseExportWorkspaceResult = NonNullable<Awaited<ReturnType<typeof useExportWorkspace>>>;
export type UseUploadArchiveResourceResult = NonNullable<Awaited<ReturnType<typeof useUploadArchiveResource>>>;
export type UseImportIntoWorkspaceResult = NonNullable<Awaited<ReturnType<typeof useImportIntoWorkspace>>>;
