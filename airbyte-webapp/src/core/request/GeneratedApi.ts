/**
 * Generated by orval v6.7.1 ğŸº
 * Do not edit manually.
 * Airbyte Configuration API
 * Airbyte Configuration API
[https://airbyte.io](https://airbyte.io).

This API is a collection of HTTP RPC-style methods. While it is not a REST API, those familiar with REST should find the conventions of this API recognizable.

Here are some conventions that this API follows:
* All endpoints are http POST methods.
* All endpoints accept data via `application/json` request bodies. The API does not accept any data via query params.
* The naming convention for endpoints is: localhost:8000/{VERSION}/{METHOD_FAMILY}/{METHOD_NAME} e.g. `localhost:8000/v1/connections/create`.
* For all `update` methods, the whole object must be passed in, even the fields that did not change.

Change Management:
* The major version of the API endpoint can be determined / specified in the URL `localhost:8080/v1/connections/create`
* Minor version bumps will be invisible to the end user. The user cannot specify minor versions in requests.
* All backwards incompatible changes will happen in major version bumps. We will not make backwards incompatible changes in minor version bumps. Examples of non-breaking changes (includes but not limited to...):
  * Adding fields to request or response bodies.
  * Adding new HTTP endpoints.
* All `web_backend` APIs are not considered public APIs and are not guaranteeing backwards compatibility.

 * OpenAPI spec version: 1.0.0
 */
import { req } from "./UseApiOverride";
/**
 * Input failed validation
 */
export type InvalidInputResponseResponse = InvalidInputExceptionInfo;

export interface KnownExceptionInfo {
  message: string;
  exceptionClassName?: string;
  exceptionStack?: string[];
  rootCauseExceptionClassName?: string;
  rootCauseExceptionStack?: string[];
}

/**
 * Exception occurred; see message for details.
 */
export type ExceptionResponseResponse = KnownExceptionInfo;

export interface NotFoundKnownExceptionInfo {
  id?: string;
  message: string;
  exceptionClassName?: string;
  exceptionStack?: string[];
  rootCauseExceptionClassName?: string;
  rootCauseExceptionStack?: string[];
}

/**
 * Object with given id was not found.
 */
export type NotFoundResponseResponse = NotFoundKnownExceptionInfo;

export interface InvalidInputProperty {
  propertyPath: string;
  invalidValue?: string;
  message?: string;
}

export interface InvalidInputExceptionInfo {
  message: string;
  exceptionClassName?: string;
  exceptionStack?: string[];
  validationErrors: InvalidInputProperty[];
}

export type UploadReadStatus = "succeeded" | "failed";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UploadReadStatus = {
  succeeded: "succeeded" as UploadReadStatus,
  failed: "failed" as UploadReadStatus,
};

export type ResourceId = string;

export interface ImportRequestBody {
  resourceId: ResourceId;
  workspaceId: WorkspaceId;
}

export interface UploadRead {
  status: UploadReadStatus;
  resourceId?: ResourceId;
}

export type ImportReadStatus = "succeeded" | "failed";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ImportReadStatus = {
  succeeded: "succeeded" as ImportReadStatus,
  failed: "failed" as ImportReadStatus,
};

export interface ImportRead {
  status: ImportReadStatus;
  reason?: string;
}

/**
 * Tarball Archive (.tar.gz) of Airbyte Configuration and Database
 */
export type AirbyteArchive = Blob;

export type DestinationSyncMode = "append" | "overwrite" | "append_dedup";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DestinationSyncMode = {
  append: "append" as DestinationSyncMode,
  overwrite: "overwrite" as DestinationSyncMode,
  append_dedup: "append_dedup" as DestinationSyncMode,
};

export type SyncMode = "full_refresh" | "incremental";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SyncMode = {
  full_refresh: "full_refresh" as SyncMode,
  incremental: "incremental" as SyncMode,
};

export interface WebBackendConnectionRead {
  connectionId: ConnectionId;
  name: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId: SourceId;
  destinationId: DestinationId;
  syncCatalog: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  operationIds?: OperationId[];
  source: SourceRead;
  destination: DestinationRead;
  operations?: OperationRead[];
  /** epoch time of the latest sync job. null if no sync job has taken place. */
  latestSyncJobCreatedAt?: number;
  latestSyncJobStatus?: JobStatus;
  isSyncing: boolean;
  resourceRequirements?: ResourceRequirements;
}

export interface WebBackendConnectionReadList {
  connections: WebBackendConnectionRead[];
}

export type SetInstancewideDestinationOauthParamsRequestBodyParams = { [key: string]: any };

export interface SetInstancewideDestinationOauthParamsRequestBody {
  destinationDefinitionId: DestinationDefinitionId;
  params: SetInstancewideDestinationOauthParamsRequestBodyParams;
}

export type SetInstancewideSourceOauthParamsRequestBodyParams = { [key: string]: any };

export interface SetInstancewideSourceOauthParamsRequestBody {
  sourceDefinitionId: SourceDefinitionId;
  params: SetInstancewideSourceOauthParamsRequestBodyParams;
}

export interface CompleteOAuthResponse {
  [key: string]: any;
}

/**
 * The query parameters present in the redirect URL after a user granted consent e.g auth code
 */
export type CompleteDestinationOAuthRequestQueryParams = { [key: string]: any };

/**
 * The query parameters present in the redirect URL after a user granted consent e.g auth code
 */
export type CompleteSourceOauthRequestQueryParams = { [key: string]: any };

export interface CompleteSourceOauthRequest {
  sourceDefinitionId: SourceDefinitionId;
  workspaceId: WorkspaceId;
  /** When completing OAuth flow to gain an access token, some API sometimes requires to verify that the app re-send the redirectUrl that was used when consent was given. */
  redirectUrl?: string;
  /** The query parameters present in the redirect URL after a user granted consent e.g auth code */
  queryParams?: CompleteSourceOauthRequestQueryParams;
  oAuthInputConfiguration?: OAuthInputConfiguration;
}

export interface OAuthConsentRead {
  consentUrl: string;
}

export interface DestinationOauthConsentRequest {
  destinationDefinitionId: DestinationDefinitionId;
  workspaceId: WorkspaceId;
  /** The url to redirect to after getting the user consent */
  redirectUrl: string;
  oAuthInputConfiguration?: OAuthInputConfiguration;
}

export interface SourceOauthConsentRequest {
  sourceDefinitionId: SourceDefinitionId;
  workspaceId: WorkspaceId;
  /** The url to redirect to after getting the user consent */
  redirectUrl: string;
  oAuthInputConfiguration?: OAuthInputConfiguration;
}

export interface OAuthConfigSpecification {
  /** OAuth specific blob. This is a Json Schema used to validate Json configurations used as input to OAuth.
Must be a valid non-nested JSON that refers to properties from ConnectorSpecification.connectionSpecification
using special annotation 'path_in_connector_config'.
These are input values the user is entering through the UI to authenticate to the connector, that might also shared
as inputs for syncing data via the connector.

Examples:

if no connector values is shared during oauth flow, oauth_user_input_from_connector_config_specification=[]
if connector values such as 'app_id' inside the top level are used to generate the API url for the oauth flow,
  oauth_user_input_from_connector_config_specification={
    app_id: {
      type: string
      path_in_connector_config: ['app_id']
    }
  }
if connector values such as 'info.app_id' nested inside another object are used to generate the API url for the oauth flow,
  oauth_user_input_from_connector_config_specification={
    app_id: {
      type: string
      path_in_connector_config: ['info', 'app_id']
    }
  } */
  oauthUserInputFromConnectorConfigSpecification?: OAuthConfiguration;
  /** OAuth specific blob. This is a Json Schema used to validate Json configurations produced by the OAuth flows as they are
returned by the distant OAuth APIs.
Must be a valid JSON describing the fields to merge back to `ConnectorSpecification.connectionSpecification`.
For each field, a special annotation `path_in_connector_config` can be specified to determine where to merge it,

Examples:

    complete_oauth_output_specification={
      refresh_token: {
        type: string,
        path_in_connector_config: ['credentials', 'refresh_token']
      }
    } */
  completeOAuthOutputSpecification?: OAuthConfiguration;
  /** OAuth specific blob. This is a Json Schema used to validate Json configurations persisted as Airbyte Server configurations.
Must be a valid non-nested JSON describing additional fields configured by the Airbyte Instance or Workspace Admins to be used by the
server when completing an OAuth flow (typically exchanging an auth code for refresh token).

Examples:

    complete_oauth_server_input_specification={
      client_id: {
        type: string
      },
      client_secret: {
        type: string
      }
    } */
  completeOAuthServerInputSpecification?: OAuthConfiguration;
  /** OAuth specific blob. This is a Json Schema used to validate Json configurations persisted as Airbyte Server configurations that
also need to be merged back into the connector configuration at runtime.
This is a subset configuration of `complete_oauth_server_input_specification` that filters fields out to retain only the ones that
are necessary for the connector to function with OAuth. (some fields could be used during oauth flows but not needed afterwards, therefore
they would be listed in the `complete_oauth_server_input_specification` but not `complete_oauth_server_output_specification`)
Must be a valid non-nested JSON describing additional fields configured by the Airbyte Instance or Workspace Admins to be used by the
connector when using OAuth flow APIs.
These fields are to be merged back to `ConnectorSpecification.connectionSpecification`.
For each field, a special annotation `path_in_connector_config` can be specified to determine where to merge it,

Examples:

      complete_oauth_server_output_specification={
        client_id: {
          type: string,
          path_in_connector_config: ['credentials', 'client_id']
        },
        client_secret: {
          type: string,
          path_in_connector_config: ['credentials', 'client_secret']
        }
      } */
  completeOAuthServerOutputSpecification?: OAuthConfiguration;
}

export type AdvancedAuthAuthFlowType = "oauth2.0" | "oauth1.0";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AdvancedAuthAuthFlowType = {
  oauth20: "oauth2.0" as AdvancedAuthAuthFlowType,
  oauth10: "oauth1.0" as AdvancedAuthAuthFlowType,
};

export interface AdvancedAuth {
  authFlowType?: AdvancedAuthAuthFlowType;
  /** Json Path to a field in the connectorSpecification that should exist for the advanced auth to be applicable. */
  predicateKey?: string[];
  /** Value of the predicate_key fields for the advanced auth to be applicable. */
  predicateValue?: string;
  oauthConfigSpecification?: OAuthConfigSpecification;
}

/**
 * OAuth specific blob.
 */
export type OAuthConfiguration = unknown;

/**
 * The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
 */
export type OAuthInputConfiguration = OAuthConfiguration;

export interface CompleteDestinationOAuthRequest {
  destinationDefinitionId: DestinationDefinitionId;
  workspaceId: WorkspaceId;
  /** When completing OAuth flow to gain an access token, some API sometimes requires to verify that the app re-send the redirectUrl that was used when consent was given. */
  redirectUrl?: string;
  /** The query parameters present in the redirect URL after a user granted consent e.g auth code */
  queryParams?: CompleteDestinationOAuthRequestQueryParams;
  oAuthInputConfiguration?: OAuthInputConfiguration;
}

export type DbMigrationState =
  | "pending"
  | "above_target"
  | "below_baseline"
  | "baseline"
  | "ignored"
  | "missing_success"
  | "missing_failed"
  | "success"
  | "undone"
  | "available"
  | "failed"
  | "out_of_order"
  | "future_success"
  | "future_failed"
  | "outdated"
  | "superseded"
  | "deleted";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DbMigrationState = {
  pending: "pending" as DbMigrationState,
  above_target: "above_target" as DbMigrationState,
  below_baseline: "below_baseline" as DbMigrationState,
  baseline: "baseline" as DbMigrationState,
  ignored: "ignored" as DbMigrationState,
  missing_success: "missing_success" as DbMigrationState,
  missing_failed: "missing_failed" as DbMigrationState,
  success: "success" as DbMigrationState,
  undone: "undone" as DbMigrationState,
  available: "available" as DbMigrationState,
  failed: "failed" as DbMigrationState,
  out_of_order: "out_of_order" as DbMigrationState,
  future_success: "future_success" as DbMigrationState,
  future_failed: "future_failed" as DbMigrationState,
  outdated: "outdated" as DbMigrationState,
  superseded: "superseded" as DbMigrationState,
  deleted: "deleted" as DbMigrationState,
};

export interface DbMigrationRead {
  migrationType: string;
  migrationVersion: string;
  migrationDescription: string;
  migrationState?: DbMigrationState;
  migratedBy?: string;
  migratedAt?: number;
  migrationScript?: string;
}

export interface DbMigrationExecutionRead {
  initialVersion?: string;
  targetVersion?: string;
  executedMigrations?: DbMigrationRead[];
}

export interface DbMigrationReadList {
  migrations?: DbMigrationRead[];
}

/**
 * optional resource requirements to run workers (blank for unbounded allocations)
 */
export interface ResourceRequirements {
  cpu_request?: string;
  cpu_limit?: string;
  memory_request?: string;
  memory_limit?: string;
}

/**
 * enum that describes the different types of jobs that the platform runs.
 */
export type JobType =
  | "get_spec"
  | "check_connection"
  | "discover_schema"
  | "sync"
  | "reset_connection"
  | "connection_updater"
  | "replicate";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JobType = {
  get_spec: "get_spec" as JobType,
  check_connection: "check_connection" as JobType,
  discover_schema: "discover_schema" as JobType,
  sync: "sync" as JobType,
  reset_connection: "reset_connection" as JobType,
  connection_updater: "connection_updater" as JobType,
  replicate: "replicate" as JobType,
};

/**
 * sets resource requirements for a specific job type for an actor definition. these values override the default, if both are set.
 */
export interface JobTypeResourceLimit {
  jobType: JobType;
  resourceRequirements: ResourceRequirements;
}

/**
 * actor definition specific resource requirements. if default is set, these are the requirements that should be set for ALL jobs run for this actor definition. it is overriden by the job type specific configurations. if not set, the platform will use defaults. these values will be overriden by configuration at the connection level.
 */
export interface ActorDefinitionResourceRequirements {
  default?: ResourceRequirements;
  jobSpecific?: JobTypeResourceLimit[];
}

export interface ConnectionStateObject {
  [key: string]: any;
}

export interface ConnectionState {
  connectionId: ConnectionId;
  state?: ConnectionStateObject;
}

export type CheckConnectionReadStatus = "succeeded" | "failed";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CheckConnectionReadStatus = {
  succeeded: "succeeded" as CheckConnectionReadStatus,
  failed: "failed" as CheckConnectionReadStatus,
};

export interface CheckConnectionRead {
  status: CheckConnectionReadStatus;
  message?: string;
  jobInfo: SynchronousJobRead;
}

export interface HealthCheckRead {
  available: boolean;
}

export interface Pagination {
  pageSize?: number;
  rowOffset?: number;
}

export interface LogRead {
  logLines: string[];
}

export interface SynchronousJobRead {
  id: string;
  configType: JobConfigType;
  /** only present if a config id was provided. */
  configId?: string;
  createdAt: number;
  endedAt: number;
  succeeded: boolean;
  logs?: LogRead;
}

export interface AttemptInfoRead {
  attempt: AttemptRead;
  logs: LogRead;
}

export interface JobDebugInfoRead {
  job: JobDebugRead;
  attempts: AttemptInfoRead[];
}

export interface JobInfoRead {
  job: JobRead;
  attempts: AttemptInfoRead[];
}

export interface JobReadList {
  jobs: JobWithAttemptsRead[];
}

export type AttemptStatus = "running" | "failed" | "succeeded";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AttemptStatus = {
  running: "running" as AttemptStatus,
  failed: "failed" as AttemptStatus,
  succeeded: "succeeded" as AttemptStatus,
};

/**
 * Categorizes well known errors into types for programmatic handling. If not set, the type of error is not well known.
 */
export type AttemptFailureType = "config_error" | "system_error" | "manual_cancellation";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AttemptFailureType = {
  config_error: "config_error" as AttemptFailureType,
  system_error: "system_error" as AttemptFailureType,
  manual_cancellation: "manual_cancellation" as AttemptFailureType,
};

/**
 * Indicates where the error originated. If not set, the origin of error is not well known.
 */
export type AttemptFailureOrigin = "source" | "destination" | "replication" | "persistence" | "normalization" | "dbt";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AttemptFailureOrigin = {
  source: "source" as AttemptFailureOrigin,
  destination: "destination" as AttemptFailureOrigin,
  replication: "replication" as AttemptFailureOrigin,
  persistence: "persistence" as AttemptFailureOrigin,
  normalization: "normalization" as AttemptFailureOrigin,
  dbt: "dbt" as AttemptFailureOrigin,
};

export interface AttemptFailureReason {
  failureOrigin?: AttemptFailureOrigin;
  failureType?: AttemptFailureType;
  externalMessage?: string;
  stacktrace?: string;
  /** True if it is known that retrying may succeed, e.g. for a transient failure. False if it is known that a retry will not succeed, e.g. for a configuration issue. If not set, retryable status is not well known. */
  retryable?: boolean;
  timestamp: number;
}

export interface AttemptFailureSummary {
  failures: AttemptFailureReason[];
  /** True if the number of committed records for this attempt was greater than 0. False if 0 records were committed. If not set, the number of committed records is unknown. */
  partialSuccess?: boolean;
}

export interface AttemptStats {
  recordsEmitted?: number;
  bytesEmitted?: number;
  stateMessagesEmitted?: number;
  recordsCommitted?: number;
}

export interface AttemptStreamStats {
  streamName: string;
  stats: AttemptStats;
}

export interface AttemptRead {
  id: number;
  status: AttemptStatus;
  createdAt: number;
  updatedAt: number;
  endedAt?: number;
  bytesSynced?: number;
  recordsSynced?: number;
  totalStats?: AttemptStats;
  streamStats?: AttemptStreamStats[];
  failureSummary?: AttemptFailureSummary;
}

export type JobStatus = "pending" | "running" | "incomplete" | "failed" | "succeeded" | "cancelled";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JobStatus = {
  pending: "pending" as JobStatus,
  running: "running" as JobStatus,
  incomplete: "incomplete" as JobStatus,
  failed: "failed" as JobStatus,
  succeeded: "succeeded" as JobStatus,
  cancelled: "cancelled" as JobStatus,
};

export interface JobWithAttemptsRead {
  job?: JobRead;
  attempts?: AttemptRead[];
}

export type JobConfigType =
  | "check_connection_source"
  | "check_connection_destination"
  | "discover_schema"
  | "get_spec"
  | "sync"
  | "reset_connection";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JobConfigType = {
  check_connection_source: "check_connection_source" as JobConfigType,
  check_connection_destination: "check_connection_destination" as JobConfigType,
  discover_schema: "discover_schema" as JobConfigType,
  get_spec: "get_spec" as JobConfigType,
  sync: "sync" as JobConfigType,
  reset_connection: "reset_connection" as JobConfigType,
};

export interface JobListRequestBody {
  configTypes: JobConfigType[];
  configId: string;
  pagination?: Pagination;
}

export type JobId = number;

export interface JobDebugRead {
  id: JobId;
  configType: JobConfigType;
  configId: string;
  status: JobStatus;
  airbyteVersion: string;
  sourceDefinition: SourceDefinitionRead;
  destinationDefinition: DestinationDefinitionRead;
}

export interface JobRead {
  id: JobId;
  configType: JobConfigType;
  configId: string;
  createdAt: number;
  updatedAt: number;
  status: JobStatus;
}

export interface JobIdRequestBody {
  id: JobId;
}

export type DataType = "string" | "number" | "boolean" | "object" | "array";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DataType = {
  string: "string" as DataType,
  number: "number" as DataType,
  boolean: "boolean" as DataType,
  object: "object" as DataType,
  array: "array" as DataType,
};

/**
 * the mutable part of the stream to configure the destination
 */
export interface AirbyteStreamConfiguration {
  syncMode: SyncMode;
  /** Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental`. Otherwise it is ignored. */
  cursorField?: string[];
  destinationSyncMode: DestinationSyncMode;
  /** Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup`. Otherwise it is ignored. */
  primaryKey?: string[][];
  /** Alias name to the stream to be used in the destination */
  aliasName?: string;
  selected?: boolean;
}

export interface StreamJsonSchema {
  [key: string]: any;
}

/**
 * the immutable schema defined by the source
 */
export interface AirbyteStream {
  /** Stream's name. */
  name: string;
  /** Stream schema using Json Schema specs. */
  jsonSchema?: StreamJsonSchema;
  supportedSyncModes?: SyncMode[];
  /** If the source defines the cursor field, then any other cursor field inputs will be ignored. If it does not, either the user_provided one is used, or the default one is used as a backup. */
  sourceDefinedCursor?: boolean;
  /** Path to the field that will be used to determine if a record is new or modified since the last sync. If not provided by the source, the end user will have to specify the comparable themselves. */
  defaultCursorField?: string[];
  /** If the source defines the primary key, paths to the fields that will be used as a primary key. If not provided by the source, the end user will have to specify the primary key themselves. */
  sourceDefinedPrimaryKey?: string[][];
  /** Optional Source-defined namespace. Airbyte streams from the same sources should have the same namespace. Currently only used by JDBC destinations to determine what schema to write to. */
  namespace?: string;
}

/**
 * each stream is split in two parts; the immutable schema from source and mutable configuration for destination
 */
export interface AirbyteStreamAndConfiguration {
  stream?: AirbyteStream;
  config?: AirbyteStreamConfiguration;
}

/**
 * describes the available schema (catalog).
 */
export interface AirbyteCatalog {
  streams: AirbyteStreamAndConfiguration[];
}

/**
 * type/source of logs produced
 */
export type LogType = "server" | "scheduler";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LogType = {
  server: "server" as LogType,
  scheduler: "scheduler" as LogType,
};

export interface LogsRequestBody {
  logType: LogType;
}

export type CheckOperationReadStatus = "succeeded" | "failed";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CheckOperationReadStatus = {
  succeeded: "succeeded" as CheckOperationReadStatus,
  failed: "failed" as CheckOperationReadStatus,
};

export interface CheckOperationRead {
  status: CheckOperationReadStatus;
  message?: string;
}

export interface OperatorDbt {
  gitRepoUrl: string;
  gitRepoBranch?: string;
  dockerImage?: string;
  dbtArguments?: string;
}

export type OperatorNormalizationOption = "basic";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OperatorNormalizationOption = {
  basic: "basic" as OperatorNormalizationOption,
};

export interface OperatorNormalization {
  option?: OperatorNormalizationOption;
}

export type OperatorType = "normalization" | "dbt";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OperatorType = {
  normalization: "normalization" as OperatorType,
  dbt: "dbt" as OperatorType,
};

export interface OperatorConfiguration {
  operatorType: OperatorType;
  normalization?: OperatorNormalization;
  dbt?: OperatorDbt;
}

export interface OperationRead {
  workspaceId: WorkspaceId;
  operationId: OperationId;
  name: string;
  operatorConfiguration: OperatorConfiguration;
}

export interface OperationReadList {
  operations: OperationRead[];
}

export interface OperationCreate {
  workspaceId: WorkspaceId;
  name: string;
  operatorConfiguration: OperatorConfiguration;
}

export type OperationId = string;

export interface OperationUpdate {
  operationId: OperationId;
  name: string;
  operatorConfiguration: OperatorConfiguration;
}

export interface OperationIdRequestBody {
  operationId: OperationId;
}

/**
 * Method used for computing final namespace in destination
 */
export type NamespaceDefinitionType = "source" | "destination" | "customformat";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NamespaceDefinitionType = {
  source: "source" as NamespaceDefinitionType,
  destination: "destination" as NamespaceDefinitionType,
  customformat: "customformat" as NamespaceDefinitionType,
};

export type ConnectionScheduleTimeUnit = "minutes" | "hours" | "days" | "weeks" | "months";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConnectionScheduleTimeUnit = {
  minutes: "minutes" as ConnectionScheduleTimeUnit,
  hours: "hours" as ConnectionScheduleTimeUnit,
  days: "days" as ConnectionScheduleTimeUnit,
  weeks: "weeks" as ConnectionScheduleTimeUnit,
  months: "months" as ConnectionScheduleTimeUnit,
};

/**
 * if null, then no schedule is set.
 */
export type ConnectionSchedule = {
  units: number;
  timeUnit: ConnectionScheduleTimeUnit;
} | null;

/**
 * Active means that data is flowing through the connection. Inactive means it is not. Deprecated means the connection is off and cannot be re-activated. the schema field describes the elements of the schema that will be synced.
 */
export type ConnectionStatus = "active" | "inactive" | "deprecated";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConnectionStatus = {
  active: "active" as ConnectionStatus,
  inactive: "inactive" as ConnectionStatus,
  deprecated: "deprecated" as ConnectionStatus,
};

export interface ConnectionReadList {
  connections: ConnectionRead[];
}

export interface WebBackendConnectionUpdate {
  /** Name that will be set to the connection */
  name?: string;
  connectionId: ConnectionId;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  operationIds?: OperationId[];
  syncCatalog: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
  withRefreshedCatalog?: boolean;
  operations?: WebBackendOperationCreateOrUpdate[];
}

export interface WebBackendConnectionCreate {
  /** Optional name of the connection */
  name?: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId: SourceId;
  destinationId: DestinationId;
  operationIds?: OperationId[];
  syncCatalog?: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
  operations?: OperationCreate[];
}

export interface ConnectionCreate {
  /** Optional name of the connection */
  name?: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId: SourceId;
  destinationId: DestinationId;
  operationIds?: OperationId[];
  syncCatalog?: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
}

export interface DbMigrationRequestBody {
  database: string;
}

export type ConnectionId = string;

export interface ConnectionSearch {
  connectionId?: ConnectionId;
  name?: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId?: SourceId;
  destinationId?: DestinationId;
  schedule?: ConnectionSchedule;
  status?: ConnectionStatus;
  source?: SourceSearch;
  destination?: DestinationSearch;
}

export interface ConnectionUpdate {
  connectionId: ConnectionId;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Name that will be set to this connection */
  name?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  operationIds?: OperationId[];
  syncCatalog: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
}

export interface WebBackendConnectionRequestBody {
  withRefreshedCatalog?: boolean;
  connectionId: ConnectionId;
}

export interface ConnectionIdRequestBody {
  connectionId: ConnectionId;
}

export type ReleaseStage = "alpha" | "beta" | "generally_available" | "custom";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReleaseStage = {
  alpha: "alpha" as ReleaseStage,
  beta: "beta" as ReleaseStage,
  generally_available: "generally_available" as ReleaseStage,
  custom: "custom" as ReleaseStage,
};

/**
 * The values required to configure the destination. The schema for this must match the schema return by destination_definition_specifications/get for the destinationDefinition.
 */
export type DestinationConfiguration = unknown;

export interface DestinationSearch {
  destinationDefinitionId?: DestinationDefinitionId;
  destinationId?: DestinationId;
  workspaceId?: WorkspaceId;
  connectionConfiguration?: DestinationConfiguration;
  name?: string;
  destinationName?: string;
}

export interface DestinationRead {
  destinationDefinitionId: DestinationDefinitionId;
  destinationId: DestinationId;
  workspaceId: WorkspaceId;
  connectionConfiguration: DestinationConfiguration;
  name: string;
  destinationName: string;
}

export interface DestinationReadList {
  destinations: DestinationRead[];
}

export interface DestinationUpdate {
  destinationId: DestinationId;
  connectionConfiguration: DestinationConfiguration;
  name: string;
}

export interface DestinationCreate {
  workspaceId: WorkspaceId;
  name: string;
  destinationDefinitionId: DestinationDefinitionId;
  connectionConfiguration: DestinationConfiguration;
}

export interface DestinationCoreConfig {
  destinationDefinitionId: DestinationDefinitionId;
  connectionConfiguration: DestinationConfiguration;
}

export type DestinationId = string;

export interface WebBackendConnectionSearch {
  connectionId?: ConnectionId;
  name?: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId?: SourceId;
  destinationId?: DestinationId;
  schedule?: ConnectionSchedule;
  status?: ConnectionStatus;
  source?: SourceSearch;
  destination?: DestinationSearch;
}

export interface ConnectionRead {
  connectionId: ConnectionId;
  name: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId: SourceId;
  destinationId: DestinationId;
  operationIds?: OperationId[];
  syncCatalog: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
}

export interface DestinationIdRequestBody {
  destinationId: DestinationId;
}

/**
 * The specification for what values are required to configure the destinationDefinition.
 */
export type DestinationDefinitionSpecification = unknown;

export interface DestinationDefinitionSpecificationRead {
  destinationDefinitionId: DestinationDefinitionId;
  documentationUrl?: string;
  connectionSpecification?: DestinationDefinitionSpecification;
  authSpecification?: DestinationAuthSpecification;
  advancedAuth?: AdvancedAuth;
  jobInfo: SynchronousJobRead;
  supportedDestinationSyncModes?: DestinationSyncMode[];
  supportsDbt?: boolean;
  supportsNormalization?: boolean;
}

export interface PrivateDestinationDefinitionRead {
  destinationDefinition: DestinationDefinitionRead;
  granted: boolean;
}

export interface PrivateDestinationDefinitionReadList {
  destinationDefinitions: PrivateDestinationDefinitionRead[];
}

export interface DestinationDefinitionIdWithWorkspaceId {
  destinationDefinitionId: DestinationDefinitionId;
  workspaceId: WorkspaceId;
}

export interface CustomDestinationDefinitionUpdate {
  workspaceId: WorkspaceId;
  destinationDefinition: DestinationDefinitionUpdate;
}

export interface CustomDestinationDefinitionCreate {
  workspaceId: WorkspaceId;
  destinationDefinition: DestinationDefinitionCreate;
}

export interface DestinationDefinitionRead {
  destinationDefinitionId: DestinationDefinitionId;
  name: string;
  dockerRepository: string;
  dockerImageTag: string;
  documentationUrl: string;
  icon?: string;
  releaseStage?: ReleaseStage;
  /** The date when this connector was first released, in yyyy-mm-dd format. */
  releaseDate?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface DestinationDefinitionReadList {
  destinationDefinitions: DestinationDefinitionRead[];
}

export interface DestinationDefinitionUpdate {
  destinationDefinitionId: DestinationDefinitionId;
  dockerImageTag?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface DestinationDefinitionCreate {
  name: string;
  dockerRepository: string;
  dockerImageTag: string;
  documentationUrl: string;
  icon?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface DestinationDefinitionIdRequestBody {
  destinationDefinitionId: DestinationDefinitionId;
}

export type DestinationAuthSpecification = AuthSpecification;

export type DestinationDefinitionId = string;

/**
 * Returns the results of a discover catalog job. If the job was not successful, the catalog field will not be present. jobInfo will aways be present and its status be used to determine if the job was successful or not.
 */
export interface SourceDiscoverSchemaRead {
  catalog?: AirbyteCatalog;
  jobInfo: SynchronousJobRead;
}

export interface SourceReadList {
  sources: SourceRead[];
}

export interface SourceDiscoverSchemaRequestBody {
  sourceId: SourceId;
  disable_cache?: boolean;
}

/**
 * The values required to configure the source. The schema for this must match the schema return by source_definition_specifications/get for the source.
 */
export type SourceConfiguration = unknown;

export interface SourceUpdate {
  sourceId: SourceId;
  connectionConfiguration: SourceConfiguration;
  name: string;
}

export interface SourceCreate {
  sourceDefinitionId: SourceDefinitionId;
  connectionConfiguration: SourceConfiguration;
  workspaceId: WorkspaceId;
  name: string;
}

export interface SourceCoreConfig {
  sourceDefinitionId: SourceDefinitionId;
  connectionConfiguration: SourceConfiguration;
}

export type SourceId = string;

export interface SourceRead {
  sourceDefinitionId: SourceDefinitionId;
  sourceId: SourceId;
  workspaceId: WorkspaceId;
  connectionConfiguration: SourceConfiguration;
  name: string;
  sourceName: string;
}

export interface SourceIdRequestBody {
  sourceId: SourceId;
}

/**
 * An object containing any metadata needed to describe this connector's Oauth flow
 */
export interface OAuth2Specification {
  /** A list of strings representing a pointer to the root object which contains any oauth parameters in the ConnectorSpecification.
Examples:
if oauth parameters were contained inside the top level, rootObject=[] If they were nested inside another object {'credentials': {'app_id' etc...}, rootObject=['credentials'] If they were inside a oneOf {'switch': {oneOf: [{client_id...}, {non_oauth_param]}},  rootObject=['switch', 0]  */
  rootObject: unknown[];
  /** Pointers to the fields in the rootObject needed to obtain the initial refresh/access tokens for the OAuth flow. Each inner array represents the path in the rootObject of the referenced field. For example. Assume the rootObject contains params 'app_secret', 'app_id' which are needed to get the initial refresh token. If they are not nested in the rootObject, then the array would look like this [['app_secret'], ['app_id']] If they are nested inside an object called 'auth_params' then this array would be [['auth_params', 'app_secret'], ['auth_params', 'app_id']] */
  oauthFlowInitParameters: string[][];
  /** Pointers to the fields in the rootObject which can be populated from successfully completing the oauth flow using the init parameters. This is typically a refresh/access token. Each inner array represents the path in the rootObject of the referenced field. */
  oauthFlowOutputParameters: string[][];
}

export type AuthSpecificationAuthType = "oauth2.0";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthSpecificationAuthType = {
  oauth20: "oauth2.0" as AuthSpecificationAuthType,
};

export interface AuthSpecification {
  auth_type?: AuthSpecificationAuthType;
  oauth2Specification?: OAuth2Specification;
}

export type SourceAuthSpecification = AuthSpecification;

/**
 * The specification for what values are required to configure the sourceDefinition.
 */
export interface SourceDefinitionSpecification {
  [key: string]: any;
}

export interface SourceDefinitionSpecificationRead {
  sourceDefinitionId: SourceDefinitionId;
  documentationUrl?: string;
  connectionSpecification?: SourceDefinitionSpecification;
  authSpecification?: SourceAuthSpecification;
  advancedAuth?: AdvancedAuth;
  jobInfo: SynchronousJobRead;
}

export interface PrivateSourceDefinitionRead {
  sourceDefinition: SourceDefinitionRead;
  granted: boolean;
}

export interface PrivateSourceDefinitionReadList {
  sourceDefinitions: PrivateSourceDefinitionRead[];
}

export interface CustomSourceDefinitionUpdate {
  workspaceId: WorkspaceId;
  sourceDefinition: SourceDefinitionUpdate;
}

export interface SourceDefinitionCreate {
  name: string;
  dockerRepository: string;
  dockerImageTag: string;
  documentationUrl: string;
  icon?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface CustomSourceDefinitionCreate {
  workspaceId: WorkspaceId;
  sourceDefinition: SourceDefinitionCreate;
}

export type SourceDefinitionId = string;

export interface SourceDefinitionIdWithWorkspaceId {
  sourceDefinitionId: SourceDefinitionId;
  workspaceId: WorkspaceId;
}

export interface SourceDefinitionRead {
  sourceDefinitionId: SourceDefinitionId;
  name: string;
  dockerRepository: string;
  dockerImageTag: string;
  documentationUrl?: string;
  icon?: string;
  releaseStage?: ReleaseStage;
  /** The date when this connector was first released, in yyyy-mm-dd format. */
  releaseDate?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface SourceDefinitionReadList {
  sourceDefinitions: SourceDefinitionRead[];
}

/**
 * Update the SourceDefinition. Currently, the only allowed attribute to update is the default docker image version.
 */
export interface SourceDefinitionUpdate {
  sourceDefinitionId: SourceDefinitionId;
  dockerImageTag: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface SourceDefinitionIdRequestBody {
  sourceDefinitionId: SourceDefinitionId;
}

export interface SlugRequestBody {
  slug: string;
}

export interface WebBackendWorkspaceStateResult {
  hasConnections: boolean;
  hasSources: boolean;
  hasDestinations: boolean;
}

export interface WebBackendWorkspaceState {
  workspaceId: WorkspaceId;
}

export interface WorkspaceGiveFeedback {
  workspaceId: WorkspaceId;
}

export interface WorkspaceUpdate {
  workspaceId: WorkspaceId;
  email?: string;
  initialSetupComplete: boolean;
  displaySetupWizard?: boolean;
  anonymousDataCollection: boolean;
  news: boolean;
  securityUpdates: boolean;
  notifications?: Notification[];
}

export interface WorkspaceUpdateName {
  workspaceId: WorkspaceId;
  name: string;
}

export interface WorkspaceRead {
  workspaceId: WorkspaceId;
  customerId: CustomerId;
  email?: string;
  name: string;
  slug: string;
  initialSetupComplete: boolean;
  displaySetupWizard?: boolean;
  anonymousDataCollection?: boolean;
  news?: boolean;
  securityUpdates?: boolean;
  notifications?: Notification[];
  firstCompletedSync?: boolean;
  feedbackDone?: boolean;
}

export interface WorkspaceReadList {
  workspaces: WorkspaceRead[];
}

export interface WorkspaceIdRequestBody {
  workspaceId: WorkspaceId;
}

export type NotificationReadStatus = "succeeded" | "failed";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationReadStatus = {
  succeeded: "succeeded" as NotificationReadStatus,
  failed: "failed" as NotificationReadStatus,
};

export interface NotificationRead {
  status: NotificationReadStatus;
  message?: string;
}

export type NotificationType = "slack" | "customerio";

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationType = {
  slack: "slack" as NotificationType,
  customerio: "customerio" as NotificationType,
};

export interface CustomerioNotificationConfiguration {
  [key: string]: any;
}

export interface SlackNotificationConfiguration {
  webhook: string;
}

export interface Notification {
  notificationType: NotificationType;
  sendOnSuccess: boolean;
  sendOnFailure: boolean;
  slackConfiguration?: SlackNotificationConfiguration;
  customerioConfiguration?: CustomerioNotificationConfiguration;
}

export interface WorkspaceCreate {
  email?: string;
  anonymousDataCollection?: boolean;
  name: string;
  news?: boolean;
  securityUpdates?: boolean;
  notifications?: Notification[];
  displaySetupWizard?: boolean;
}

export type CustomerId = string;

export type WorkspaceId = string;

export interface WebBackendOperationCreateOrUpdate {
  operationId?: OperationId;
  workspaceId: WorkspaceId;
  name: string;
  operatorConfiguration: OperatorConfiguration;
}

export interface SourceSearch {
  sourceDefinitionId?: SourceDefinitionId;
  sourceId?: SourceId;
  workspaceId?: WorkspaceId;
  connectionConfiguration?: SourceConfiguration;
  name?: string;
  sourceName?: string;
}

/**
 * @summary Creates a workspace
 */
export const createWorkspace = (workspaceCreate: WorkspaceCreate) => {
  return req<WorkspaceRead>({
    url: `/v1/workspaces/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceCreate,
  });
};

/**
 * @summary Deletes a workspace
 */
export const deleteWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return req<void>({
    url: `/v1/workspaces/delete`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary List all workspaces registered in the current Airbyte deployment
 */
export const listWorkspaces = () => {
  return req<WorkspaceReadList>({ url: `/v1/workspaces/list`, method: "post" });
};

/**
 * @summary Find workspace by ID
 */
export const getWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return req<WorkspaceRead>({
    url: `/v1/workspaces/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary Find workspace by slug
 */
export const getWorkspaceBySlug = (slugRequestBody: SlugRequestBody) => {
  return req<WorkspaceRead>({
    url: `/v1/workspaces/get_by_slug`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: slugRequestBody,
  });
};

/**
 * @summary Update workspace state
 */
export const updateWorkspace = (workspaceUpdate: WorkspaceUpdate) => {
  return req<WorkspaceRead>({
    url: `/v1/workspaces/update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceUpdate,
  });
};

/**
 * @summary Update workspace name
 */
export const updateWorkspaceName = (workspaceUpdateName: WorkspaceUpdateName) => {
  return req<WorkspaceRead>({
    url: `/v1/workspaces/update_name`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceUpdateName,
  });
};

/**
 * @summary Update workspace feedback state
 */
export const updateWorkspaceFeedback = (workspaceGiveFeedback: WorkspaceGiveFeedback) => {
  return req<void>({
    url: `/v1/workspaces/tag_feedback_status_as_done`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceGiveFeedback,
  });
};

/**
 * @summary Try sending a notifications
 */
export const tryNotificationConfig = (notification: Notification) => {
  return req<NotificationRead>({
    url: `/v1/notifications/try`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: notification,
  });
};

/**
 * @summary Creates a sourceDefinition
 */
export const createSourceDefinition = (sourceDefinitionCreate: SourceDefinitionCreate) => {
  return req<SourceDefinitionRead>({
    url: `/v1/source_definitions/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDefinitionCreate,
  });
};

/**
 * @summary Update a sourceDefinition
 */
export const updateSourceDefinition = (sourceDefinitionUpdate: SourceDefinitionUpdate) => {
  return req<SourceDefinitionRead>({
    url: `/v1/source_definitions/update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDefinitionUpdate,
  });
};

/**
 * @summary List all the sourceDefinitions the current Airbyte deployment is configured to use
 */
export const listSourceDefinitions = () => {
  return req<SourceDefinitionReadList>({ url: `/v1/source_definitions/list`, method: "post" });
};

/**
 * Guaranteed to retrieve the latest information on supported sources.
 * @summary List the latest sourceDefinitions Airbyte supports
 */
export const listLatestSourceDefinitions = () => {
  return req<SourceDefinitionReadList>({ url: `/v1/source_definitions/list_latest`, method: "post" });
};

/**
 * @summary Get source
 */
export const getSourceDefinition = (sourceDefinitionIdRequestBody: SourceDefinitionIdRequestBody) => {
  return req<SourceDefinitionRead>({
    url: `/v1/source_definitions/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDefinitionIdRequestBody,
  });
};

/**
 * @summary Delete a source definition
 */
export const deleteSourceDefinition = (sourceDefinitionIdRequestBody: SourceDefinitionIdRequestBody) => {
  return req<void>({
    url: `/v1/source_definitions/delete`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDefinitionIdRequestBody,
  });
};

/**
 * @summary List all private, non-custom sourceDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace's grants.
 */
export const listPrivateSourceDefinitions = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return req<PrivateSourceDefinitionReadList>({
    url: `/v1/source_definitions/list_private`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary List all the sourceDefinitions the given workspace is configured to use
 */
export const listSourceDefinitionsForWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return req<SourceDefinitionReadList>({
    url: `/v1/source_definitions/list_for_workspace`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary Creates a custom sourceDefinition for the given workspace
 */
export const createCustomSourceDefinition = (customSourceDefinitionCreate: CustomSourceDefinitionCreate) => {
  return req<SourceDefinitionRead>({
    url: `/v1/source_definitions/create_custom`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: customSourceDefinitionCreate,
  });
};

/**
 * @summary Get a sourceDefinition that is configured for the given workspace
 */
export const getSourceDefinitionForWorkspace = (
  sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId
) => {
  return req<SourceDefinitionRead>({
    url: `/v1/source_definitions/get_for_workspace`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDefinitionIdWithWorkspaceId,
  });
};

/**
 * @summary Update a custom sourceDefinition for the given workspace
 */
export const updateCustomSourceDefinition = (customSourceDefinitionUpdate: CustomSourceDefinitionUpdate) => {
  return req<SourceDefinitionRead>({
    url: `/v1/source_definitions/update_custom`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: customSourceDefinitionUpdate,
  });
};

/**
 * @summary Delete a custom source definition for the given workspace
 */
export const deleteCustomSourceDefinition = (sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId) => {
  return req<void>({
    url: `/v1/source_definitions/delete_custom`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDefinitionIdWithWorkspaceId,
  });
};

/**
 * @summary grant a private, non-custom sourceDefinition to a given workspace
 */
export const grantSourceDefinitionToWorkspace = (
  sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId
) => {
  return req<PrivateSourceDefinitionRead>({
    url: `/v1/source_definitions/grant_definition`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDefinitionIdWithWorkspaceId,
  });
};

/**
 * @summary revoke a grant to a private, non-custom sourceDefinition from a given workspace
 */
export const revokeSourceDefinitionFromWorkspace = (
  sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId
) => {
  return req<void>({
    url: `/v1/source_definitions/revoke_definition`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDefinitionIdWithWorkspaceId,
  });
};

/**
 * @summary Get specification for a SourceDefinition.
 */
export const getSourceDefinitionSpecification = (sourceDefinitionIdRequestBody: SourceDefinitionIdRequestBody) => {
  return req<SourceDefinitionSpecificationRead>({
    url: `/v1/source_definition_specifications/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDefinitionIdRequestBody,
  });
};

/**
 * @summary Create a source
 */
export const createSource = (sourceCreate: SourceCreate) => {
  return req<SourceRead>({
    url: `/v1/sources/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceCreate,
  });
};

/**
 * @summary Update a source
 */
export const updateSource = (sourceUpdate: SourceUpdate) => {
  return req<SourceRead>({
    url: `/v1/sources/update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceUpdate,
  });
};

/**
 * List sources for workspace. Does not return deleted sources.
 * @summary List sources for workspace
 */
export const listSourcesForWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return req<SourceReadList>({
    url: `/v1/sources/list`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary Get source
 */
export const getSource = (sourceIdRequestBody: SourceIdRequestBody) => {
  return req<SourceRead>({
    url: `/v1/sources/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceIdRequestBody,
  });
};

/**
 * @summary Search sources
 */
export const searchSources = (sourceSearch: SourceSearch) => {
  return req<SourceReadList>({
    url: `/v1/sources/search`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceSearch,
  });
};

/**
 * @summary Clone source
 */
export const cloneSource = (sourceIdRequestBody: SourceIdRequestBody) => {
  return req<SourceRead>({
    url: `/v1/sources/clone`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceIdRequestBody,
  });
};

/**
 * @summary Delete a source
 */
export const deleteSource = (sourceIdRequestBody: SourceIdRequestBody) => {
  return req<void>({
    url: `/v1/sources/delete`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceIdRequestBody,
  });
};

/**
 * @summary Check connection to the source
 */
export const checkConnectionToSource = (sourceIdRequestBody: SourceIdRequestBody) => {
  return req<CheckConnectionRead>({
    url: `/v1/sources/check_connection`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceIdRequestBody,
  });
};

/**
 * @summary Check connection for a proposed update to a source
 */
export const checkConnectionToSourceForUpdate = (sourceUpdate: SourceUpdate) => {
  return req<CheckConnectionRead>({
    url: `/v1/sources/check_connection_for_update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceUpdate,
  });
};

/**
 * @summary Discover the schema catalog of the source
 */
export const discoverSchemaForSource = (sourceDiscoverSchemaRequestBody: SourceDiscoverSchemaRequestBody) => {
  return req<SourceDiscoverSchemaRead>({
    url: `/v1/sources/discover_schema`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceDiscoverSchemaRequestBody,
  });
};

/**
 * @summary Creates a destinationsDefinition
 */
export const createDestinationDefinition = (destinationDefinitionCreate: DestinationDefinitionCreate) => {
  return req<DestinationDefinitionRead>({
    url: `/v1/destination_definitions/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationDefinitionCreate,
  });
};

/**
 * @summary Update destinationDefinition
 */
export const updateDestinationDefinition = (destinationDefinitionUpdate: DestinationDefinitionUpdate) => {
  return req<DestinationDefinitionRead>({
    url: `/v1/destination_definitions/update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationDefinitionUpdate,
  });
};

/**
 * @summary List all the destinationDefinitions the current Airbyte deployment is configured to use
 */
export const listDestinationDefinitions = () => {
  return req<DestinationDefinitionReadList>({ url: `/v1/destination_definitions/list`, method: "post" });
};

/**
 * Guaranteed to retrieve the latest information on supported destinations.
 * @summary List the latest destinationDefinitions Airbyte supports
 */
export const listLatestDestinationDefinitions = () => {
  return req<DestinationDefinitionReadList>({ url: `/v1/destination_definitions/list_latest`, method: "post" });
};

/**
 * @summary Get destinationDefinition
 */
export const getDestinationDefinition = (destinationDefinitionIdRequestBody: DestinationDefinitionIdRequestBody) => {
  return req<DestinationDefinitionRead>({
    url: `/v1/destination_definitions/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationDefinitionIdRequestBody,
  });
};

/**
 * @summary Delete a destination definition
 */
export const deleteDestinationDefinition = (destinationDefinitionIdRequestBody: DestinationDefinitionIdRequestBody) => {
  return req<void>({
    url: `/v1/destination_definitions/delete`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationDefinitionIdRequestBody,
  });
};

/**
 * @summary List all private, non-custom destinationDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace's grants.
 */
export const listPrivateDestinationDefinitions = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return req<PrivateDestinationDefinitionReadList>({
    url: `/v1/destination_definitions/list_private`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary List all the destinationDefinitions the given workspace is configured to use
 */
export const listDestinationDefinitionsForWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return req<DestinationDefinitionReadList>({
    url: `/v1/destination_definitions/list_for_workspace`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary Creates a custom destinationDefinition for the given workspace
 */
export const createCustomDestinationDefinition = (
  customDestinationDefinitionCreate: CustomDestinationDefinitionCreate
) => {
  return req<DestinationDefinitionRead>({
    url: `/v1/destination_definitions/create_custom`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: customDestinationDefinitionCreate,
  });
};

/**
 * @summary Get a destinationDefinition that is configured for the given workspace
 */
export const getDestinationDefinitionForWorkspace = (
  destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId
) => {
  return req<DestinationDefinitionRead>({
    url: `/v1/destination_definitions/get_for_workspace`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationDefinitionIdWithWorkspaceId,
  });
};

/**
 * @summary Update a custom destinationDefinition for the given workspace
 */
export const updateCustomDestinationDefinition = (
  customDestinationDefinitionUpdate: CustomDestinationDefinitionUpdate
) => {
  return req<DestinationDefinitionRead>({
    url: `/v1/destination_definitions/update_custom`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: customDestinationDefinitionUpdate,
  });
};

/**
 * @summary Delete a custom destination definition for the given workspace
 */
export const deleteCustomDestinationDefinition = (
  destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId
) => {
  return req<void>({
    url: `/v1/destination_definitions/delete_custom`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationDefinitionIdWithWorkspaceId,
  });
};

/**
 * @summary grant a private, non-custom destinationDefinition to a given workspace
 */
export const grantDestinationDefinitionToWorkspace = (
  destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId
) => {
  return req<PrivateDestinationDefinitionRead>({
    url: `/v1/destination_definitions/grant_definition`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationDefinitionIdWithWorkspaceId,
  });
};

/**
 * @summary revoke a grant to a private, non-custom destinationDefinition from a given workspace
 */
export const revokeDestinationDefinitionFromWorkspace = (
  destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId
) => {
  return req<void>({
    url: `/v1/destination_definitions/revoke_definition`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationDefinitionIdWithWorkspaceId,
  });
};

/**
 * @summary Get specification for a destinationDefinition
 */
export const getDestinationDefinitionSpecification = (
  destinationDefinitionIdRequestBody: DestinationDefinitionIdRequestBody
) => {
  return req<DestinationDefinitionSpecificationRead>({
    url: `/v1/destination_definition_specifications/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationDefinitionIdRequestBody,
  });
};

/**
 * @summary Create a destination
 */
export const createDestination = (destinationCreate: DestinationCreate) => {
  return req<DestinationRead>({
    url: `/v1/destinations/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationCreate,
  });
};

/**
 * @summary Update a destination
 */
export const updateDestination = (destinationUpdate: DestinationUpdate) => {
  return req<DestinationRead>({
    url: `/v1/destinations/update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationUpdate,
  });
};

/**
 * @summary List configured destinations for a workspace
 */
export const listDestinationsForWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return req<DestinationReadList>({
    url: `/v1/destinations/list`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary Get configured destination
 */
export const getDestination = (destinationIdRequestBody: DestinationIdRequestBody) => {
  return req<DestinationRead>({
    url: `/v1/destinations/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationIdRequestBody,
  });
};

/**
 * @summary Search destinations
 */
export const searchDestinations = (destinationSearch: DestinationSearch) => {
  return req<DestinationReadList>({
    url: `/v1/destinations/search`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationSearch,
  });
};

/**
 * @summary Check connection to the destination
 */
export const checkConnectionToDestination = (destinationIdRequestBody: DestinationIdRequestBody) => {
  return req<CheckConnectionRead>({
    url: `/v1/destinations/check_connection`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationIdRequestBody,
  });
};

/**
 * @summary Check connection for a proposed update to a destination
 */
export const checkConnectionToDestinationForUpdate = (destinationUpdate: DestinationUpdate) => {
  return req<CheckConnectionRead>({
    url: `/v1/destinations/check_connection_for_update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationUpdate,
  });
};

/**
 * @summary Delete the destination
 */
export const deleteDestination = (destinationIdRequestBody: DestinationIdRequestBody) => {
  return req<void>({
    url: `/v1/destinations/delete`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationIdRequestBody,
  });
};

/**
 * @summary Clone destination
 */
export const cloneDestination = (destinationIdRequestBody: DestinationIdRequestBody) => {
  return req<DestinationRead>({
    url: `/v1/destinations/clone`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationIdRequestBody,
  });
};

/**
 * @summary Create a connection between a source and a destination
 */
export const createConnection = (connectionCreate: ConnectionCreate) => {
  return req<ConnectionRead>({
    url: `/v1/connections/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: connectionCreate,
  });
};

/**
 * @summary Update a connection
 */
export const updateConnection = (connectionUpdate: ConnectionUpdate) => {
  return req<ConnectionRead>({
    url: `/v1/connections/update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: connectionUpdate,
  });
};

/**
 * List connections for workspace. Does not return deleted connections.
 * @summary Returns all connections for a workspace.
 */
export const listConnectionsForWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return req<ConnectionReadList>({
    url: `/v1/connections/list`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * List connections for workspace, including deleted connections.
 * @summary Returns all connections for a workspace, including deleted connections.
 */
export const listAllConnectionsForWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return req<ConnectionReadList>({
    url: `/v1/connections/list_all`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary Get a connection
 */
export const getConnection = (connectionIdRequestBody: ConnectionIdRequestBody) => {
  return req<ConnectionRead>({
    url: `/v1/connections/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: connectionIdRequestBody,
  });
};

/**
 * @summary Fetch the current state for a connection.
 */
export const getState = (connectionIdRequestBody: ConnectionIdRequestBody) => {
  return req<ConnectionState>({
    url: `/v1/state/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: connectionIdRequestBody,
  });
};

/**
 * @summary Search connections
 */
export const searchConnections = (connectionSearch: ConnectionSearch) => {
  return req<ConnectionReadList>({
    url: `/v1/connections/search`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: connectionSearch,
  });
};

/**
 * @summary Delete a connection
 */
export const deleteConnection = (connectionIdRequestBody: ConnectionIdRequestBody) => {
  return req<void>({
    url: `/v1/connections/delete`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: connectionIdRequestBody,
  });
};

/**
 * @summary Trigger a manual sync of the connection
 */
export const syncConnection = (connectionIdRequestBody: ConnectionIdRequestBody) => {
  return req<JobInfoRead>({
    url: `/v1/connections/sync`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: connectionIdRequestBody,
  });
};

/**
 * @summary Reset the data for the connection. Deletes data generated by the connection in the destination. Resets any cursors back to initial state.
 */
export const resetConnection = (connectionIdRequestBody: ConnectionIdRequestBody) => {
  return req<JobInfoRead>({
    url: `/v1/connections/reset`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: connectionIdRequestBody,
  });
};

/**
 * @summary Check if an operation to be created is valid
 */
export const checkOperation = (operatorConfiguration: OperatorConfiguration) => {
  return req<CheckOperationRead>({
    url: `/v1/operations/check`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: operatorConfiguration,
  });
};

/**
 * @summary Create an operation to be applied as part of a connection pipeline
 */
export const createOperation = (operationCreate: OperationCreate) => {
  return req<OperationRead>({
    url: `/v1/operations/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: operationCreate,
  });
};

/**
 * @summary Update an operation
 */
export const updateOperation = (operationUpdate: OperationUpdate) => {
  return req<OperationRead>({
    url: `/v1/operations/update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: operationUpdate,
  });
};

/**
 * List operations for connection.
 * @summary Returns all operations for a connection.
 */
export const listOperationsForConnection = (connectionIdRequestBody: ConnectionIdRequestBody) => {
  return req<OperationReadList>({
    url: `/v1/operations/list`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: connectionIdRequestBody,
  });
};

/**
 * @summary Returns an operation
 */
export const getOperation = (operationIdRequestBody: OperationIdRequestBody) => {
  return req<OperationRead>({
    url: `/v1/operations/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: operationIdRequestBody,
  });
};

/**
 * @summary Delete an operation
 */
export const deleteOperation = (operationIdRequestBody: OperationIdRequestBody) => {
  return req<void>({
    url: `/v1/operations/delete`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: operationIdRequestBody,
  });
};

/**
 * @summary Run check connection for a given source configuration
 */
export const executeSourceCheckConnection = (sourceCoreConfig: SourceCoreConfig) => {
  return req<CheckConnectionRead>({
    url: `/v1/scheduler/sources/check_connection`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceCoreConfig,
  });
};

/**
 * @summary Run discover schema for a given source a source configuration
 */
export const executeSourceDiscoverSchema = (sourceCoreConfig: SourceCoreConfig) => {
  return req<SourceDiscoverSchemaRead>({
    url: `/v1/scheduler/sources/discover_schema`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceCoreConfig,
  });
};

/**
 * @summary Run check connection for a given destination configuration
 */
export const executeDestinationCheckConnection = (destinationCoreConfig: DestinationCoreConfig) => {
  return req<CheckConnectionRead>({
    url: `/v1/scheduler/destinations/check_connection`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationCoreConfig,
  });
};

/**
 * @summary List all database migrations
 */
export const listMigrations = (dbMigrationRequestBody: DbMigrationRequestBody) => {
  return req<DbMigrationReadList>({
    url: `/v1/db_migrations/list`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: dbMigrationRequestBody,
  });
};

/**
 * @summary Migrate the database to the latest version
 */
export const executeMigrations = (dbMigrationRequestBody: DbMigrationRequestBody) => {
  return req<DbMigrationExecutionRead>({
    url: `/v1/db_migrations/migrate`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: dbMigrationRequestBody,
  });
};

/**
 * @summary Sets instancewide variables to be used for the oauth flow when creating this source. When set, these variables will be injected into a connector's configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company's Google Ads developer_token, client_id, and client_secret without the user having to know about these variables.

 */
export const setInstancewideSourceOauthParams = (
  setInstancewideSourceOauthParamsRequestBody: SetInstancewideSourceOauthParamsRequestBody
) => {
  return req<void>({
    url: `/v1/source_oauths/oauth_params/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: setInstancewideSourceOauthParamsRequestBody,
  });
};

/**
 * @summary Given a source connector definition ID, return the URL to the consent screen where to redirect the user to.
 */
export const getSourceOAuthConsent = (sourceOauthConsentRequest: SourceOauthConsentRequest) => {
  return req<OAuthConsentRead>({
    url: `/v1/source_oauths/get_consent_url`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: sourceOauthConsentRequest,
  });
};

/**
 * @summary Given a source def ID generate an access/refresh token etc.
 */
export const completeSourceOAuth = (completeSourceOauthRequest: CompleteSourceOauthRequest) => {
  return req<CompleteOAuthResponse>({
    url: `/v1/source_oauths/complete_oauth`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: completeSourceOauthRequest,
  });
};

/**
 * @summary Given a destination connector definition ID, return the URL to the consent screen where to redirect the user to.
 */
export const getDestinationOAuthConsent = (destinationOauthConsentRequest: DestinationOauthConsentRequest) => {
  return req<OAuthConsentRead>({
    url: `/v1/destination_oauths/get_consent_url`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: destinationOauthConsentRequest,
  });
};

/**
 * @summary Given a destination def ID generate an access/refresh token etc.
 */
export const completeDestinationOAuth = (completeDestinationOAuthRequest: CompleteDestinationOAuthRequest) => {
  return req<CompleteOAuthResponse>({
    url: `/v1/destination_oauths/complete_oauth`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: completeDestinationOAuthRequest,
  });
};

/**
 * @summary Sets instancewide variables to be used for the oauth flow when creating this destination. When set, these variables will be injected into a connector's configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company's Google Ads developer_token, client_id, and client_secret without the user having to know about these variables.

 */
export const setInstancewideDestinationOauthParams = (
  setInstancewideDestinationOauthParamsRequestBody: SetInstancewideDestinationOauthParamsRequestBody
) => {
  return req<void>({
    url: `/v1/destination_oauths/oauth_params/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: setInstancewideDestinationOauthParamsRequestBody,
  });
};

/**
 * @summary Returns all non-deleted connections for a workspace.
 */
export const webBackendListConnectionsForWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return req<WebBackendConnectionReadList>({
    url: `/v1/web_backend/connections/list`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary Returns all connections for a workspace.
 */
export const webBackendListAllConnectionsForWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return req<WebBackendConnectionReadList>({
    url: `/v1/web_backend/connections/list_all`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary Get a connection
 */
export const webBackendGetConnection = (webBackendConnectionRequestBody: WebBackendConnectionRequestBody) => {
  return req<WebBackendConnectionRead>({
    url: `/v1/web_backend/connections/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: webBackendConnectionRequestBody,
  });
};

/**
 * @summary Create a connection
 */
export const webBackendCreateConnection = (webBackendConnectionCreate: WebBackendConnectionCreate) => {
  return req<WebBackendConnectionRead>({
    url: `/v1/web_backend/connections/create`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: webBackendConnectionCreate,
  });
};

/**
 * @summary Update a connection
 */
export const webBackendUpdateConnection = (webBackendConnectionUpdate: WebBackendConnectionUpdate) => {
  return req<WebBackendConnectionRead>({
    url: `/v1/web_backend/connections/update`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: webBackendConnectionUpdate,
  });
};

/**
 * @summary Search connections
 */
export const webBackendSearchConnections = (webBackendConnectionSearch: WebBackendConnectionSearch) => {
  return req<WebBackendConnectionReadList>({
    url: `/v1/web_backend/connections/search`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: webBackendConnectionSearch,
  });
};

/**
 * @summary Returns the current state of a workspace
 */
export const webBackendGetWorkspaceState = (webBackendWorkspaceState: WebBackendWorkspaceState) => {
  return req<WebBackendWorkspaceStateResult>({
    url: `/v1/web_backend/workspace/state`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: webBackendWorkspaceState,
  });
};

/**
 * @summary Returns recent jobs for a connection. Jobs are returned in descending order by createdAt.
 */
export const listJobsFor = (jobListRequestBody: JobListRequestBody) => {
  return req<JobReadList>({
    url: `/v1/jobs/list`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: jobListRequestBody,
  });
};

/**
 * @summary Get information about a job
 */
export const getJobInfo = (jobIdRequestBody: JobIdRequestBody) => {
  return req<JobInfoRead>({
    url: `/v1/jobs/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: jobIdRequestBody,
  });
};

/**
 * @summary Cancels a job
 */
export const cancelJob = (jobIdRequestBody: JobIdRequestBody) => {
  return req<JobInfoRead>({
    url: `/v1/jobs/cancel`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: jobIdRequestBody,
  });
};

/**
 * @summary Gets all information needed to debug this job
 */
export const getJobDebugInfo = (jobIdRequestBody: JobIdRequestBody) => {
  return req<JobDebugInfoRead>({
    url: `/v1/jobs/get_debug_info`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: jobIdRequestBody,
  });
};

/**
 * @summary Health Check
 */
export const getHealthCheck = () => {
  return req<HealthCheckRead>({ url: `/v1/health`, method: "get" });
};

/**
 * @summary Get logs
 */
export const getLogs = (logsRequestBody: LogsRequestBody) => {
  return req<Blob>({
    url: `/v1/logs/get`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: logsRequestBody,
    responseType: "blob",
  });
};

/**
 * @summary Returns the openapi specification
 */
export const getOpenApiSpec = () => {
  return req<Blob>({ url: `/v1/openapi`, method: "get", responseType: "blob" });
};

/**
 * @summary Export Airbyte Configuration and Data Archive
 */
export const exportArchive = () => {
  return req<AirbyteArchive>({ url: `/v1/deployment/export`, method: "post" });
};

/**
 * @summary Import Airbyte Configuration and Data Archive
 */
export const importArchive = (airbyteArchive: AirbyteArchive) => {
  return req<ImportRead>({
    url: `/v1/deployment/import`,
    method: "post",
    headers: { "Content-Type": "application/x-gzip" },
    data: airbyteArchive,
  });
};

/**
 * @summary Export Airbyte Workspace Configuration
 */
export const exportWorkspace = (workspaceIdRequestBody: WorkspaceIdRequestBody) => {
  return req<AirbyteArchive>({
    url: `/v1/deployment/export_workspace`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: workspaceIdRequestBody,
  });
};

/**
 * @summary Upload a GZIP archive tarball and stage it in the server's cache as a temporary resource
 */
export const uploadArchiveResource = (airbyteArchive: AirbyteArchive) => {
  return req<UploadRead>({
    url: `/v1/deployment/upload_archive_resource`,
    method: "post",
    headers: { "Content-Type": "application/x-gzip" },
    data: airbyteArchive,
  });
};

/**
 * @summary Import Airbyte Configuration into Workspace (this operation might change ids of imported configurations). Note, in order to use this api endpoint, you might need to upload a temporary archive resource with 'deployment/upload_archive_resource' first

 */
export const importIntoWorkspace = (importRequestBody: ImportRequestBody) => {
  return req<ImportRead>({
    url: `/v1/deployment/import_into_workspace`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: importRequestBody,
  });
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type AsyncReturnType<T extends (...args: any) => Promise<any>> = T extends (...args: any) => Promise<infer R> ? R : any;

export type CreateWorkspaceResult = NonNullable<AsyncReturnType<typeof createWorkspace>>;
export type DeleteWorkspaceResult = NonNullable<AsyncReturnType<typeof deleteWorkspace>>;
export type ListWorkspacesResult = NonNullable<AsyncReturnType<typeof listWorkspaces>>;
export type GetWorkspaceResult = NonNullable<AsyncReturnType<typeof getWorkspace>>;
export type GetWorkspaceBySlugResult = NonNullable<AsyncReturnType<typeof getWorkspaceBySlug>>;
export type UpdateWorkspaceResult = NonNullable<AsyncReturnType<typeof updateWorkspace>>;
export type UpdateWorkspaceNameResult = NonNullable<AsyncReturnType<typeof updateWorkspaceName>>;
export type UpdateWorkspaceFeedbackResult = NonNullable<AsyncReturnType<typeof updateWorkspaceFeedback>>;
export type TryNotificationConfigResult = NonNullable<AsyncReturnType<typeof tryNotificationConfig>>;
export type CreateSourceDefinitionResult = NonNullable<AsyncReturnType<typeof createSourceDefinition>>;
export type UpdateSourceDefinitionResult = NonNullable<AsyncReturnType<typeof updateSourceDefinition>>;
export type ListSourceDefinitionsResult = NonNullable<AsyncReturnType<typeof listSourceDefinitions>>;
export type ListLatestSourceDefinitionsResult = NonNullable<AsyncReturnType<typeof listLatestSourceDefinitions>>;
export type GetSourceDefinitionResult = NonNullable<AsyncReturnType<typeof getSourceDefinition>>;
export type DeleteSourceDefinitionResult = NonNullable<AsyncReturnType<typeof deleteSourceDefinition>>;
export type ListPrivateSourceDefinitionsResult = NonNullable<AsyncReturnType<typeof listPrivateSourceDefinitions>>;
export type ListSourceDefinitionsForWorkspaceResult = NonNullable<
  AsyncReturnType<typeof listSourceDefinitionsForWorkspace>
>;
export type CreateCustomSourceDefinitionResult = NonNullable<AsyncReturnType<typeof createCustomSourceDefinition>>;
export type GetSourceDefinitionForWorkspaceResult = NonNullable<
  AsyncReturnType<typeof getSourceDefinitionForWorkspace>
>;
export type UpdateCustomSourceDefinitionResult = NonNullable<AsyncReturnType<typeof updateCustomSourceDefinition>>;
export type DeleteCustomSourceDefinitionResult = NonNullable<AsyncReturnType<typeof deleteCustomSourceDefinition>>;
export type GrantSourceDefinitionToWorkspaceResult = NonNullable<
  AsyncReturnType<typeof grantSourceDefinitionToWorkspace>
>;
export type RevokeSourceDefinitionFromWorkspaceResult = NonNullable<
  AsyncReturnType<typeof revokeSourceDefinitionFromWorkspace>
>;
export type GetSourceDefinitionSpecificationResult = NonNullable<
  AsyncReturnType<typeof getSourceDefinitionSpecification>
>;
export type CreateSourceResult = NonNullable<AsyncReturnType<typeof createSource>>;
export type UpdateSourceResult = NonNullable<AsyncReturnType<typeof updateSource>>;
export type ListSourcesForWorkspaceResult = NonNullable<AsyncReturnType<typeof listSourcesForWorkspace>>;
export type GetSourceResult = NonNullable<AsyncReturnType<typeof getSource>>;
export type SearchSourcesResult = NonNullable<AsyncReturnType<typeof searchSources>>;
export type CloneSourceResult = NonNullable<AsyncReturnType<typeof cloneSource>>;
export type DeleteSourceResult = NonNullable<AsyncReturnType<typeof deleteSource>>;
export type CheckConnectionToSourceResult = NonNullable<AsyncReturnType<typeof checkConnectionToSource>>;
export type CheckConnectionToSourceForUpdateResult = NonNullable<
  AsyncReturnType<typeof checkConnectionToSourceForUpdate>
>;
export type DiscoverSchemaForSourceResult = NonNullable<AsyncReturnType<typeof discoverSchemaForSource>>;
export type CreateDestinationDefinitionResult = NonNullable<AsyncReturnType<typeof createDestinationDefinition>>;
export type UpdateDestinationDefinitionResult = NonNullable<AsyncReturnType<typeof updateDestinationDefinition>>;
export type ListDestinationDefinitionsResult = NonNullable<AsyncReturnType<typeof listDestinationDefinitions>>;
export type ListLatestDestinationDefinitionsResult = NonNullable<
  AsyncReturnType<typeof listLatestDestinationDefinitions>
>;
export type GetDestinationDefinitionResult = NonNullable<AsyncReturnType<typeof getDestinationDefinition>>;
export type DeleteDestinationDefinitionResult = NonNullable<AsyncReturnType<typeof deleteDestinationDefinition>>;
export type ListPrivateDestinationDefinitionsResult = NonNullable<
  AsyncReturnType<typeof listPrivateDestinationDefinitions>
>;
export type ListDestinationDefinitionsForWorkspaceResult = NonNullable<
  AsyncReturnType<typeof listDestinationDefinitionsForWorkspace>
>;
export type CreateCustomDestinationDefinitionResult = NonNullable<
  AsyncReturnType<typeof createCustomDestinationDefinition>
>;
export type GetDestinationDefinitionForWorkspaceResult = NonNullable<
  AsyncReturnType<typeof getDestinationDefinitionForWorkspace>
>;
export type UpdateCustomDestinationDefinitionResult = NonNullable<
  AsyncReturnType<typeof updateCustomDestinationDefinition>
>;
export type DeleteCustomDestinationDefinitionResult = NonNullable<
  AsyncReturnType<typeof deleteCustomDestinationDefinition>
>;
export type GrantDestinationDefinitionToWorkspaceResult = NonNullable<
  AsyncReturnType<typeof grantDestinationDefinitionToWorkspace>
>;
export type RevokeDestinationDefinitionFromWorkspaceResult = NonNullable<
  AsyncReturnType<typeof revokeDestinationDefinitionFromWorkspace>
>;
export type GetDestinationDefinitionSpecificationResult = NonNullable<
  AsyncReturnType<typeof getDestinationDefinitionSpecification>
>;
export type CreateDestinationResult = NonNullable<AsyncReturnType<typeof createDestination>>;
export type UpdateDestinationResult = NonNullable<AsyncReturnType<typeof updateDestination>>;
export type ListDestinationsForWorkspaceResult = NonNullable<AsyncReturnType<typeof listDestinationsForWorkspace>>;
export type GetDestinationResult = NonNullable<AsyncReturnType<typeof getDestination>>;
export type SearchDestinationsResult = NonNullable<AsyncReturnType<typeof searchDestinations>>;
export type CheckConnectionToDestinationResult = NonNullable<AsyncReturnType<typeof checkConnectionToDestination>>;
export type CheckConnectionToDestinationForUpdateResult = NonNullable<
  AsyncReturnType<typeof checkConnectionToDestinationForUpdate>
>;
export type DeleteDestinationResult = NonNullable<AsyncReturnType<typeof deleteDestination>>;
export type CloneDestinationResult = NonNullable<AsyncReturnType<typeof cloneDestination>>;
export type CreateConnectionResult = NonNullable<AsyncReturnType<typeof createConnection>>;
export type UpdateConnectionResult = NonNullable<AsyncReturnType<typeof updateConnection>>;
export type ListConnectionsForWorkspaceResult = NonNullable<AsyncReturnType<typeof listConnectionsForWorkspace>>;
export type ListAllConnectionsForWorkspaceResult = NonNullable<AsyncReturnType<typeof listAllConnectionsForWorkspace>>;
export type GetConnectionResult = NonNullable<AsyncReturnType<typeof getConnection>>;
export type GetStateResult = NonNullable<AsyncReturnType<typeof getState>>;
export type SearchConnectionsResult = NonNullable<AsyncReturnType<typeof searchConnections>>;
export type DeleteConnectionResult = NonNullable<AsyncReturnType<typeof deleteConnection>>;
export type SyncConnectionResult = NonNullable<AsyncReturnType<typeof syncConnection>>;
export type ResetConnectionResult = NonNullable<AsyncReturnType<typeof resetConnection>>;
export type CheckOperationResult = NonNullable<AsyncReturnType<typeof checkOperation>>;
export type CreateOperationResult = NonNullable<AsyncReturnType<typeof createOperation>>;
export type UpdateOperationResult = NonNullable<AsyncReturnType<typeof updateOperation>>;
export type ListOperationsForConnectionResult = NonNullable<AsyncReturnType<typeof listOperationsForConnection>>;
export type GetOperationResult = NonNullable<AsyncReturnType<typeof getOperation>>;
export type DeleteOperationResult = NonNullable<AsyncReturnType<typeof deleteOperation>>;
export type ExecuteSourceCheckConnectionResult = NonNullable<AsyncReturnType<typeof executeSourceCheckConnection>>;
export type ExecuteSourceDiscoverSchemaResult = NonNullable<AsyncReturnType<typeof executeSourceDiscoverSchema>>;
export type ExecuteDestinationCheckConnectionResult = NonNullable<
  AsyncReturnType<typeof executeDestinationCheckConnection>
>;
export type ListMigrationsResult = NonNullable<AsyncReturnType<typeof listMigrations>>;
export type ExecuteMigrationsResult = NonNullable<AsyncReturnType<typeof executeMigrations>>;
export type SetInstancewideSourceOauthParamsResult = NonNullable<
  AsyncReturnType<typeof setInstancewideSourceOauthParams>
>;
export type GetSourceOAuthConsentResult = NonNullable<AsyncReturnType<typeof getSourceOAuthConsent>>;
export type CompleteSourceOAuthResult = NonNullable<AsyncReturnType<typeof completeSourceOAuth>>;
export type GetDestinationOAuthConsentResult = NonNullable<AsyncReturnType<typeof getDestinationOAuthConsent>>;
export type CompleteDestinationOAuthResult = NonNullable<AsyncReturnType<typeof completeDestinationOAuth>>;
export type SetInstancewideDestinationOauthParamsResult = NonNullable<
  AsyncReturnType<typeof setInstancewideDestinationOauthParams>
>;
export type WebBackendListConnectionsForWorkspaceResult = NonNullable<
  AsyncReturnType<typeof webBackendListConnectionsForWorkspace>
>;
export type WebBackendListAllConnectionsForWorkspaceResult = NonNullable<
  AsyncReturnType<typeof webBackendListAllConnectionsForWorkspace>
>;
export type WebBackendGetConnectionResult = NonNullable<AsyncReturnType<typeof webBackendGetConnection>>;
export type WebBackendCreateConnectionResult = NonNullable<AsyncReturnType<typeof webBackendCreateConnection>>;
export type WebBackendUpdateConnectionResult = NonNullable<AsyncReturnType<typeof webBackendUpdateConnection>>;
export type WebBackendSearchConnectionsResult = NonNullable<AsyncReturnType<typeof webBackendSearchConnections>>;
export type WebBackendGetWorkspaceStateResult = NonNullable<AsyncReturnType<typeof webBackendGetWorkspaceState>>;
export type ListJobsForResult = NonNullable<AsyncReturnType<typeof listJobsFor>>;
export type GetJobInfoResult = NonNullable<AsyncReturnType<typeof getJobInfo>>;
export type CancelJobResult = NonNullable<AsyncReturnType<typeof cancelJob>>;
export type GetJobDebugInfoResult = NonNullable<AsyncReturnType<typeof getJobDebugInfo>>;
export type GetHealthCheckResult = NonNullable<AsyncReturnType<typeof getHealthCheck>>;
export type GetLogsResult = NonNullable<AsyncReturnType<typeof getLogs>>;
export type GetOpenApiSpecResult = NonNullable<AsyncReturnType<typeof getOpenApiSpec>>;
export type ExportArchiveResult = NonNullable<AsyncReturnType<typeof exportArchive>>;
export type ImportArchiveResult = NonNullable<AsyncReturnType<typeof importArchive>>;
export type ExportWorkspaceResult = NonNullable<AsyncReturnType<typeof exportWorkspace>>;
export type UploadArchiveResourceResult = NonNullable<AsyncReturnType<typeof uploadArchiveResource>>;
export type ImportIntoWorkspaceResult = NonNullable<AsyncReturnType<typeof importIntoWorkspace>>;
