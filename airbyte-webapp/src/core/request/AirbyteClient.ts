/* eslint-disable */
/**
 * Generated by orval üç∫
 * Do not edit manually. Run "npm run generate-client" instead.
 * Airbyte Configuration API
 * Airbyte Configuration API
[https://airbyte.io](https://airbyte.io).

This API is a collection of HTTP RPC-style methods. While it is not a REST API, those familiar with REST should find the conventions of this API recognizable.

Here are some conventions that this API follows:
* All endpoints are http POST methods.
* All endpoints accept data via `application/json` request bodies. The API does not accept any data via query params.
* The naming convention for endpoints is: localhost:8000/{VERSION}/{METHOD_FAMILY}/{METHOD_NAME} e.g. `localhost:8000/v1/connections/create`.
* For all `update` methods, the whole object must be passed in, even the fields that did not change.

Change Management:
* The major version of the API endpoint can be determined / specified in the URL `localhost:8080/v1/connections/create`
* Minor version bumps will be invisible to the end user. The user cannot specify minor versions in requests.
* All backwards incompatible changes will happen in major version bumps. We will not make backwards incompatible changes in minor version bumps. Examples of non-breaking changes (includes but not limited to...):
  * Adding fields to request or response bodies.
  * Adding new HTTP endpoints.
* All `web_backend` APIs are not considered public APIs and are not guaranteeing backwards compatibility.

 * OpenAPI spec version: 1.0.0
 */
import { apiOverride } from "./apiOverride";
/**
 * Input failed validation
 */
export type InvalidInputResponseResponse = InvalidInputExceptionInfo;

export interface KnownExceptionInfo {
  message: string;
  exceptionClassName?: string;
  exceptionStack?: string[];
  rootCauseExceptionClassName?: string;
  rootCauseExceptionStack?: string[];
}

/**
 * Exception occurred; see message for details.
 */
export type ExceptionResponseResponse = KnownExceptionInfo;

export interface NotFoundKnownExceptionInfo {
  id?: string;
  message: string;
  exceptionClassName?: string;
  exceptionStack?: string[];
  rootCauseExceptionClassName?: string;
  rootCauseExceptionStack?: string[];
}

/**
 * Object with given id was not found.
 */
export type NotFoundResponseResponse = NotFoundKnownExceptionInfo;

export interface InvalidInputProperty {
  propertyPath: string;
  invalidValue?: string;
  message?: string;
}

export interface InvalidInputExceptionInfo {
  message: string;
  exceptionClassName?: string;
  exceptionStack?: string[];
  validationErrors: InvalidInputProperty[];
}

export type UploadReadStatus = typeof UploadReadStatus[keyof typeof UploadReadStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UploadReadStatus = {
  succeeded: "succeeded",
  failed: "failed",
} as const;

export type ResourceId = string;

export interface ImportRequestBody {
  resourceId: ResourceId;
  workspaceId: WorkspaceId;
}

export interface UploadRead {
  status: UploadReadStatus;
  resourceId?: ResourceId;
}

export type ImportReadStatus = typeof ImportReadStatus[keyof typeof ImportReadStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ImportReadStatus = {
  succeeded: "succeeded",
  failed: "failed",
} as const;

export interface ImportRead {
  status: ImportReadStatus;
  reason?: string;
}

/**
 * Tarball Archive (.tar.gz) of Airbyte Configuration and Database
 */
export type AirbyteArchive = Blob;

export type DestinationSyncMode = typeof DestinationSyncMode[keyof typeof DestinationSyncMode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DestinationSyncMode = {
  append: "append",
  overwrite: "overwrite",
  append_dedup: "append_dedup",
} as const;

export type SyncMode = typeof SyncMode[keyof typeof SyncMode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SyncMode = {
  full_refresh: "full_refresh",
  incremental: "incremental",
} as const;

export interface WebBackendConnectionRead {
  connectionId: ConnectionId;
  name: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId: SourceId;
  destinationId: DestinationId;
  syncCatalog: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  operationIds?: OperationId[];
  source: SourceRead;
  destination: DestinationRead;
  operations?: OperationRead[];
  /** epoch time of the latest sync job. null if no sync job has taken place. */
  latestSyncJobCreatedAt?: number;
  latestSyncJobStatus?: JobStatus;
  isSyncing: boolean;
  resourceRequirements?: ResourceRequirements;
  catalogId?: string;
  catalogDiff?: CatalogDiff;
}

export interface WebBackendConnectionReadList {
  connections: WebBackendConnectionRead[];
}

export type SetInstancewideDestinationOauthParamsRequestBodyParams = { [key: string]: any };

export interface SetInstancewideDestinationOauthParamsRequestBody {
  destinationDefinitionId: DestinationDefinitionId;
  params: SetInstancewideDestinationOauthParamsRequestBodyParams;
}

export type SetInstancewideSourceOauthParamsRequestBodyParams = { [key: string]: any };

export interface SetInstancewideSourceOauthParamsRequestBody {
  sourceDefinitionId: SourceDefinitionId;
  params: SetInstancewideSourceOauthParamsRequestBodyParams;
}

export interface CompleteOAuthResponse {
  [key: string]: any;
}

/**
 * The query parameters present in the redirect URL after a user granted consent e.g auth code
 */
export type CompleteDestinationOAuthRequestQueryParams = { [key: string]: any };

export interface CompleteDestinationOAuthRequest {
  destinationDefinitionId: DestinationDefinitionId;
  workspaceId: WorkspaceId;
  /** When completing OAuth flow to gain an access token, some API sometimes requires to verify that the app re-send the redirectUrl that was used when consent was given. */
  redirectUrl?: string;
  /** The query parameters present in the redirect URL after a user granted consent e.g auth code */
  queryParams?: CompleteDestinationOAuthRequestQueryParams;
  oAuthInputConfiguration?: OAuthInputConfiguration;
}

/**
 * The query parameters present in the redirect URL after a user granted consent e.g auth code
 */
export type CompleteSourceOauthRequestQueryParams = { [key: string]: any };

export interface CompleteSourceOauthRequest {
  sourceDefinitionId: SourceDefinitionId;
  workspaceId: WorkspaceId;
  /** When completing OAuth flow to gain an access token, some API sometimes requires to verify that the app re-send the redirectUrl that was used when consent was given. */
  redirectUrl?: string;
  /** The query parameters present in the redirect URL after a user granted consent e.g auth code */
  queryParams?: CompleteSourceOauthRequestQueryParams;
  oAuthInputConfiguration?: OAuthInputConfiguration;
}

export interface OAuthConsentRead {
  consentUrl: string;
}

export type AdvancedAuthAuthFlowType = typeof AdvancedAuthAuthFlowType[keyof typeof AdvancedAuthAuthFlowType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AdvancedAuthAuthFlowType = {
  oauth20: "oauth2.0",
  oauth10: "oauth1.0",
} as const;

export interface AdvancedAuth {
  authFlowType?: AdvancedAuthAuthFlowType;
  /** Json Path to a field in the connectorSpecification that should exist for the advanced auth to be applicable. */
  predicateKey?: string[];
  /** Value of the predicate_key fields for the advanced auth to be applicable. */
  predicateValue?: string;
  oauthConfigSpecification?: OAuthConfigSpecification;
}

/**
 * The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
 */
export type OAuthConfiguration = unknown;

export interface OAuthConfigSpecification {
  /** OAuth specific blob. This is a Json Schema used to validate Json configurations used as input to OAuth.
Must be a valid non-nested JSON that refers to properties from ConnectorSpecification.connectionSpecification
using special annotation 'path_in_connector_config'.
These are input values the user is entering through the UI to authenticate to the connector, that might also shared
as inputs for syncing data via the connector.

Examples:

if no connector values is shared during oauth flow, oauth_user_input_from_connector_config_specification=[]
if connector values such as 'app_id' inside the top level are used to generate the API url for the oauth flow,
  oauth_user_input_from_connector_config_specification={
    app_id: {
      type: string
      path_in_connector_config: ['app_id']
    }
  }
if connector values such as 'info.app_id' nested inside another object are used to generate the API url for the oauth flow,
  oauth_user_input_from_connector_config_specification={
    app_id: {
      type: string
      path_in_connector_config: ['info', 'app_id']
    }
  } */
  oauthUserInputFromConnectorConfigSpecification?: OAuthConfiguration;
  /** OAuth specific blob. This is a Json Schema used to validate Json configurations produced by the OAuth flows as they are
returned by the distant OAuth APIs.
Must be a valid JSON describing the fields to merge back to `ConnectorSpecification.connectionSpecification`.
For each field, a special annotation `path_in_connector_config` can be specified to determine where to merge it,

Examples:

    complete_oauth_output_specification={
      refresh_token: {
        type: string,
        path_in_connector_config: ['credentials', 'refresh_token']
      }
    } */
  completeOAuthOutputSpecification?: OAuthConfiguration;
  /** OAuth specific blob. This is a Json Schema used to validate Json configurations persisted as Airbyte Server configurations.
Must be a valid non-nested JSON describing additional fields configured by the Airbyte Instance or Workspace Admins to be used by the
server when completing an OAuth flow (typically exchanging an auth code for refresh token).

Examples:

    complete_oauth_server_input_specification={
      client_id: {
        type: string
      },
      client_secret: {
        type: string
      }
    } */
  completeOAuthServerInputSpecification?: OAuthConfiguration;
  /** OAuth specific blob. This is a Json Schema used to validate Json configurations persisted as Airbyte Server configurations that
also need to be merged back into the connector configuration at runtime.
This is a subset configuration of `complete_oauth_server_input_specification` that filters fields out to retain only the ones that
are necessary for the connector to function with OAuth. (some fields could be used during oauth flows but not needed afterwards, therefore
they would be listed in the `complete_oauth_server_input_specification` but not `complete_oauth_server_output_specification`)
Must be a valid non-nested JSON describing additional fields configured by the Airbyte Instance or Workspace Admins to be used by the
connector when using OAuth flow APIs.
These fields are to be merged back to `ConnectorSpecification.connectionSpecification`.
For each field, a special annotation `path_in_connector_config` can be specified to determine where to merge it,

Examples:

      complete_oauth_server_output_specification={
        client_id: {
          type: string,
          path_in_connector_config: ['credentials', 'client_id']
        },
        client_secret: {
          type: string,
          path_in_connector_config: ['credentials', 'client_secret']
        }
      } */
  completeOAuthServerOutputSpecification?: OAuthConfiguration;
}

export type OAuthInputConfiguration = OAuthConfiguration;

export interface DestinationOauthConsentRequest {
  destinationDefinitionId: DestinationDefinitionId;
  workspaceId: WorkspaceId;
  /** The url to redirect to after getting the user consent */
  redirectUrl: string;
  oAuthInputConfiguration?: OAuthInputConfiguration;
}

export interface SourceOauthConsentRequest {
  sourceDefinitionId: SourceDefinitionId;
  workspaceId: WorkspaceId;
  /** The url to redirect to after getting the user consent */
  redirectUrl: string;
  oAuthInputConfiguration?: OAuthInputConfiguration;
}

export type DbMigrationState = typeof DbMigrationState[keyof typeof DbMigrationState];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DbMigrationState = {
  pending: "pending",
  above_target: "above_target",
  below_baseline: "below_baseline",
  baseline: "baseline",
  ignored: "ignored",
  missing_success: "missing_success",
  missing_failed: "missing_failed",
  success: "success",
  undone: "undone",
  available: "available",
  failed: "failed",
  out_of_order: "out_of_order",
  future_success: "future_success",
  future_failed: "future_failed",
  outdated: "outdated",
  superseded: "superseded",
  deleted: "deleted",
} as const;

export interface DbMigrationRead {
  migrationType: string;
  migrationVersion: string;
  migrationDescription: string;
  migrationState?: DbMigrationState;
  migratedBy?: string;
  migratedAt?: number;
  migrationScript?: string;
}

export interface DbMigrationExecutionRead {
  initialVersion?: string;
  targetVersion?: string;
  executedMigrations?: DbMigrationRead[];
}

export interface DbMigrationReadList {
  migrations?: DbMigrationRead[];
}

/**
 * optional resource requirements to run workers (blank for unbounded allocations)
 */
export interface ResourceRequirements {
  cpu_request?: string;
  cpu_limit?: string;
  memory_request?: string;
  memory_limit?: string;
}

/**
 * enum that describes the different types of jobs that the platform runs.
 */
export type JobType = typeof JobType[keyof typeof JobType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JobType = {
  get_spec: "get_spec",
  check_connection: "check_connection",
  discover_schema: "discover_schema",
  sync: "sync",
  reset_connection: "reset_connection",
  connection_updater: "connection_updater",
  replicate: "replicate",
} as const;

/**
 * sets resource requirements for a specific job type for an actor definition. these values override the default, if both are set.
 */
export interface JobTypeResourceLimit {
  jobType: JobType;
  resourceRequirements: ResourceRequirements;
}

/**
 * actor definition specific resource requirements. if default is set, these are the requirements that should be set for ALL jobs run for this actor definition. it is overriden by the job type specific configurations. if not set, the platform will use defaults. these values will be overriden by configuration at the connection level.
 */
export interface ActorDefinitionResourceRequirements {
  default?: ResourceRequirements;
  jobSpecific?: JobTypeResourceLimit[];
}

/**
 * JSONSchema representation of the field
 */
export interface FieldSchema {
  [key: string]: any;
}

/**
 * A field name is a list of strings that form the path to the field.
 */
export type FieldName = string[];

export interface FieldSchemaUpdate {
  oldSchema: FieldSchema;
  newSchema: FieldSchema;
}

export interface FieldRemove {
  schema?: FieldSchema;
}

export interface FieldAdd {
  schema?: FieldSchema;
}

export type FieldTransformTransformType = typeof FieldTransformTransformType[keyof typeof FieldTransformTransformType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FieldTransformTransformType = {
  add_field: "add_field",
  remove_field: "remove_field",
  update_field_schema: "update_field_schema",
} as const;

/**
 * Describes the difference between two Streams.
 */
export interface FieldTransform {
  transformType: FieldTransformTransformType;
  fieldName: FieldName;
  addField?: FieldAdd;
  removeField?: FieldRemove;
  updateFieldSchema?: FieldSchemaUpdate;
}

export type StreamTransformTransformType =
  typeof StreamTransformTransformType[keyof typeof StreamTransformTransformType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StreamTransformTransformType = {
  add_stream: "add_stream",
  remove_stream: "remove_stream",
  update_stream: "update_stream",
} as const;

export interface StreamTransform {
  transformType: StreamTransformTransformType;
  streamDescriptor: StreamDescriptor;
  /** list of field transformations. order does not matter. */
  updateStream?: FieldTransform[];
}

/**
 * Describes the difference between two Airbyte catalogs.
 */
export interface CatalogDiff {
  /** list of stream transformations. order does not matter. */
  transforms: StreamTransform[];
}

export type ConnectionStateType = typeof ConnectionStateType[keyof typeof ConnectionStateType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConnectionStateType = {
  global: "global",
  stream: "stream",
  legacy: "legacy",
  not_set: "not_set",
} as const;

export interface StateBlob {
  [key: string]: any;
}

export interface StreamState {
  streamDescriptor: StreamDescriptor;
  streamState?: StateBlob;
}

export interface GlobalState {
  shared_state?: StateBlob;
  streamStates: StreamState[];
}

/**
 * Contains the state for a connection. The stateType field identifies what type of state it is. Only the field corresponding to that type will be set, the rest will be null. If stateType=not_set, then none of the fields will be set.
 */
export interface ConnectionState {
  stateType: ConnectionStateType;
  connectionId: ConnectionId;
  state?: StateBlob;
  streamState?: StreamState[];
  globalState?: GlobalState;
}

export type CheckConnectionReadStatus = typeof CheckConnectionReadStatus[keyof typeof CheckConnectionReadStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CheckConnectionReadStatus = {
  succeeded: "succeeded",
  failed: "failed",
} as const;

export interface HealthCheckRead {
  available: boolean;
}

export interface Pagination {
  pageSize?: number;
  rowOffset?: number;
}

export interface LogRead {
  logLines: string[];
}

export interface SynchronousJobRead {
  id: string;
  configType: JobConfigType;
  /** only present if a config id was provided. */
  configId?: string;
  createdAt: number;
  endedAt: number;
  succeeded: boolean;
  logs?: LogRead;
}

export interface CheckConnectionRead {
  status: CheckConnectionReadStatus;
  message?: string;
  jobInfo: SynchronousJobRead;
}

export interface AttemptInfoRead {
  attempt: AttemptRead;
  logs: LogRead;
}

export interface JobDebugInfoRead {
  job: JobDebugRead;
  attempts: AttemptInfoRead[];
}

export interface JobInfoRead {
  job: JobRead;
  attempts: AttemptInfoRead[];
}

export interface JobReadList {
  jobs: JobWithAttemptsRead[];
}

export type AttemptStatus = typeof AttemptStatus[keyof typeof AttemptStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AttemptStatus = {
  running: "running",
  failed: "failed",
  succeeded: "succeeded",
} as const;

/**
 * Categorizes well known errors into types for programmatic handling. If not set, the type of error is not well known.
 */
export type AttemptFailureType = typeof AttemptFailureType[keyof typeof AttemptFailureType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AttemptFailureType = {
  config_error: "config_error",
  system_error: "system_error",
  manual_cancellation: "manual_cancellation",
} as const;

/**
 * Indicates where the error originated. If not set, the origin of error is not well known.
 */
export type AttemptFailureOrigin = typeof AttemptFailureOrigin[keyof typeof AttemptFailureOrigin];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AttemptFailureOrigin = {
  source: "source",
  destination: "destination",
  replication: "replication",
  persistence: "persistence",
  normalization: "normalization",
  dbt: "dbt",
  airbyte_platform: "airbyte_platform",
} as const;

export interface AttemptFailureReason {
  failureOrigin?: AttemptFailureOrigin;
  failureType?: AttemptFailureType;
  externalMessage?: string;
  internalMessage?: string;
  stacktrace?: string;
  /** True if it is known that retrying may succeed, e.g. for a transient failure. False if it is known that a retry will not succeed, e.g. for a configuration issue. If not set, retryable status is not well known. */
  retryable?: boolean;
  timestamp: number;
}

export interface AttemptFailureSummary {
  failures: AttemptFailureReason[];
  /** True if the number of committed records for this attempt was greater than 0. False if 0 records were committed. If not set, the number of committed records is unknown. */
  partialSuccess?: boolean;
}

export interface AttemptStats {
  recordsEmitted?: number;
  bytesEmitted?: number;
  stateMessagesEmitted?: number;
  recordsCommitted?: number;
}

export interface AttemptStreamStats {
  streamName: string;
  stats: AttemptStats;
}

export interface AttemptRead {
  id: number;
  status: AttemptStatus;
  createdAt: number;
  updatedAt: number;
  endedAt?: number;
  bytesSynced?: number;
  recordsSynced?: number;
  totalStats?: AttemptStats;
  streamStats?: AttemptStreamStats[];
  failureSummary?: AttemptFailureSummary;
}

export type JobStatus = typeof JobStatus[keyof typeof JobStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JobStatus = {
  pending: "pending",
  running: "running",
  incomplete: "incomplete",
  failed: "failed",
  succeeded: "succeeded",
  cancelled: "cancelled",
} as const;

export interface JobWithAttemptsRead {
  job?: JobRead;
  attempts?: AttemptRead[];
}

export interface JobDebugRead {
  id: JobId;
  configType: JobConfigType;
  configId: string;
  status: JobStatus;
  airbyteVersion: string;
  sourceDefinition: SourceDefinitionRead;
  destinationDefinition: DestinationDefinitionRead;
}

export interface StreamDescriptor {
  name: string;
  namespace?: string;
}

/**
 * contains information about how a reset was configured. only populated if the job was a reset.
 */
export interface ResetConfig {
  streamsToReset?: StreamDescriptor[];
}

export interface JobIdRequestBody {
  id: JobId;
}

export type JobConfigType = typeof JobConfigType[keyof typeof JobConfigType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JobConfigType = {
  check_connection_source: "check_connection_source",
  check_connection_destination: "check_connection_destination",
  discover_schema: "discover_schema",
  get_spec: "get_spec",
  sync: "sync",
  reset_connection: "reset_connection",
} as const;

export interface JobListRequestBody {
  configTypes: JobConfigType[];
  configId: string;
  pagination?: Pagination;
}

export type JobId = number;

export interface JobRead {
  id: JobId;
  configType: JobConfigType;
  configId: string;
  createdAt: number;
  updatedAt: number;
  status: JobStatus;
  resetConfig?: ResetConfig;
}

export type DataType = typeof DataType[keyof typeof DataType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DataType = {
  string: "string",
  number: "number",
  boolean: "boolean",
  object: "object",
  array: "array",
} as const;

/**
 * the mutable part of the stream to configure the destination
 */
export interface AirbyteStreamConfiguration {
  syncMode: SyncMode;
  /** Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental`. Otherwise it is ignored. */
  cursorField?: string[];
  destinationSyncMode: DestinationSyncMode;
  /** Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup`. Otherwise it is ignored. */
  primaryKey?: string[][];
  /** Alias name to the stream to be used in the destination */
  aliasName?: string;
  selected?: boolean;
}

/**
 * Stream schema using Json Schema specs.
 */
export interface StreamJsonSchema {
  [key: string]: any;
}

/**
 * the immutable schema defined by the source
 */
export interface AirbyteStream {
  /** Stream's name. */
  name: string;
  jsonSchema?: StreamJsonSchema;
  supportedSyncModes?: SyncMode[];
  /** If the source defines the cursor field, then any other cursor field inputs will be ignored. If it does not, either the user_provided one is used, or the default one is used as a backup. */
  sourceDefinedCursor?: boolean;
  /** Path to the field that will be used to determine if a record is new or modified since the last sync. If not provided by the source, the end user will have to specify the comparable themselves. */
  defaultCursorField?: string[];
  /** If the source defines the primary key, paths to the fields that will be used as a primary key. If not provided by the source, the end user will have to specify the primary key themselves. */
  sourceDefinedPrimaryKey?: string[][];
  /** Optional Source-defined namespace. Airbyte streams from the same sources should have the same namespace. Currently only used by JDBC destinations to determine what schema to write to. */
  namespace?: string;
}

/**
 * each stream is split in two parts; the immutable schema from source and mutable configuration for destination
 */
export interface AirbyteStreamAndConfiguration {
  stream?: AirbyteStream;
  config?: AirbyteStreamConfiguration;
}

/**
 * describes the available schema (catalog).
 */
export interface AirbyteCatalog {
  streams: AirbyteStreamAndConfiguration[];
}

/**
 * type/source of logs produced
 */
export type LogType = typeof LogType[keyof typeof LogType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LogType = {
  server: "server",
  scheduler: "scheduler",
} as const;

export interface LogsRequestBody {
  logType: LogType;
}

export type CheckOperationReadStatus = typeof CheckOperationReadStatus[keyof typeof CheckOperationReadStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CheckOperationReadStatus = {
  succeeded: "succeeded",
  failed: "failed",
} as const;

export interface CheckOperationRead {
  status: CheckOperationReadStatus;
  message?: string;
}

export interface OperatorDbt {
  gitRepoUrl: string;
  gitRepoBranch?: string;
  dockerImage?: string;
  dbtArguments?: string;
}

export type OperatorNormalizationOption = typeof OperatorNormalizationOption[keyof typeof OperatorNormalizationOption];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OperatorNormalizationOption = {
  basic: "basic",
} as const;

export interface OperatorNormalization {
  option?: OperatorNormalizationOption;
}

export type OperatorType = typeof OperatorType[keyof typeof OperatorType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OperatorType = {
  normalization: "normalization",
  dbt: "dbt",
} as const;

export interface OperatorConfiguration {
  operatorType: OperatorType;
  normalization?: OperatorNormalization;
  dbt?: OperatorDbt;
}

export interface OperationCreate {
  workspaceId: WorkspaceId;
  name: string;
  operatorConfiguration: OperatorConfiguration;
}

export type OperationId = string;

export interface OperationRead {
  workspaceId: WorkspaceId;
  operationId: OperationId;
  name: string;
  operatorConfiguration: OperatorConfiguration;
}

export interface OperationReadList {
  operations: OperationRead[];
}

export interface WebBackendOperationCreateOrUpdate {
  operationId?: OperationId;
  workspaceId: WorkspaceId;
  name: string;
  operatorConfiguration: OperatorConfiguration;
}

export interface OperationUpdate {
  operationId: OperationId;
  name: string;
  operatorConfiguration: OperatorConfiguration;
}

export interface OperationIdRequestBody {
  operationId: OperationId;
}

/**
 * Method used for computing final namespace in destination
 */
export type NamespaceDefinitionType = typeof NamespaceDefinitionType[keyof typeof NamespaceDefinitionType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NamespaceDefinitionType = {
  source: "source",
  destination: "destination",
  customformat: "customformat",
} as const;

export type ConnectionScheduleTimeUnit = typeof ConnectionScheduleTimeUnit[keyof typeof ConnectionScheduleTimeUnit];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConnectionScheduleTimeUnit = {
  minutes: "minutes",
  hours: "hours",
  days: "days",
  weeks: "weeks",
  months: "months",
} as const;

/**
 * if null, then no schedule is set.
 */
export interface ConnectionSchedule {
  units: number;
  timeUnit: ConnectionScheduleTimeUnit;
}

/**
 * Active means that data is flowing through the connection. Inactive means it is not. Deprecated means the connection is off and cannot be re-activated. the schema field describes the elements of the schema that will be synced.
 */
export type ConnectionStatus = typeof ConnectionStatus[keyof typeof ConnectionStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConnectionStatus = {
  active: "active",
  inactive: "inactive",
  deprecated: "deprecated",
} as const;

export interface ConnectionReadList {
  connections: ConnectionRead[];
}

export interface WebBackendConnectionCreate {
  /** Optional name of the connection */
  name?: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId: SourceId;
  destinationId: DestinationId;
  operationIds?: OperationId[];
  syncCatalog?: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
  operations?: OperationCreate[];
  sourceCatalogId?: string;
}

export interface ConnectionCreate {
  /** Optional name of the connection */
  name?: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId: SourceId;
  destinationId: DestinationId;
  operationIds?: OperationId[];
  syncCatalog?: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
  sourceCatalogId?: string;
}

export interface DbMigrationRequestBody {
  database: string;
}

export type ConnectionId = string;

export interface WebBackendConnectionSearch {
  connectionId?: ConnectionId;
  name?: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId?: SourceId;
  destinationId?: DestinationId;
  schedule?: ConnectionSchedule;
  status?: ConnectionStatus;
  source?: SourceSearch;
  destination?: DestinationSearch;
}

export interface ConnectionSearch {
  connectionId?: ConnectionId;
  name?: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId?: SourceId;
  destinationId?: DestinationId;
  schedule?: ConnectionSchedule;
  status?: ConnectionStatus;
  source?: SourceSearch;
  destination?: DestinationSearch;
}

export interface ConnectionRead {
  connectionId: ConnectionId;
  name: string;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  sourceId: SourceId;
  destinationId: DestinationId;
  operationIds?: OperationId[];
  syncCatalog: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
  sourceCatalogId?: string;
}

export interface WebBackendConnectionUpdate {
  /** Name that will be set to the connection */
  name?: string;
  connectionId: ConnectionId;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  operationIds?: OperationId[];
  syncCatalog: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
  withRefreshedCatalog?: boolean;
  operations?: WebBackendOperationCreateOrUpdate[];
  sourceCatalogId?: string;
}

export interface ConnectionUpdate {
  connectionId: ConnectionId;
  namespaceDefinition?: NamespaceDefinitionType;
  /** Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'. */
  namespaceFormat?: string;
  /** Name that will be set to this connection */
  name?: string;
  /** Prefix that will be prepended to the name of each stream when it is written to the destination. */
  prefix?: string;
  operationIds?: OperationId[];
  syncCatalog: AirbyteCatalog;
  schedule?: ConnectionSchedule;
  status: ConnectionStatus;
  resourceRequirements?: ResourceRequirements;
  sourceCatalogId?: string;
}

export interface WebBackendConnectionRequestBody {
  withRefreshedCatalog?: boolean;
  connectionId: ConnectionId;
}

export interface ConnectionIdRequestBody {
  connectionId: ConnectionId;
}

export type ReleaseStage = typeof ReleaseStage[keyof typeof ReleaseStage];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReleaseStage = {
  alpha: "alpha",
  beta: "beta",
  generally_available: "generally_available",
  custom: "custom",
} as const;

export interface DestinationReadList {
  destinations: DestinationRead[];
}

/**
 * The values required to configure the destination. The schema for this must match the schema return by destination_definition_specifications/get for the destinationDefinition.
 */
export type DestinationConfiguration = unknown;

export interface DestinationSearch {
  destinationDefinitionId?: DestinationDefinitionId;
  destinationId?: DestinationId;
  workspaceId?: WorkspaceId;
  connectionConfiguration?: DestinationConfiguration;
  name?: string;
  destinationName?: string;
}

export interface DestinationUpdate {
  destinationId: DestinationId;
  connectionConfiguration: DestinationConfiguration;
  name: string;
}

export interface DestinationCreate {
  workspaceId: WorkspaceId;
  name: string;
  destinationDefinitionId: DestinationDefinitionId;
  connectionConfiguration: DestinationConfiguration;
}

export interface DestinationCoreConfig {
  destinationDefinitionId: DestinationDefinitionId;
  connectionConfiguration: DestinationConfiguration;
}

export type DestinationId = string;

export interface DestinationRead {
  destinationDefinitionId: DestinationDefinitionId;
  destinationId: DestinationId;
  workspaceId: WorkspaceId;
  connectionConfiguration: DestinationConfiguration;
  name: string;
  destinationName: string;
}

export interface DestinationIdRequestBody {
  destinationId: DestinationId;
}

/**
 * The specification for what values are required to configure the destinationDefinition.
 */
export type DestinationDefinitionSpecification = unknown;

export interface DestinationDefinitionSpecificationRead {
  destinationDefinitionId: DestinationDefinitionId;
  documentationUrl?: string;
  connectionSpecification?: DestinationDefinitionSpecification;
  authSpecification?: DestinationAuthSpecification;
  advancedAuth?: AdvancedAuth;
  jobInfo: SynchronousJobRead;
  supportedDestinationSyncModes?: DestinationSyncMode[];
  supportsDbt?: boolean;
  supportsNormalization?: boolean;
}

export interface DestinationDefinitionIdWithWorkspaceId {
  destinationDefinitionId: DestinationDefinitionId;
  workspaceId: WorkspaceId;
}

export interface CustomDestinationDefinitionUpdate {
  workspaceId: WorkspaceId;
  destinationDefinition: DestinationDefinitionUpdate;
}

export interface CustomDestinationDefinitionCreate {
  workspaceId: WorkspaceId;
  destinationDefinition: DestinationDefinitionCreate;
}

export interface DestinationDefinitionRead {
  destinationDefinitionId: DestinationDefinitionId;
  name: string;
  dockerRepository: string;
  dockerImageTag: string;
  documentationUrl: string;
  icon?: string;
  releaseStage?: ReleaseStage;
  /** The date when this connector was first released, in yyyy-mm-dd format. */
  releaseDate?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface PrivateDestinationDefinitionRead {
  destinationDefinition: DestinationDefinitionRead;
  granted: boolean;
}

export interface PrivateDestinationDefinitionReadList {
  destinationDefinitions: PrivateDestinationDefinitionRead[];
}

export interface DestinationDefinitionReadList {
  destinationDefinitions: DestinationDefinitionRead[];
}

export interface DestinationDefinitionUpdate {
  destinationDefinitionId: DestinationDefinitionId;
  dockerImageTag?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface DestinationDefinitionCreate {
  name: string;
  dockerRepository: string;
  dockerImageTag: string;
  documentationUrl: string;
  icon?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export type DestinationAuthSpecification = AuthSpecification;

export type DestinationDefinitionId = string;

export interface DestinationDefinitionIdRequestBody {
  destinationDefinitionId: DestinationDefinitionId;
}

export interface SourceSearch {
  sourceDefinitionId?: SourceDefinitionId;
  sourceId?: SourceId;
  workspaceId?: WorkspaceId;
  connectionConfiguration?: SourceConfiguration;
  name?: string;
  sourceName?: string;
}

/**
 * Returns the results of a discover catalog job. If the job was not successful, the catalog field will not be present. jobInfo will aways be present and its status be used to determine if the job was successful or not.
 */
export interface SourceDiscoverSchemaRead {
  catalog?: AirbyteCatalog;
  jobInfo: SynchronousJobRead;
  catalogId?: string;
}

export interface SourceReadList {
  sources: SourceRead[];
}

export interface SourceDiscoverSchemaRequestBody {
  sourceId: SourceId;
  disable_cache?: boolean;
}

/**
 * The values required to configure the source. The schema for this must match the schema return by source_definition_specifications/get for the source.
 */
export type SourceConfiguration = unknown;

export interface SourceUpdate {
  sourceId: SourceId;
  connectionConfiguration: SourceConfiguration;
  name: string;
}

export interface SourceCreate {
  sourceDefinitionId: SourceDefinitionId;
  connectionConfiguration: SourceConfiguration;
  workspaceId: WorkspaceId;
  name: string;
}

export interface SourceCoreConfig {
  sourceDefinitionId: SourceDefinitionId;
  connectionConfiguration: SourceConfiguration;
}

export type SourceId = string;

export interface SourceRead {
  sourceDefinitionId: SourceDefinitionId;
  sourceId: SourceId;
  workspaceId: WorkspaceId;
  connectionConfiguration: SourceConfiguration;
  name: string;
  sourceName: string;
}

export interface SourceIdRequestBody {
  sourceId: SourceId;
}

/**
 * An object containing any metadata needed to describe this connector's Oauth flow
 */
export interface OAuth2Specification {
  /** A list of strings representing a pointer to the root object which contains any oauth parameters in the ConnectorSpecification.
Examples:
if oauth parameters were contained inside the top level, rootObject=[] If they were nested inside another object {'credentials': {'app_id' etc...}, rootObject=['credentials'] If they were inside a oneOf {'switch': {oneOf: [{client_id...}, {non_oauth_param]}},  rootObject=['switch', 0]  */
  rootObject: unknown[];
  /** Pointers to the fields in the rootObject needed to obtain the initial refresh/access tokens for the OAuth flow. Each inner array represents the path in the rootObject of the referenced field. For example. Assume the rootObject contains params 'app_secret', 'app_id' which are needed to get the initial refresh token. If they are not nested in the rootObject, then the array would look like this [['app_secret'], ['app_id']] If they are nested inside an object called 'auth_params' then this array would be [['auth_params', 'app_secret'], ['auth_params', 'app_id']] */
  oauthFlowInitParameters: string[][];
  /** Pointers to the fields in the rootObject which can be populated from successfully completing the oauth flow using the init parameters. This is typically a refresh/access token. Each inner array represents the path in the rootObject of the referenced field. */
  oauthFlowOutputParameters: string[][];
}

export type AuthSpecificationAuthType = typeof AuthSpecificationAuthType[keyof typeof AuthSpecificationAuthType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthSpecificationAuthType = {
  oauth20: "oauth2.0",
} as const;

export interface AuthSpecification {
  auth_type?: AuthSpecificationAuthType;
  oauth2Specification?: OAuth2Specification;
}

export type SourceAuthSpecification = AuthSpecification;

/**
 * The specification for what values are required to configure the sourceDefinition.
 */
export interface SourceDefinitionSpecification {
  [key: string]: any;
}

export interface SourceDefinitionSpecificationRead {
  sourceDefinitionId: SourceDefinitionId;
  documentationUrl?: string;
  connectionSpecification?: SourceDefinitionSpecification;
  authSpecification?: SourceAuthSpecification;
  advancedAuth?: AdvancedAuth;
  jobInfo: SynchronousJobRead;
}

export interface PrivateSourceDefinitionRead {
  sourceDefinition: SourceDefinitionRead;
  granted: boolean;
}

export interface PrivateSourceDefinitionReadList {
  sourceDefinitions: PrivateSourceDefinitionRead[];
}

export interface CustomSourceDefinitionUpdate {
  workspaceId: WorkspaceId;
  sourceDefinition: SourceDefinitionUpdate;
}

export interface SourceDefinitionCreate {
  name: string;
  dockerRepository: string;
  dockerImageTag: string;
  documentationUrl: string;
  icon?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface CustomSourceDefinitionCreate {
  workspaceId: WorkspaceId;
  sourceDefinition: SourceDefinitionCreate;
}

export type SourceDefinitionId = string;

export interface SourceDefinitionIdWithWorkspaceId {
  sourceDefinitionId: SourceDefinitionId;
  workspaceId: WorkspaceId;
}

export interface SourceDefinitionRead {
  sourceDefinitionId: SourceDefinitionId;
  name: string;
  dockerRepository: string;
  dockerImageTag: string;
  documentationUrl?: string;
  icon?: string;
  releaseStage?: ReleaseStage;
  /** The date when this connector was first released, in yyyy-mm-dd format. */
  releaseDate?: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface SourceDefinitionReadList {
  sourceDefinitions: SourceDefinitionRead[];
}

/**
 * Update the SourceDefinition. Currently, the only allowed attribute to update is the default docker image version.
 */
export interface SourceDefinitionUpdate {
  sourceDefinitionId: SourceDefinitionId;
  dockerImageTag: string;
  resourceRequirements?: ActorDefinitionResourceRequirements;
}

export interface SourceDefinitionIdRequestBody {
  sourceDefinitionId: SourceDefinitionId;
}

export interface SlugRequestBody {
  slug: string;
}

export interface WebBackendWorkspaceStateResult {
  hasConnections: boolean;
  hasSources: boolean;
  hasDestinations: boolean;
}

export interface WebBackendWorkspaceState {
  workspaceId: WorkspaceId;
}

export interface WorkspaceGiveFeedback {
  workspaceId: WorkspaceId;
}

export interface WorkspaceUpdate {
  workspaceId: WorkspaceId;
  email?: string;
  initialSetupComplete: boolean;
  displaySetupWizard?: boolean;
  anonymousDataCollection: boolean;
  news: boolean;
  securityUpdates: boolean;
  notifications?: Notification[];
}

export interface WorkspaceUpdateName {
  workspaceId: WorkspaceId;
  name: string;
}

export interface WorkspaceRead {
  workspaceId: WorkspaceId;
  customerId: CustomerId;
  email?: string;
  name: string;
  slug: string;
  initialSetupComplete: boolean;
  displaySetupWizard?: boolean;
  anonymousDataCollection?: boolean;
  news?: boolean;
  securityUpdates?: boolean;
  notifications?: Notification[];
  firstCompletedSync?: boolean;
  feedbackDone?: boolean;
}

export interface WorkspaceReadList {
  workspaces: WorkspaceRead[];
}

export interface WorkspaceIdRequestBody {
  workspaceId: WorkspaceId;
}

export type NotificationReadStatus = typeof NotificationReadStatus[keyof typeof NotificationReadStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationReadStatus = {
  succeeded: "succeeded",
  failed: "failed",
} as const;

export interface NotificationRead {
  status: NotificationReadStatus;
  message?: string;
}

export type NotificationType = typeof NotificationType[keyof typeof NotificationType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationType = {
  slack: "slack",
  customerio: "customerio",
} as const;

export interface CustomerioNotificationConfiguration {
  [key: string]: any;
}

export interface SlackNotificationConfiguration {
  webhook: string;
}

export interface Notification {
  notificationType: NotificationType;
  sendOnSuccess: boolean;
  sendOnFailure: boolean;
  slackConfiguration?: SlackNotificationConfiguration;
  customerioConfiguration?: CustomerioNotificationConfiguration;
}

export interface WorkspaceCreate {
  email?: string;
  anonymousDataCollection?: boolean;
  name: string;
  news?: boolean;
  securityUpdates?: boolean;
  notifications?: Notification[];
  displaySetupWizard?: boolean;
}

export type CustomerId = string;

export type WorkspaceId = string;

// eslint-disable-next-line
type SecondParameter<T extends (...args: any) => any> = T extends (config: any, args: infer P) => any ? P : never;

/**
 * @summary Creates a workspace
 */
export const createWorkspace = (workspaceCreate: WorkspaceCreate, options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<WorkspaceRead>(
    {
      url: `/v1/workspaces/create`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: workspaceCreate,
    },
    options
  );
};

/**
 * @summary Deletes a workspace
 */
export const deleteWorkspace = (
  workspaceIdRequestBody: WorkspaceIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<void>(
    {
      url: `/v1/workspaces/delete`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: workspaceIdRequestBody,
    },
    options
  );
};

/**
 * @summary List all workspaces registered in the current Airbyte deployment
 */
export const listWorkspaces = (options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<WorkspaceReadList>({ url: `/v1/workspaces/list`, method: "post" }, options);
};

/**
 * @summary Find workspace by ID
 */
export const getWorkspace = (
  workspaceIdRequestBody: WorkspaceIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<WorkspaceRead>(
    {
      url: `/v1/workspaces/get`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: workspaceIdRequestBody,
    },
    options
  );
};

/**
 * @summary Find workspace by slug
 */
export const getWorkspaceBySlug = (slugRequestBody: SlugRequestBody, options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<WorkspaceRead>(
    {
      url: `/v1/workspaces/get_by_slug`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: slugRequestBody,
    },
    options
  );
};

/**
 * @summary Update workspace state
 */
export const updateWorkspace = (workspaceUpdate: WorkspaceUpdate, options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<WorkspaceRead>(
    {
      url: `/v1/workspaces/update`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: workspaceUpdate,
    },
    options
  );
};

/**
 * @summary Update workspace name
 */
export const updateWorkspaceName = (
  workspaceUpdateName: WorkspaceUpdateName,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<WorkspaceRead>(
    {
      url: `/v1/workspaces/update_name`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: workspaceUpdateName,
    },
    options
  );
};

/**
 * @summary Update workspace feedback state
 */
export const updateWorkspaceFeedback = (
  workspaceGiveFeedback: WorkspaceGiveFeedback,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<void>(
    {
      url: `/v1/workspaces/tag_feedback_status_as_done`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: workspaceGiveFeedback,
    },
    options
  );
};

/**
 * @summary Try sending a notifications
 */
export const tryNotificationConfig = (notification: Notification, options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<NotificationRead>(
    {
      url: `/v1/notifications/try`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: notification,
    },
    options
  );
};

/**
 * @summary Creates a sourceDefinition
 */
export const createSourceDefinition = (
  sourceDefinitionCreate: SourceDefinitionCreate,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<SourceDefinitionRead>(
    {
      url: `/v1/source_definitions/create`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: sourceDefinitionCreate,
    },
    options
  );
};

/**
 * @summary Update a sourceDefinition
 */
export const updateSourceDefinition = (
  sourceDefinitionUpdate: SourceDefinitionUpdate,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<SourceDefinitionRead>(
    {
      url: `/v1/source_definitions/update`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: sourceDefinitionUpdate,
    },
    options
  );
};

/**
 * @summary List all the sourceDefinitions the current Airbyte deployment is configured to use
 */
export const listSourceDefinitions = (options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<SourceDefinitionReadList>({ url: `/v1/source_definitions/list`, method: "post" }, options);
};

/**
 * Guaranteed to retrieve the latest information on supported sources.
 * @summary List the latest sourceDefinitions Airbyte supports
 */
export const listLatestSourceDefinitions = (options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<SourceDefinitionReadList>({ url: `/v1/source_definitions/list_latest`, method: "post" }, options);
};

/**
 * @summary Get source
 */
export const getSourceDefinition = (
  sourceDefinitionIdRequestBody: SourceDefinitionIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<SourceDefinitionRead>(
    {
      url: `/v1/source_definitions/get`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: sourceDefinitionIdRequestBody,
    },
    options
  );
};

/**
 * @summary Delete a source definition
 */
export const deleteSourceDefinition = (
  sourceDefinitionIdRequestBody: SourceDefinitionIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<void>(
    {
      url: `/v1/source_definitions/delete`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: sourceDefinitionIdRequestBody,
    },
    options
  );
};

/**
 * @summary List all private, non-custom sourceDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace's grants.
 */
export const listPrivateSourceDefinitions = (
  workspaceIdRequestBody: WorkspaceIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<PrivateSourceDefinitionReadList>(
    {
      url: `/v1/source_definitions/list_private`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: workspaceIdRequestBody,
    },
    options
  );
};

/**
 * @summary List all the sourceDefinitions the given workspace is configured to use
 */
export const listSourceDefinitionsForWorkspace = (
  workspaceIdRequestBody: WorkspaceIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<SourceDefinitionReadList>(
    {
      url: `/v1/source_definitions/list_for_workspace`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: workspaceIdRequestBody,
    },
    options
  );
};

/**
 * @summary Creates a custom sourceDefinition for the given workspace
 */
export const createCustomSourceDefinition = (
  customSourceDefinitionCreate: CustomSourceDefinitionCreate,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<SourceDefinitionRead>(
    {
      url: `/v1/source_definitions/create_custom`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: customSourceDefinitionCreate,
    },
    options
  );
};

/**
 * @summary Get a sourceDefinition that is configured for the given workspace
 */
export const getSourceDefinitionForWorkspace = (
  sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<SourceDefinitionRead>(
    {
      url: `/v1/source_definitions/get_for_workspace`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: sourceDefinitionIdWithWorkspaceId,
    },
    options
  );
};

/**
 * @summary Update a custom sourceDefinition for the given workspace
 */
export const updateCustomSourceDefinition = (
  customSourceDefinitionUpdate: CustomSourceDefinitionUpdate,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<SourceDefinitionRead>(
    {
      url: `/v1/source_definitions/update_custom`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: customSourceDefinitionUpdate,
    },
    options
  );
};

/**
 * @summary Delete a custom source definition for the given workspace
 */
export const deleteCustomSourceDefinition = (
  sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<void>(
    {
      url: `/v1/source_definitions/delete_custom`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: sourceDefinitionIdWithWorkspaceId,
    },
    options
  );
};

/**
 * @summary grant a private, non-custom sourceDefinition to a given workspace
 */
export const grantSourceDefinitionToWorkspace = (
  sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<PrivateSourceDefinitionRead>(
    {
      url: `/v1/source_definitions/grant_definition`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: sourceDefinitionIdWithWorkspaceId,
    },
    options
  );
};

/**
 * @summary revoke a grant to a private, non-custom sourceDefinition from a given workspace
 */
export const revokeSourceDefinitionFromWorkspace = (
  sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<void>(
    {
      url: `/v1/source_definitions/revoke_definition`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: sourceDefinitionIdWithWorkspaceId,
    },
    options
  );
};

/**
 * @summary Get specification for a SourceDefinition.
 */
export const getSourceDefinitionSpecification = (
  sourceDefinitionIdWithWorkspaceId: SourceDefinitionIdWithWorkspaceId,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<SourceDefinitionSpecificationRead>(
    {
      url: `/v1/source_definition_specifications/get`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: sourceDefinitionIdWithWorkspaceId,
    },
    options
  );
};

/**
 * @summary Create a source
 */
export const createSource = (sourceCreate: SourceCreate, options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<SourceRead>(
    { url: `/v1/sources/create`, method: "post", headers: { "Content-Type": "application/json" }, data: sourceCreate },
    options
  );
};

/**
 * @summary Update a source
 */
export const updateSource = (sourceUpdate: SourceUpdate, options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<SourceRead>(
    { url: `/v1/sources/update`, method: "post", headers: { "Content-Type": "application/json" }, data: sourceUpdate },
    options
  );
};

/**
 * List sources for workspace. Does not return deleted sources.
 * @summary List sources for workspace
 */
export const listSourcesForWorkspace = (
  workspaceIdRequestBody: WorkspaceIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<SourceReadList>(
    {
      url: `/v1/sources/list`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: workspaceIdRequestBody,
    },
    options
  );
};

/**
 * @summary Get source
 */
export const getSource = (sourceIdRequestBody: SourceIdRequestBody, options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<SourceRead>(
    {
      url: `/v1/sources/get`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: sourceIdRequestBody,
    },
    options
  );
};

/**
 * @summary Search sources
 */
export const searchSources = (sourceSearch: SourceSearch, options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<SourceReadList>(
    { url: `/v1/sources/search`, method: "post", headers: { "Content-Type": "application/json" }, data: sourceSearch },
    options
  );
};

/**
 * @summary Clone source
 */
export const cloneSource = (
  sourceIdRequestBody: SourceIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<SourceRead>(
    {
      url: `/v1/sources/clone`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: sourceIdRequestBody,
    },
    options
  );
};

/**
 * @summary Delete a source
 */
export const deleteSource = (
  sourceIdRequestBody: SourceIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<void>(
    {
      url: `/v1/sources/delete`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: sourceIdRequestBody,
    },
    options
  );
};

/**
 * @summary Check connection to the source
 */
export const checkConnectionToSource = (
  sourceIdRequestBody: SourceIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<CheckConnectionRead>(
    {
      url: `/v1/sources/check_connection`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: sourceIdRequestBody,
    },
    options
  );
};

/**
 * @summary Check connection for a proposed update to a source
 */
export const checkConnectionToSourceForUpdate = (
  sourceUpdate: SourceUpdate,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<CheckConnectionRead>(
    {
      url: `/v1/sources/check_connection_for_update`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: sourceUpdate,
    },
    options
  );
};

/**
 * @summary Discover the schema catalog of the source
 */
export const discoverSchemaForSource = (
  sourceDiscoverSchemaRequestBody: SourceDiscoverSchemaRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<SourceDiscoverSchemaRead>(
    {
      url: `/v1/sources/discover_schema`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: sourceDiscoverSchemaRequestBody,
    },
    options
  );
};

/**
 * @summary Creates a destinationsDefinition
 */
export const createDestinationDefinition = (
  destinationDefinitionCreate: DestinationDefinitionCreate,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<DestinationDefinitionRead>(
    {
      url: `/v1/destination_definitions/create`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: destinationDefinitionCreate,
    },
    options
  );
};

/**
 * @summary Update destinationDefinition
 */
export const updateDestinationDefinition = (
  destinationDefinitionUpdate: DestinationDefinitionUpdate,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<DestinationDefinitionRead>(
    {
      url: `/v1/destination_definitions/update`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: destinationDefinitionUpdate,
    },
    options
  );
};

/**
 * @summary List all the destinationDefinitions the current Airbyte deployment is configured to use
 */
export const listDestinationDefinitions = (options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<DestinationDefinitionReadList>(
    { url: `/v1/destination_definitions/list`, method: "post" },
    options
  );
};

/**
 * Guaranteed to retrieve the latest information on supported destinations.
 * @summary List the latest destinationDefinitions Airbyte supports
 */
export const listLatestDestinationDefinitions = (options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<DestinationDefinitionReadList>(
    { url: `/v1/destination_definitions/list_latest`, method: "post" },
    options
  );
};

/**
 * @summary Get destinationDefinition
 */
export const getDestinationDefinition = (
  destinationDefinitionIdRequestBody: DestinationDefinitionIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<DestinationDefinitionRead>(
    {
      url: `/v1/destination_definitions/get`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: destinationDefinitionIdRequestBody,
    },
    options
  );
};

/**
 * @summary Delete a destination definition
 */
export const deleteDestinationDefinition = (
  destinationDefinitionIdRequestBody: DestinationDefinitionIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<void>(
    {
      url: `/v1/destination_definitions/delete`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: destinationDefinitionIdRequestBody,
    },
    options
  );
};

/**
 * @summary List all private, non-custom destinationDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace's grants.
 */
export const listPrivateDestinationDefinitions = (
  workspaceIdRequestBody: WorkspaceIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<PrivateDestinationDefinitionReadList>(
    {
      url: `/v1/destination_definitions/list_private`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: workspaceIdRequestBody,
    },
    options
  );
};

/**
 * @summary List all the destinationDefinitions the given workspace is configured to use
 */
export const listDestinationDefinitionsForWorkspace = (
  workspaceIdRequestBody: WorkspaceIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<DestinationDefinitionReadList>(
    {
      url: `/v1/destination_definitions/list_for_workspace`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: workspaceIdRequestBody,
    },
    options
  );
};

/**
 * @summary Creates a custom destinationDefinition for the given workspace
 */
export const createCustomDestinationDefinition = (
  customDestinationDefinitionCreate: CustomDestinationDefinitionCreate,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<DestinationDefinitionRead>(
    {
      url: `/v1/destination_definitions/create_custom`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: customDestinationDefinitionCreate,
    },
    options
  );
};

/**
 * @summary Get a destinationDefinition that is configured for the given workspace
 */
export const getDestinationDefinitionForWorkspace = (
  destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<DestinationDefinitionRead>(
    {
      url: `/v1/destination_definitions/get_for_workspace`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: destinationDefinitionIdWithWorkspaceId,
    },
    options
  );
};

/**
 * @summary Update a custom destinationDefinition for the given workspace
 */
export const updateCustomDestinationDefinition = (
  customDestinationDefinitionUpdate: CustomDestinationDefinitionUpdate,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<DestinationDefinitionRead>(
    {
      url: `/v1/destination_definitions/update_custom`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: customDestinationDefinitionUpdate,
    },
    options
  );
};

/**
 * @summary Delete a custom destination definition for the given workspace
 */
export const deleteCustomDestinationDefinition = (
  destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<void>(
    {
      url: `/v1/destination_definitions/delete_custom`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: destinationDefinitionIdWithWorkspaceId,
    },
    options
  );
};

/**
 * @summary grant a private, non-custom destinationDefinition to a given workspace
 */
export const grantDestinationDefinitionToWorkspace = (
  destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<PrivateDestinationDefinitionRead>(
    {
      url: `/v1/destination_definitions/grant_definition`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: destinationDefinitionIdWithWorkspaceId,
    },
    options
  );
};

/**
 * @summary revoke a grant to a private, non-custom destinationDefinition from a given workspace
 */
export const revokeDestinationDefinitionFromWorkspace = (
  destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<void>(
    {
      url: `/v1/destination_definitions/revoke_definition`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: destinationDefinitionIdWithWorkspaceId,
    },
    options
  );
};

/**
 * @summary Get specification for a destinationDefinition
 */
export const getDestinationDefinitionSpecification = (
  destinationDefinitionIdWithWorkspaceId: DestinationDefinitionIdWithWorkspaceId,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<DestinationDefinitionSpecificationRead>(
    {
      url: `/v1/destination_definition_specifications/get`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: destinationDefinitionIdWithWorkspaceId,
    },
    options
  );
};

/**
 * @summary Create a destination
 */
export const createDestination = (
  destinationCreate: DestinationCreate,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<DestinationRead>(
    {
      url: `/v1/destinations/create`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: destinationCreate,
    },
    options
  );
};

/**
 * @summary Update a destination
 */
export const updateDestination = (
  destinationUpdate: DestinationUpdate,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<DestinationRead>(
    {
      url: `/v1/destinations/update`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: destinationUpdate,
    },
    options
  );
};

/**
 * @summary List configured destinations for a workspace
 */
export const listDestinationsForWorkspace = (
  workspaceIdRequestBody: WorkspaceIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<DestinationReadList>(
    {
      url: `/v1/destinations/list`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: workspaceIdRequestBody,
    },
    options
  );
};

/**
 * @summary Get configured destination
 */
export const getDestination = (
  destinationIdRequestBody: DestinationIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<DestinationRead>(
    {
      url: `/v1/destinations/get`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: destinationIdRequestBody,
    },
    options
  );
};

/**
 * @summary Search destinations
 */
export const searchDestinations = (
  destinationSearch: DestinationSearch,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<DestinationReadList>(
    {
      url: `/v1/destinations/search`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: destinationSearch,
    },
    options
  );
};

/**
 * @summary Check connection to the destination
 */
export const checkConnectionToDestination = (
  destinationIdRequestBody: DestinationIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<CheckConnectionRead>(
    {
      url: `/v1/destinations/check_connection`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: destinationIdRequestBody,
    },
    options
  );
};

/**
 * @summary Check connection for a proposed update to a destination
 */
export const checkConnectionToDestinationForUpdate = (
  destinationUpdate: DestinationUpdate,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<CheckConnectionRead>(
    {
      url: `/v1/destinations/check_connection_for_update`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: destinationUpdate,
    },
    options
  );
};

/**
 * @summary Delete the destination
 */
export const deleteDestination = (
  destinationIdRequestBody: DestinationIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<void>(
    {
      url: `/v1/destinations/delete`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: destinationIdRequestBody,
    },
    options
  );
};

/**
 * @summary Clone destination
 */
export const cloneDestination = (
  destinationIdRequestBody: DestinationIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<DestinationRead>(
    {
      url: `/v1/destinations/clone`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: destinationIdRequestBody,
    },
    options
  );
};

/**
 * @summary Create a connection between a source and a destination
 */
export const createConnection = (connectionCreate: ConnectionCreate, options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<ConnectionRead>(
    {
      url: `/v1/connections/create`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: connectionCreate,
    },
    options
  );
};

/**
 * @summary Update a connection
 */
export const updateConnection = (connectionUpdate: ConnectionUpdate, options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<ConnectionRead>(
    {
      url: `/v1/connections/update`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: connectionUpdate,
    },
    options
  );
};

/**
 * List connections for workspace. Does not return deleted connections.
 * @summary Returns all connections for a workspace.
 */
export const listConnectionsForWorkspace = (
  workspaceIdRequestBody: WorkspaceIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<ConnectionReadList>(
    {
      url: `/v1/connections/list`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: workspaceIdRequestBody,
    },
    options
  );
};

/**
 * List connections for workspace, including deleted connections.
 * @summary Returns all connections for a workspace, including deleted connections.
 */
export const listAllConnectionsForWorkspace = (
  workspaceIdRequestBody: WorkspaceIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<ConnectionReadList>(
    {
      url: `/v1/connections/list_all`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: workspaceIdRequestBody,
    },
    options
  );
};

/**
 * @summary Get a connection
 */
export const getConnection = (
  connectionIdRequestBody: ConnectionIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<ConnectionRead>(
    {
      url: `/v1/connections/get`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: connectionIdRequestBody,
    },
    options
  );
};

/**
 * @summary Fetch the current state for a connection.
 */
export const getState = (
  connectionIdRequestBody: ConnectionIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<ConnectionState>(
    {
      url: `/v1/state/get`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: connectionIdRequestBody,
    },
    options
  );
};

/**
 * @summary Search connections
 */
export const searchConnections = (
  connectionSearch: ConnectionSearch,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<ConnectionReadList>(
    {
      url: `/v1/connections/search`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: connectionSearch,
    },
    options
  );
};

/**
 * @summary Delete a connection
 */
export const deleteConnection = (
  connectionIdRequestBody: ConnectionIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<void>(
    {
      url: `/v1/connections/delete`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: connectionIdRequestBody,
    },
    options
  );
};

/**
 * @summary Trigger a manual sync of the connection
 */
export const syncConnection = (
  connectionIdRequestBody: ConnectionIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<JobInfoRead>(
    {
      url: `/v1/connections/sync`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: connectionIdRequestBody,
    },
    options
  );
};

/**
 * @summary Reset the data for the connection. Deletes data generated by the connection in the destination. Resets any cursors back to initial state.
 */
export const resetConnection = (
  connectionIdRequestBody: ConnectionIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<JobInfoRead>(
    {
      url: `/v1/connections/reset`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: connectionIdRequestBody,
    },
    options
  );
};

/**
 * @summary Check if an operation to be created is valid
 */
export const checkOperation = (
  operatorConfiguration: OperatorConfiguration,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<CheckOperationRead>(
    {
      url: `/v1/operations/check`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: operatorConfiguration,
    },
    options
  );
};

/**
 * @summary Create an operation to be applied as part of a connection pipeline
 */
export const createOperation = (operationCreate: OperationCreate, options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<OperationRead>(
    {
      url: `/v1/operations/create`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: operationCreate,
    },
    options
  );
};

/**
 * @summary Update an operation
 */
export const updateOperation = (operationUpdate: OperationUpdate, options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<OperationRead>(
    {
      url: `/v1/operations/update`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: operationUpdate,
    },
    options
  );
};

/**
 * List operations for connection.
 * @summary Returns all operations for a connection.
 */
export const listOperationsForConnection = (
  connectionIdRequestBody: ConnectionIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<OperationReadList>(
    {
      url: `/v1/operations/list`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: connectionIdRequestBody,
    },
    options
  );
};

/**
 * @summary Returns an operation
 */
export const getOperation = (
  operationIdRequestBody: OperationIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<OperationRead>(
    {
      url: `/v1/operations/get`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: operationIdRequestBody,
    },
    options
  );
};

/**
 * @summary Delete an operation
 */
export const deleteOperation = (
  operationIdRequestBody: OperationIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<void>(
    {
      url: `/v1/operations/delete`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: operationIdRequestBody,
    },
    options
  );
};

/**
 * @summary Run check connection for a given source configuration
 */
export const executeSourceCheckConnection = (
  sourceCoreConfig: SourceCoreConfig,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<CheckConnectionRead>(
    {
      url: `/v1/scheduler/sources/check_connection`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: sourceCoreConfig,
    },
    options
  );
};

/**
 * @summary Run discover schema for a given source a source configuration
 */
export const executeSourceDiscoverSchema = (
  sourceCoreConfig: SourceCoreConfig,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<SourceDiscoverSchemaRead>(
    {
      url: `/v1/scheduler/sources/discover_schema`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: sourceCoreConfig,
    },
    options
  );
};

/**
 * @summary Run check connection for a given destination configuration
 */
export const executeDestinationCheckConnection = (
  destinationCoreConfig: DestinationCoreConfig,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<CheckConnectionRead>(
    {
      url: `/v1/scheduler/destinations/check_connection`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: destinationCoreConfig,
    },
    options
  );
};

/**
 * @summary List all database migrations
 */
export const listMigrations = (
  dbMigrationRequestBody: DbMigrationRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<DbMigrationReadList>(
    {
      url: `/v1/db_migrations/list`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: dbMigrationRequestBody,
    },
    options
  );
};

/**
 * @summary Migrate the database to the latest version
 */
export const executeMigrations = (
  dbMigrationRequestBody: DbMigrationRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<DbMigrationExecutionRead>(
    {
      url: `/v1/db_migrations/migrate`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: dbMigrationRequestBody,
    },
    options
  );
};

/**
 * @summary Sets instancewide variables to be used for the oauth flow when creating this source. When set, these variables will be injected into a connector's configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company's Google Ads developer_token, client_id, and client_secret without the user having to know about these variables.

 */
export const setInstancewideSourceOauthParams = (
  setInstancewideSourceOauthParamsRequestBody: SetInstancewideSourceOauthParamsRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<void>(
    {
      url: `/v1/source_oauths/oauth_params/create`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: setInstancewideSourceOauthParamsRequestBody,
    },
    options
  );
};

/**
 * @summary Given a source connector definition ID, return the URL to the consent screen where to redirect the user to.
 */
export const getSourceOAuthConsent = (
  sourceOauthConsentRequest: SourceOauthConsentRequest,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<OAuthConsentRead>(
    {
      url: `/v1/source_oauths/get_consent_url`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: sourceOauthConsentRequest,
    },
    options
  );
};

/**
 * @summary Given a source def ID generate an access/refresh token etc.
 */
export const completeSourceOAuth = (
  completeSourceOauthRequest: CompleteSourceOauthRequest,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<CompleteOAuthResponse>(
    {
      url: `/v1/source_oauths/complete_oauth`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: completeSourceOauthRequest,
    },
    options
  );
};

/**
 * @summary Given a destination connector definition ID, return the URL to the consent screen where to redirect the user to.
 */
export const getDestinationOAuthConsent = (
  destinationOauthConsentRequest: DestinationOauthConsentRequest,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<OAuthConsentRead>(
    {
      url: `/v1/destination_oauths/get_consent_url`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: destinationOauthConsentRequest,
    },
    options
  );
};

/**
 * @summary Given a destination def ID generate an access/refresh token etc.
 */
export const completeDestinationOAuth = (
  completeDestinationOAuthRequest: CompleteDestinationOAuthRequest,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<CompleteOAuthResponse>(
    {
      url: `/v1/destination_oauths/complete_oauth`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: completeDestinationOAuthRequest,
    },
    options
  );
};

/**
 * @summary Sets instancewide variables to be used for the oauth flow when creating this destination. When set, these variables will be injected into a connector's configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company's Google Ads developer_token, client_id, and client_secret without the user having to know about these variables.

 */
export const setInstancewideDestinationOauthParams = (
  setInstancewideDestinationOauthParamsRequestBody: SetInstancewideDestinationOauthParamsRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<void>(
    {
      url: `/v1/destination_oauths/oauth_params/create`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: setInstancewideDestinationOauthParamsRequestBody,
    },
    options
  );
};

/**
 * @summary Returns all non-deleted connections for a workspace.
 */
export const webBackendListConnectionsForWorkspace = (
  workspaceIdRequestBody: WorkspaceIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<WebBackendConnectionReadList>(
    {
      url: `/v1/web_backend/connections/list`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: workspaceIdRequestBody,
    },
    options
  );
};

/**
 * @summary Returns all connections for a workspace.
 */
export const webBackendListAllConnectionsForWorkspace = (
  workspaceIdRequestBody: WorkspaceIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<WebBackendConnectionReadList>(
    {
      url: `/v1/web_backend/connections/list_all`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: workspaceIdRequestBody,
    },
    options
  );
};

/**
 * @summary Get a connection
 */
export const webBackendGetConnection = (
  webBackendConnectionRequestBody: WebBackendConnectionRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<WebBackendConnectionRead>(
    {
      url: `/v1/web_backend/connections/get`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: webBackendConnectionRequestBody,
    },
    options
  );
};

/**
 * @summary Create a connection
 */
export const webBackendCreateConnection = (
  webBackendConnectionCreate: WebBackendConnectionCreate,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<WebBackendConnectionRead>(
    {
      url: `/v1/web_backend/connections/create`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: webBackendConnectionCreate,
    },
    options
  );
};

/**
 * @summary Update a connection
 */
export const webBackendUpdateConnection = (
  webBackendConnectionUpdate: WebBackendConnectionUpdate,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<WebBackendConnectionRead>(
    {
      url: `/v1/web_backend/connections/update`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: webBackendConnectionUpdate,
    },
    options
  );
};

/**
 * @summary Search connections
 */
export const webBackendSearchConnections = (
  webBackendConnectionSearch: WebBackendConnectionSearch,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<WebBackendConnectionReadList>(
    {
      url: `/v1/web_backend/connections/search`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: webBackendConnectionSearch,
    },
    options
  );
};

/**
 * @summary Fetch the current state type for a connection.
 */
export const getStateType = (
  connectionIdRequestBody: ConnectionIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<ConnectionStateType>(
    {
      url: `/v1/web_backend/state/get_type`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: connectionIdRequestBody,
    },
    options
  );
};

/**
 * @summary Returns the current state of a workspace
 */
export const webBackendGetWorkspaceState = (
  webBackendWorkspaceState: WebBackendWorkspaceState,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<WebBackendWorkspaceStateResult>(
    {
      url: `/v1/web_backend/workspace/state`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: webBackendWorkspaceState,
    },
    options
  );
};

/**
 * @summary Returns recent jobs for a connection. Jobs are returned in descending order by createdAt.
 */
export const listJobsFor = (jobListRequestBody: JobListRequestBody, options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<JobReadList>(
    { url: `/v1/jobs/list`, method: "post", headers: { "Content-Type": "application/json" }, data: jobListRequestBody },
    options
  );
};

/**
 * @summary Get information about a job
 */
export const getJobInfo = (jobIdRequestBody: JobIdRequestBody, options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<JobInfoRead>(
    { url: `/v1/jobs/get`, method: "post", headers: { "Content-Type": "application/json" }, data: jobIdRequestBody },
    options
  );
};

/**
 * @summary Cancels a job
 */
export const cancelJob = (jobIdRequestBody: JobIdRequestBody, options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<JobInfoRead>(
    { url: `/v1/jobs/cancel`, method: "post", headers: { "Content-Type": "application/json" }, data: jobIdRequestBody },
    options
  );
};

/**
 * @summary Gets all information needed to debug this job
 */
export const getJobDebugInfo = (jobIdRequestBody: JobIdRequestBody, options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<JobDebugInfoRead>(
    {
      url: `/v1/jobs/get_debug_info`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: jobIdRequestBody,
    },
    options
  );
};

/**
 * @summary Health Check
 */
export const getHealthCheck = (options?: SecondParameter<typeof apiOverride>, signal?: AbortSignal) => {
  return apiOverride<HealthCheckRead>({ url: `/v1/health`, method: "get", signal }, options);
};

/**
 * @summary Get logs
 */
export const getLogs = (logsRequestBody: LogsRequestBody, options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<Blob>(
    {
      url: `/v1/logs/get`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: logsRequestBody,
      responseType: "blob",
    },
    options
  );
};

/**
 * @summary Returns the openapi specification
 */
export const getOpenApiSpec = (options?: SecondParameter<typeof apiOverride>, signal?: AbortSignal) => {
  return apiOverride<Blob>({ url: `/v1/openapi`, method: "get", signal, responseType: "blob" }, options);
};

/**
 * @summary Export Airbyte Configuration and Data Archive
 */
export const exportArchive = (options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<AirbyteArchive>({ url: `/v1/deployment/export`, method: "post" }, options);
};

/**
 * @summary Import Airbyte Configuration and Data Archive
 */
export const importArchive = (airbyteArchive: AirbyteArchive, options?: SecondParameter<typeof apiOverride>) => {
  return apiOverride<ImportRead>(
    {
      url: `/v1/deployment/import`,
      method: "post",
      headers: { "Content-Type": "application/x-gzip" },
      data: airbyteArchive,
    },
    options
  );
};

/**
 * @summary Export Airbyte Workspace Configuration
 */
export const exportWorkspace = (
  workspaceIdRequestBody: WorkspaceIdRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<AirbyteArchive>(
    {
      url: `/v1/deployment/export_workspace`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: workspaceIdRequestBody,
    },
    options
  );
};

/**
 * @summary Upload a GZIP archive tarball and stage it in the server's cache as a temporary resource
 */
export const uploadArchiveResource = (
  airbyteArchive: AirbyteArchive,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<UploadRead>(
    {
      url: `/v1/deployment/upload_archive_resource`,
      method: "post",
      headers: { "Content-Type": "application/x-gzip" },
      data: airbyteArchive,
    },
    options
  );
};

/**
 * @summary Import Airbyte Configuration into Workspace (this operation might change ids of imported configurations). Note, in order to use this api endpoint, you might need to upload a temporary archive resource with 'deployment/upload_archive_resource' first

 */
export const importIntoWorkspace = (
  importRequestBody: ImportRequestBody,
  options?: SecondParameter<typeof apiOverride>
) => {
  return apiOverride<ImportRead>(
    {
      url: `/v1/deployment/import_into_workspace`,
      method: "post",
      headers: { "Content-Type": "application/json" },
      data: importRequestBody,
    },
    options
  );
};

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

export type CreateWorkspaceResult = NonNullable<Awaited<ReturnType<typeof createWorkspace>>>;
export type DeleteWorkspaceResult = NonNullable<Awaited<ReturnType<typeof deleteWorkspace>>>;
export type ListWorkspacesResult = NonNullable<Awaited<ReturnType<typeof listWorkspaces>>>;
export type GetWorkspaceResult = NonNullable<Awaited<ReturnType<typeof getWorkspace>>>;
export type GetWorkspaceBySlugResult = NonNullable<Awaited<ReturnType<typeof getWorkspaceBySlug>>>;
export type UpdateWorkspaceResult = NonNullable<Awaited<ReturnType<typeof updateWorkspace>>>;
export type UpdateWorkspaceNameResult = NonNullable<Awaited<ReturnType<typeof updateWorkspaceName>>>;
export type UpdateWorkspaceFeedbackResult = NonNullable<Awaited<ReturnType<typeof updateWorkspaceFeedback>>>;
export type TryNotificationConfigResult = NonNullable<Awaited<ReturnType<typeof tryNotificationConfig>>>;
export type CreateSourceDefinitionResult = NonNullable<Awaited<ReturnType<typeof createSourceDefinition>>>;
export type UpdateSourceDefinitionResult = NonNullable<Awaited<ReturnType<typeof updateSourceDefinition>>>;
export type ListSourceDefinitionsResult = NonNullable<Awaited<ReturnType<typeof listSourceDefinitions>>>;
export type ListLatestSourceDefinitionsResult = NonNullable<Awaited<ReturnType<typeof listLatestSourceDefinitions>>>;
export type GetSourceDefinitionResult = NonNullable<Awaited<ReturnType<typeof getSourceDefinition>>>;
export type DeleteSourceDefinitionResult = NonNullable<Awaited<ReturnType<typeof deleteSourceDefinition>>>;
export type ListPrivateSourceDefinitionsResult = NonNullable<Awaited<ReturnType<typeof listPrivateSourceDefinitions>>>;
export type ListSourceDefinitionsForWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof listSourceDefinitionsForWorkspace>>
>;
export type CreateCustomSourceDefinitionResult = NonNullable<Awaited<ReturnType<typeof createCustomSourceDefinition>>>;
export type GetSourceDefinitionForWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof getSourceDefinitionForWorkspace>>
>;
export type UpdateCustomSourceDefinitionResult = NonNullable<Awaited<ReturnType<typeof updateCustomSourceDefinition>>>;
export type DeleteCustomSourceDefinitionResult = NonNullable<Awaited<ReturnType<typeof deleteCustomSourceDefinition>>>;
export type GrantSourceDefinitionToWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof grantSourceDefinitionToWorkspace>>
>;
export type RevokeSourceDefinitionFromWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof revokeSourceDefinitionFromWorkspace>>
>;
export type GetSourceDefinitionSpecificationResult = NonNullable<
  Awaited<ReturnType<typeof getSourceDefinitionSpecification>>
>;
export type CreateSourceResult = NonNullable<Awaited<ReturnType<typeof createSource>>>;
export type UpdateSourceResult = NonNullable<Awaited<ReturnType<typeof updateSource>>>;
export type ListSourcesForWorkspaceResult = NonNullable<Awaited<ReturnType<typeof listSourcesForWorkspace>>>;
export type GetSourceResult = NonNullable<Awaited<ReturnType<typeof getSource>>>;
export type SearchSourcesResult = NonNullable<Awaited<ReturnType<typeof searchSources>>>;
export type CloneSourceResult = NonNullable<Awaited<ReturnType<typeof cloneSource>>>;
export type DeleteSourceResult = NonNullable<Awaited<ReturnType<typeof deleteSource>>>;
export type CheckConnectionToSourceResult = NonNullable<Awaited<ReturnType<typeof checkConnectionToSource>>>;
export type CheckConnectionToSourceForUpdateResult = NonNullable<
  Awaited<ReturnType<typeof checkConnectionToSourceForUpdate>>
>;
export type DiscoverSchemaForSourceResult = NonNullable<Awaited<ReturnType<typeof discoverSchemaForSource>>>;
export type CreateDestinationDefinitionResult = NonNullable<Awaited<ReturnType<typeof createDestinationDefinition>>>;
export type UpdateDestinationDefinitionResult = NonNullable<Awaited<ReturnType<typeof updateDestinationDefinition>>>;
export type ListDestinationDefinitionsResult = NonNullable<Awaited<ReturnType<typeof listDestinationDefinitions>>>;
export type ListLatestDestinationDefinitionsResult = NonNullable<
  Awaited<ReturnType<typeof listLatestDestinationDefinitions>>
>;
export type GetDestinationDefinitionResult = NonNullable<Awaited<ReturnType<typeof getDestinationDefinition>>>;
export type DeleteDestinationDefinitionResult = NonNullable<Awaited<ReturnType<typeof deleteDestinationDefinition>>>;
export type ListPrivateDestinationDefinitionsResult = NonNullable<
  Awaited<ReturnType<typeof listPrivateDestinationDefinitions>>
>;
export type ListDestinationDefinitionsForWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof listDestinationDefinitionsForWorkspace>>
>;
export type CreateCustomDestinationDefinitionResult = NonNullable<
  Awaited<ReturnType<typeof createCustomDestinationDefinition>>
>;
export type GetDestinationDefinitionForWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof getDestinationDefinitionForWorkspace>>
>;
export type UpdateCustomDestinationDefinitionResult = NonNullable<
  Awaited<ReturnType<typeof updateCustomDestinationDefinition>>
>;
export type DeleteCustomDestinationDefinitionResult = NonNullable<
  Awaited<ReturnType<typeof deleteCustomDestinationDefinition>>
>;
export type GrantDestinationDefinitionToWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof grantDestinationDefinitionToWorkspace>>
>;
export type RevokeDestinationDefinitionFromWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof revokeDestinationDefinitionFromWorkspace>>
>;
export type GetDestinationDefinitionSpecificationResult = NonNullable<
  Awaited<ReturnType<typeof getDestinationDefinitionSpecification>>
>;
export type CreateDestinationResult = NonNullable<Awaited<ReturnType<typeof createDestination>>>;
export type UpdateDestinationResult = NonNullable<Awaited<ReturnType<typeof updateDestination>>>;
export type ListDestinationsForWorkspaceResult = NonNullable<Awaited<ReturnType<typeof listDestinationsForWorkspace>>>;
export type GetDestinationResult = NonNullable<Awaited<ReturnType<typeof getDestination>>>;
export type SearchDestinationsResult = NonNullable<Awaited<ReturnType<typeof searchDestinations>>>;
export type CheckConnectionToDestinationResult = NonNullable<Awaited<ReturnType<typeof checkConnectionToDestination>>>;
export type CheckConnectionToDestinationForUpdateResult = NonNullable<
  Awaited<ReturnType<typeof checkConnectionToDestinationForUpdate>>
>;
export type DeleteDestinationResult = NonNullable<Awaited<ReturnType<typeof deleteDestination>>>;
export type CloneDestinationResult = NonNullable<Awaited<ReturnType<typeof cloneDestination>>>;
export type CreateConnectionResult = NonNullable<Awaited<ReturnType<typeof createConnection>>>;
export type UpdateConnectionResult = NonNullable<Awaited<ReturnType<typeof updateConnection>>>;
export type ListConnectionsForWorkspaceResult = NonNullable<Awaited<ReturnType<typeof listConnectionsForWorkspace>>>;
export type ListAllConnectionsForWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof listAllConnectionsForWorkspace>>
>;
export type GetConnectionResult = NonNullable<Awaited<ReturnType<typeof getConnection>>>;
export type GetStateResult = NonNullable<Awaited<ReturnType<typeof getState>>>;
export type SearchConnectionsResult = NonNullable<Awaited<ReturnType<typeof searchConnections>>>;
export type DeleteConnectionResult = NonNullable<Awaited<ReturnType<typeof deleteConnection>>>;
export type SyncConnectionResult = NonNullable<Awaited<ReturnType<typeof syncConnection>>>;
export type ResetConnectionResult = NonNullable<Awaited<ReturnType<typeof resetConnection>>>;
export type CheckOperationResult = NonNullable<Awaited<ReturnType<typeof checkOperation>>>;
export type CreateOperationResult = NonNullable<Awaited<ReturnType<typeof createOperation>>>;
export type UpdateOperationResult = NonNullable<Awaited<ReturnType<typeof updateOperation>>>;
export type ListOperationsForConnectionResult = NonNullable<Awaited<ReturnType<typeof listOperationsForConnection>>>;
export type GetOperationResult = NonNullable<Awaited<ReturnType<typeof getOperation>>>;
export type DeleteOperationResult = NonNullable<Awaited<ReturnType<typeof deleteOperation>>>;
export type ExecuteSourceCheckConnectionResult = NonNullable<Awaited<ReturnType<typeof executeSourceCheckConnection>>>;
export type ExecuteSourceDiscoverSchemaResult = NonNullable<Awaited<ReturnType<typeof executeSourceDiscoverSchema>>>;
export type ExecuteDestinationCheckConnectionResult = NonNullable<
  Awaited<ReturnType<typeof executeDestinationCheckConnection>>
>;
export type ListMigrationsResult = NonNullable<Awaited<ReturnType<typeof listMigrations>>>;
export type ExecuteMigrationsResult = NonNullable<Awaited<ReturnType<typeof executeMigrations>>>;
export type SetInstancewideSourceOauthParamsResult = NonNullable<
  Awaited<ReturnType<typeof setInstancewideSourceOauthParams>>
>;
export type GetSourceOAuthConsentResult = NonNullable<Awaited<ReturnType<typeof getSourceOAuthConsent>>>;
export type CompleteSourceOAuthResult = NonNullable<Awaited<ReturnType<typeof completeSourceOAuth>>>;
export type GetDestinationOAuthConsentResult = NonNullable<Awaited<ReturnType<typeof getDestinationOAuthConsent>>>;
export type CompleteDestinationOAuthResult = NonNullable<Awaited<ReturnType<typeof completeDestinationOAuth>>>;
export type SetInstancewideDestinationOauthParamsResult = NonNullable<
  Awaited<ReturnType<typeof setInstancewideDestinationOauthParams>>
>;
export type WebBackendListConnectionsForWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof webBackendListConnectionsForWorkspace>>
>;
export type WebBackendListAllConnectionsForWorkspaceResult = NonNullable<
  Awaited<ReturnType<typeof webBackendListAllConnectionsForWorkspace>>
>;
export type WebBackendGetConnectionResult = NonNullable<Awaited<ReturnType<typeof webBackendGetConnection>>>;
export type WebBackendCreateConnectionResult = NonNullable<Awaited<ReturnType<typeof webBackendCreateConnection>>>;
export type WebBackendUpdateConnectionResult = NonNullable<Awaited<ReturnType<typeof webBackendUpdateConnection>>>;
export type WebBackendSearchConnectionsResult = NonNullable<Awaited<ReturnType<typeof webBackendSearchConnections>>>;
export type GetStateTypeResult = NonNullable<Awaited<ReturnType<typeof getStateType>>>;
export type WebBackendGetWorkspaceStateResult = NonNullable<Awaited<ReturnType<typeof webBackendGetWorkspaceState>>>;
export type ListJobsForResult = NonNullable<Awaited<ReturnType<typeof listJobsFor>>>;
export type GetJobInfoResult = NonNullable<Awaited<ReturnType<typeof getJobInfo>>>;
export type CancelJobResult = NonNullable<Awaited<ReturnType<typeof cancelJob>>>;
export type GetJobDebugInfoResult = NonNullable<Awaited<ReturnType<typeof getJobDebugInfo>>>;
export type GetHealthCheckResult = NonNullable<Awaited<ReturnType<typeof getHealthCheck>>>;
export type GetLogsResult = NonNullable<Awaited<ReturnType<typeof getLogs>>>;
export type GetOpenApiSpecResult = NonNullable<Awaited<ReturnType<typeof getOpenApiSpec>>>;
export type ExportArchiveResult = NonNullable<Awaited<ReturnType<typeof exportArchive>>>;
export type ImportArchiveResult = NonNullable<Awaited<ReturnType<typeof importArchive>>>;
export type ExportWorkspaceResult = NonNullable<Awaited<ReturnType<typeof exportWorkspace>>>;
export type UploadArchiveResourceResult = NonNullable<Awaited<ReturnType<typeof uploadArchiveResource>>>;
export type ImportIntoWorkspaceResult = NonNullable<Awaited<ReturnType<typeof importIntoWorkspace>>>;
