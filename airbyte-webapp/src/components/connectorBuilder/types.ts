import { JSONSchema7 } from "json-schema";
import * as yup from "yup";

import { SourceDefinitionSpecificationDraft } from "core/domain/connector";
import { PatchedConnectorManifest } from "core/domain/connectorBuilder/PatchedConnectorManifest";
import { AirbyteJSONSchema } from "core/jsonSchema/types";
import {
  ApiKeyAuthenticator,
  BasicHttpAuthenticator,
  BearerAuthenticator,
  DeclarativeOauth2AuthenticatorAllOf,
  DeclarativeStream,
  HttpRequesterAllOfAuthenticator,
  NoAuth,
  SessionTokenAuthenticator,
  DefaultPaginatorAllOfPaginationStrategy,
  RequestOption,
  SimpleRetrieverAllOfStreamSlicer,
} from "core/request/ConnectorManifest";

export interface BuilderFormInput {
  key: string;
  required: boolean;
  definition: AirbyteJSONSchema;
}

type BuilderFormAuthenticator = (
  | NoAuth
  | (Omit<DeclarativeOauth2AuthenticatorAllOf, "refresh_request_body"> & {
      refresh_request_body: Array<[string, string]>;
    })
  | ApiKeyAuthenticator
  | BearerAuthenticator
  | BasicHttpAuthenticator
  | SessionTokenAuthenticator
) & { type: string };

export interface BuilderFormValues {
  global: {
    connectorName: string;
    urlBase: string;
    authenticator: BuilderFormAuthenticator;
  };
  inputs: BuilderFormInput[];
  inferredInputOverrides: Record<string, Partial<AirbyteJSONSchema>>;
  streams: BuilderStream[];
}

export interface BuilderStream {
  name: string;
  urlPath: string;
  fieldPointer: string[];
  primaryKey: string[];
  httpMethod: "GET" | "POST";
  requestOptions: {
    requestParameters: Array<[string, string]>;
    requestHeaders: Array<[string, string]>;
    requestBody: Array<[string, string]>;
  };
  paginator?: {
    strategy: DefaultPaginatorAllOfPaginationStrategy;
    pageTokenOption: RequestOption;
    pageSizeOption?: RequestOption;
  };
  streamSlicer?: SimpleRetrieverAllOfStreamSlicer;
}

export const DEFAULT_BUILDER_FORM_VALUES: BuilderFormValues = {
  global: {
    connectorName: "",
    urlBase: "",
    authenticator: { type: "NoAuth" },
  },
  inputs: [],
  inferredInputOverrides: {},
  streams: [],
};

export const DEFAULT_BUILDER_STREAM_VALUES: BuilderStream = {
  name: "",
  urlPath: "",
  fieldPointer: [],
  primaryKey: [],
  httpMethod: "GET",
  requestOptions: {
    requestParameters: [],
    requestHeaders: [],
    requestBody: [],
  },
};

function getInferredInputList(values: BuilderFormValues): BuilderFormInput[] {
  if (values.global.authenticator.type === "ApiKeyAuthenticator") {
    return [
      {
        key: "api_key",
        required: true,
        definition: {
          type: "string",
          title: "API Key",
          airbyte_secret: true,
        },
      },
    ];
  }
  if (values.global.authenticator.type === "BearerAuthenticator") {
    return [
      {
        key: "api_key",
        required: true,
        definition: {
          type: "string",
          title: "API Key",
          airbyte_secret: true,
        },
      },
    ];
  }
  if (values.global.authenticator.type === "BasicHttpAuthenticator") {
    return [
      {
        key: "username",
        required: true,
        definition: {
          type: "string",
          title: "Username",
        },
      },
      {
        key: "password",
        required: true,
        definition: {
          type: "string",
          title: "Password",
          airbyte_secret: true,
        },
      },
    ];
  }
  if (values.global.authenticator.type === "OAuthAuthenticator") {
    return [
      {
        key: "client_id",
        required: true,
        definition: {
          type: "string",
          title: "Client ID",
          airbyte_secret: true,
        },
      },
      {
        key: "client_secret",
        required: true,
        definition: {
          type: "string",
          title: "Client secret",
          airbyte_secret: true,
        },
      },
      {
        key: "refresh_token",
        required: true,
        definition: {
          type: "string",
          title: "Refresh token",
          airbyte_secret: true,
        },
      },
    ];
  }
  if (values.global.authenticator.type === "SessionTokenAuthenticator") {
    return [
      {
        key: "username",
        required: false,
        definition: {
          type: "string",
          title: "Username",
        },
      },
      {
        key: "password",
        required: false,
        definition: {
          type: "string",
          title: "Password",
          airbyte_secret: true,
        },
      },
      {
        key: "session_token",
        required: false,
        definition: {
          type: "string",
          title: "Session token",
          description: "Session token generated by user (if provided username and password are not required)",
          airbyte_secret: true,
        },
      },
    ];
  }
  return [];
}

export function getInferredInputs(values: BuilderFormValues): BuilderFormInput[] {
  const inferredInputs = getInferredInputList(values);
  return inferredInputs.map((input) =>
    values.inferredInputOverrides[input.key]
      ? {
          ...input,
          definition: { ...input.definition, ...values.inferredInputOverrides[input.key] },
        }
      : input
  );
}

export const injectIntoValues = ["request_parameter", "header", "path", "body_data", "body_json"];
const nonPathRequestOptionSchema = yup
  .object()
  .shape({
    inject_into: yup.mixed().oneOf(injectIntoValues.filter((val) => val !== "path")),
    field_name: yup.string().required("form.empty.error"),
  })
  .notRequired()
  .default(undefined);

// eslint-disable-next-line no-useless-escape
export const timeDeltaRegex = /^(([\.\d]+?)y)?(([\.\d]+?)m)?(([\.\d]+?)w)?(([\.\d]+?)d)?$/;

export const builderFormValidationSchema = yup.object().shape({
  global: yup.object().shape({
    connectorName: yup.string().required("form.empty.error"),
    urlBase: yup.string().required("form.empty.error"),
    authenticator: yup.object({
      header: yup.mixed().when("type", {
        is: (type: string) => type === "ApiKeyAuthenticator" || type === "SessionTokenAuthenticator",
        then: yup.string().required("form.empty.error"),
        otherwise: (schema) => schema.strip(),
      }),
      token_refresh_endpoint: yup.mixed().when("type", {
        is: "OAuthAuthenticator",
        then: yup.string().required("form.empty.error"),
        otherwise: (schema) => schema.strip(),
      }),
      session_token_response_key: yup.mixed().when("type", {
        is: "SessionTokenAuthenticator",
        then: yup.string().required("form.empty.error"),
        otherwise: (schema) => schema.strip(),
      }),
      login_url: yup.mixed().when("type", {
        is: "SessionTokenAuthenticator",
        then: yup.string().required("form.empty.error"),
        otherwise: (schema) => schema.strip(),
      }),
      validate_session_url: yup.mixed().when("type", {
        is: "SessionTokenAuthenticator",
        then: yup.string().required("form.empty.error"),
        otherwise: (schema) => schema.strip(),
      }),
    }),
  }),
  streams: yup.array().of(
    yup.object().shape({
      name: yup.string().required("form.empty.error"),
      urlPath: yup.string().required("form.empty.error"),
      fieldPointer: yup.array().of(yup.string()),
      primaryKey: yup.array().of(yup.string()),
      httpMethod: yup.mixed().oneOf(["GET", "POST"]),
      requestOptions: yup.object().shape({
        requestParameters: yup.array().of(yup.array().of(yup.string())),
        requestHeaders: yup.array().of(yup.array().of(yup.string())),
        requestBody: yup.array().of(yup.array().of(yup.string())),
      }),
      paginator: yup
        .object()
        .shape({
          pageSizeOption: nonPathRequestOptionSchema,
          pageTokenOption: yup.object().shape({
            inject_into: yup.mixed().oneOf(injectIntoValues),
            field_name: yup.mixed().when("inject_into", {
              is: "path",
              then: (schema) => schema.strip(),
              otherwise: yup.string().required("form.empty.error"),
            }),
          }),
          strategy: yup
            .object({
              page_size: yup.mixed().when("type", {
                is: (val: string) => ["OffsetIncrement", "PageIncrement"].includes(val),
                then: yup.number().required("form.empty.error"),
                otherwise: yup.number(),
              }),
              cursor_value: yup.mixed().when("type", {
                is: "CursorPagination",
                then: yup.string().required("form.empty.error"),
                otherwise: (schema) => schema.strip(),
              }),
              stop_condition: yup.mixed().when("type", {
                is: "CursorPagination",
                then: yup.string(),
                otherwise: (schema) => schema.strip(),
              }),
              start_from_page: yup.mixed().when("type", {
                is: "PageIncrement",
                then: yup.string(),
                otherwise: (schema) => schema.strip(),
              }),
            })
            .notRequired()
            .default(undefined),
        })
        .notRequired()
        .default(undefined),
      streamSlicer: yup
        .object()
        .shape({
          cursor_field: yup.string().required("form.empty.error"),
          slice_values: yup.mixed().when("type", {
            is: "ListStreamSlicer",
            then: yup.array().of(yup.string()),
            otherwise: (schema) => schema.strip(),
          }),
          request_option: nonPathRequestOptionSchema,
          start_datetime: yup.mixed().when("type", {
            is: "DatetimeStreamSlicer",
            then: yup.string().required("form.empty.error"),
            otherwise: (schema) => schema.strip(),
          }),
          end_datetime: yup.mixed().when("type", {
            is: "DatetimeStreamSlicer",
            then: yup.string().required("form.empty.error"),
            otherwise: (schema) => schema.strip(),
          }),
          step: yup.mixed().when("type", {
            is: "DatetimeStreamSlicer",
            then: yup.string().matches(timeDeltaRegex, "form.pattern.error").required("form.empty.error"),
            otherwise: (schema) => schema.strip(),
          }),
          datetime_format: yup.mixed().when("type", {
            is: "DatetimeStreamSlicer",
            then: yup.string().required("form.empty.error"),
            otherwise: (schema) => schema.strip(),
          }),
          start_time_option: yup.mixed().when("type", {
            is: "DatetimeStreamSlicer",
            then: nonPathRequestOptionSchema,
            otherwise: (schema) => schema.strip(),
          }),
          end_time_option: yup.mixed().when("type", {
            is: "DatetimeStreamSlicer",
            then: nonPathRequestOptionSchema,
            otherwise: (schema) => schema.strip(),
          }),
          stream_state_field_start: yup.mixed().when("type", {
            is: "DatetimeStreamSlicer",
            then: yup.string(),
            otherwise: (schema) => schema.strip(),
          }),
          stream_state_field_end: yup.mixed().when("type", {
            is: "DatetimeStreamSlicer",
            then: yup.string(),
            otherwise: (schema) => schema.strip(),
          }),
          lookback_window: yup.mixed().when("type", {
            is: "DatetimeStreamSlicer",
            then: yup.string(),
            otherwise: (schema) => schema.strip(),
          }),
        })
        .notRequired()
        .default(undefined),
    })
  ),
});

function builderFormAuthenticatorToAuthenticator(
  globalSettings: BuilderFormValues["global"]
): HttpRequesterAllOfAuthenticator {
  if (globalSettings.authenticator.type === "OAuthAuthenticator") {
    return {
      ...globalSettings.authenticator,
      refresh_request_body: Object.fromEntries(globalSettings.authenticator.refresh_request_body),
    };
  }
  if (globalSettings.authenticator.type === "SessionTokenAuthenticator") {
    return {
      ...globalSettings.authenticator,
      api_url: globalSettings.urlBase,
    };
  }
  return globalSettings.authenticator as HttpRequesterAllOfAuthenticator;
}

export const convertToManifest = (values: BuilderFormValues): PatchedConnectorManifest => {
  const manifestStreams: DeclarativeStream[] = values.streams.map((stream) => {
    return {
      name: stream.name,
      primary_key: stream.primaryKey,
      retriever: {
        name: stream.name,
        primary_key: stream.primaryKey,
        requester: {
          name: stream.name,
          url_base: values.global?.urlBase,
          path: stream.urlPath,
          request_options_provider: {
            request_parameters: Object.fromEntries(stream.requestOptions.requestParameters),
            request_headers: Object.fromEntries(stream.requestOptions.requestHeaders),
            request_body_json: Object.fromEntries(stream.requestOptions.requestBody),
          },
          authenticator: builderFormAuthenticatorToAuthenticator(values.global),
          // TODO: remove these empty "config" values once they are no longer required in the connector manifest JSON schema
          config: {},
        },
        record_selector: {
          extractor: {
            field_pointer: stream.fieldPointer,
            config: {},
          },
        },
        paginator: stream.paginator
          ? {
              type: "DefaultPaginator",
              page_token_option: {
                ...stream.paginator.pageTokenOption,
                // ensures that empty field_name is not set, as connector builder server cannot accept a field_name if inject_into is set to 'path'
                field_name: stream.paginator.pageTokenOption?.field_name
                  ? stream.paginator.pageTokenOption?.field_name
                  : undefined,
              },
              page_size_option: stream.paginator.pageSizeOption,
              pagination_strategy: stream.paginator.strategy,
              url_base: values.global?.urlBase,
            }
          : { type: "NoPagination" },
        stream_slicer: stream.streamSlicer,
        config: {},
      },
      config: {},
    };
  });

  const allInputs = [...values.inputs, ...getInferredInputs(values)];

  const specSchema: JSONSchema7 = {
    $schema: "http://json-schema.org/draft-07/schema#",
    type: "object",
    required: allInputs.filter((input) => input.required).map((input) => input.key),
    properties: Object.fromEntries(allInputs.map((input) => [input.key, input.definition])),
    additionalProperties: true,
  };

  const spec: SourceDefinitionSpecificationDraft = {
    connectionSpecification: specSchema,
  };

  return {
    version: "0.1.0",
    check: {
      stream_names: [],
    },
    streams: manifestStreams,
    spec,
  };
};
